[
    {
        "project_id": 993475711,
        "content": "ðŸŒŸ <b>pwmenu</b> | Rust\n<br>\nðŸŽ¯ <b>Primary Use Case:</b>\nManaging audio settings on Linux systems using a launcher interface.\n<br>\nâœ¨ <b>Key Features:</b>\nâ€¢ Launcher-driven audio management\nâ€¢ PipeWire integration\nâ€¢ Support for multiple launchers (Fuzzel, Rofi, Walker, dmenu, custom)\nâ€¢ Font and XDG icon support\nâ€¢ System notifications\n<br>\nðŸ“– <b>Summary:</b>\npwmenu is a launcher-driven audio manager for Linux that allows users to control audio settings through their preferred launcher. It supports various launchers and offers compatibility with font and XDG icons for visual representation of audio controls.\n<br>\nðŸ”— <b>Links:</b>\nâ€¢ <a href=\"https://github.com/e-tho/pwmenu?embed=0\">View Project</a>\n================\n<a href='https://t.me/GitHub_Open_Source'>ðŸ”“ Open Source</a>",
        "media_url": "https://opengraph.githubassets.com/56e6a6b5289a7af1b7a19ccdd3cfec3671a8abf5d0fb8d0b8991de5d87e9421c/e-tho/pwmenu",
        "platform": "telegram",
        "quality_score": 0.5499999999999999
    },
    {
        "project_id": 1004995740,
        "content": "ðŸ”¥ <b>opcode</b> | TypeScript\n<br>\nðŸŽ¯ <b>Primary Use Case:</b>\nManaging Claude Code sessions and creating custom AI agents through a graphical user interface.\n<br>\nâœ¨ <b>Key Features:</b>\nâ€¢ Project & Session Management\nâ€¢ Custom AI Agents\nâ€¢ Usage Analytics Dashboard\nâ€¢ MCP Server Management\nâ€¢ Timeline & Checkpoints\n<br>\nðŸ“– <b>Summary:</b>\nOpcode is a desktop application built with Tauri 2 that provides a GUI for managing Claude Code sessions and creating custom agents. It aims to bridge the gap between command-line tools and a visual experience for AI-assisted development, offering features like usage tracking, project management, and background agent execution.\n<br>\nðŸ”— <b>Links:</b>\nâ€¢ <a href=\"https://github.com/winfunc/opcode?embed=0\">View Project</a>\nâ€¢ <a href=\"https://opcode.sh?embed=0\">Homepage</a>\n================\n<a href='https://t.me/GitHub_Open_Source'>ðŸ”“ Open Source</a>",
        "media_url": "https://opengraph.githubassets.com/fb62cd4ae82f7c2efcb9c0d9fba70cb02a17f69e4f46fcba71774f022d2a5e1c/winfunc/opcode",
        "platform": "telegram",
        "quality_score": 1.0000000000000002
    },
    {
        "project_id": 292014229,
        "content": "ðŸŒŸ <b>zellij</b> | Rust\n<br>\nðŸŽ¯ <b>Primary Use Case:</b>\nImproving terminal workflow and productivity for developers and ops personnel.\n<br>\nâœ¨ <b>Key Features:</b>\nâ€¢ Workspace management\nâ€¢ Terminal multiplexing\nâ€¢ Customizable layouts\nâ€¢ Multiplayer collaboration\nâ€¢ Floating and stacked panes\n<br>\nðŸ“– <b>Summary:</b>\nZellij is a terminal workspace and multiplexer written in Rust, designed for developers and ops-oriented users. It aims to provide a great out-of-the-box experience with advanced features like customizable layouts, multiplayer collaboration, floating/stacked panes, and a plugin system supporting WebAssembly.\n<br>\nðŸ”— <b>Links:</b>\nâ€¢ <a href=\"https://github.com/zellij-org/zellij?embed=0\">View Project</a>\nâ€¢ <a href=\"https://zellij.dev?embed=0\">Homepage</a>\n================\n<a href='https://t.me/GitHub_Open_Source'>ðŸ”“ Open Source</a>",
        "media_url": "https://repository-images.githubusercontent.com/292014229/b8e9df2e-3a36-4642-9e54-2edffb3a59ef",
        "platform": "telegram",
        "quality_score": 0.85
    },
    {
        "project_id": 967512112,
        "content": "ðŸŒŸ <b>qtap</b> | C\n<br>\nðŸŽ¯ <b>Primary Use Case:</b>\nUnderstanding and auditing egress network traffic for security, debugging, and API development purposes.\n<br>\nâœ¨ <b>Key Features:</b>\nâ€¢ Captures pre-encrypted network traffic\nâ€¢ Provides context about egress connections\nâ€¢ Identifies originating processes\nâ€¢ Operates out-of-band with minimal overhead\nâ€¢ Supports security auditing\n<br>\nðŸ“– <b>Summary:</b>\nQtap is an eBPF agent designed to capture pre-encrypted network traffic on Linux systems. It provides visibility into egress connections and their originating processes by intercepting data before and after encryption, offering rich context without requiring application modifications or proxies.\n<br>\nðŸ”— <b>Links:</b>\nâ€¢ <a href=\"https://github.com/qpoint-io/qtap?embed=0\">View Project</a>\nâ€¢ <a href=\"https://qpoint.io/qtap?embed=0\">Homepage</a>\n================\n<a href='https://t.me/GitHub_Open_Source'>ðŸ”“ Open Source</a>",
        "media_url": "https://repository-images.githubusercontent.com/967512112/f8898d6a-10a1-494e-a05b-3f465d0d72e7",
        "platform": "telegram",
        "quality_score": 1.0000000000000002
    },
    {
        "project_id": 117710726,
        "content": "âœ¨ <b>twirp</b> | Go\n<br>\nðŸŽ¯ <b>Primary Use Case:</b>\nService-to-service communication\n<br>\nâœ¨ <b>Key Features:</b>\nâ€¢ RPC framework\nâ€¢ Protobuf service definitions\nâ€¢ Code generation (routing, serialization, clients)\nâ€¢ HTTP 1.1 support\nâ€¢ JSON serialization\n<br>\nðŸ“– <b>Summary:</b>\nTwirp is a simple RPC framework that uses protobuf service definitions to generate routing and serialization, allowing developers to focus on application logic. It runs on the standard `net/http` server, supports HTTP 1.1 and JSON serialization, and provides autogenerated clients and error handling.\n<br>\nðŸ”— <b>Links:</b>\nâ€¢ <a href=\"https://github.com/twitchtv/twirp?embed=0\">View Project</a>\nâ€¢ <a href=\"https://twitchtv.github.io/twirp/docs/intro.html?embed=0\">Homepage</a>\n================\n<a href='https://t.me/GitHub_Open_Source'>ðŸ”“ Open Source</a>",
        "media_url": "https://opengraph.githubassets.com/3400daccc2eae0e52f3e120a0788da373547181bd96a183a5610f7a854673fed/twitchtv/twirp",
        "platform": "telegram",
        "quality_score": 0.55
    },
    {
        "project_id": 987670088,
        "content": "ðŸŒŸ <b>crush</b> | Go\n<br>\nðŸŽ¯ <b>Primary Use Case:</b>\nAI-assisted coding within a terminal environment.\n<br>\nâœ¨ <b>Key Features:</b>\nâ€¢ Multi-Model support\nâ€¢ Flexible LLM switching\nâ€¢ Session-Based context management\nâ€¢ LSP-Enhanced code understanding\nâ€¢ Extensible capabilities via MCPs\n<br>\nðŸ“– <b>Summary:</b>\nCrush is an AI coding agent designed to be used within a terminal environment. It allows users to integrate Large Language Models (LLMs) into their existing coding workflows, offering features like multi-model support, session-based context management, and LSP-enhanced code understanding.\n<br>\nðŸ”— <b>Links:</b>\nâ€¢ <a href=\"https://github.com/charmbracelet/crush?embed=0\">View Project</a>\n================\n<a href='https://t.me/GitHub_Open_Source'>ðŸ”“ Open Source</a>",
        "media_url": "https://repository-images.githubusercontent.com/987670088/9247ccb4-650d-4811-ba21-a1b5b47b4e70",
        "platform": "telegram",
        "quality_score": 0.85
    }
]