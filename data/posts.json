[
    {
        "project_id": 600475150,
        "content": "ðŸš€ <b>Cosmos-Server</b> | JavaScript\n<br>\nðŸŽ¯ <b>Primary Use Case:</b>\nSecure self-hosting of applications and personal servers\n<br>\nâœ¨ <b>Key Features:</b>\nâ€¢ App Store for easy application installation and management with automatic updates and security checks\nâ€¢ Storage Manager for managing disks, including Parity Disks and MergerFS\nâ€¢ Network Storages based on RClone for managing remote storages and sharing NFS/FTP\n<br>\nðŸ“– <b>Summary:</b>\nCosmos is a secure gateway and server manager designed to protect self-hosted applications.  It features an app store, storage management, network storage capabilities, a reverse proxy, and a robust authentication server.  This allows users to easily install, manage, and secure their applications from a centralized, customizable dashboard.\n<br>\nðŸ”— <b>Links:</b>\nâ€¢ <a href=\"https://github.com/azukaar/Cosmos-Server?embed=0\">View Project</a>\nâ€¢ <a href=\"https://cosmos-cloud.io?embed=0\">Homepage</a>\n================\n<a href='https://t.me/GitHub_Open_Source'>ðŸ”“ Open Source</a>",
        "media_url": "https://opengraph.githubassets.com/ed0b2bae0ac48212c9d5b9f9c13f7601a4642401b9f5fea48cbc1093f92405c5/azukaar/Cosmos-Server",
        "platform": "telegram",
        "quality_score": 1.0
    },
    {
        "project_id": 400920341,
        "content": "ðŸš€ <b>Shell</b> | C++\n<br>\nðŸŽ¯ <b>Primary Use Case:</b>\nExtend and customize the Windows File Explorer context menu\n<br>\nâœ¨ <b>Key Features:</b>\nâ€¢ Lightweight and portable\nâ€¢ Customizable appearance\nâ€¢ Add custom context menu items (sub-menus, menu items, separators)\nâ€¢ Modify or remove existing context menu items\nâ€¢ Supports files, folders, desktop, taskbar\n<br>\nðŸ“– <b>Summary:</b>\nShell is a Windows context menu extender that allows users to add, modify, or remove context menu items.  It supports custom commands, various icon types, and a simple configuration file.  This enables users to create a highly personalized and efficient file management experience.\n<br>\nðŸ”— <b>Links:</b>\nâ€¢ <a href=\"https://github.com/moudey/Shell?embed=0\">View Project</a>\nâ€¢ <a href=\"https://nilesoft.org?embed=0\">Homepage</a>\n================\n<a href='https://t.me/GitHub_Open_Source'>ðŸ”“ Open Source</a>",
        "media_url": "https://opengraph.githubassets.com/d0179e6043262f2c88d97bc59b5a5a0fdcfa7e6f72e369a522684db9ed0d4c71/moudey/Shell",
        "platform": "telegram",
        "quality_score": 0.85
    },
    {
        "project_id": 718379614,
        "content": "ðŸŒŸ <b>gpt-crawler</b> | TypeScript\n<br>\nðŸŽ¯ <b>Primary Use Case:</b>\nCreating custom GPTs and assistants from website content\n<br>\nâœ¨ <b>Key Features:</b>\nâ€¢ Crawl websites to generate knowledge files\nâ€¢ Supports configuration via a config.ts file\nâ€¢ Allows specifying selectors for content extraction\nâ€¢ Provides options for limiting the number of crawled pages\nâ€¢ Outputs data to a JSON file\n<br>\nðŸ“– <b>Summary:</b>\nThis repository provides a crawler to extract data from websites, which can then be used to create custom GPTs or assistants on OpenAI.  It allows for configuration of the crawl parameters such as URL, selectors, and maximum pages. The extracted data is outputted as a JSON file.\n<br>\nðŸ”— <b>Links:</b>\nâ€¢ <a href=\"https://github.com/BuilderIO/gpt-crawler?embed=0\">View Project</a>\nâ€¢ <a href=\"https://www.builder.io/blog/custom-gpt?embed=0\">Homepage</a>\n================\n<a href='https://t.me/GitHub_Open_Source'>ðŸ”“ Open Source</a>",
        "media_url": "https://opengraph.githubassets.com/384301a5d2d37be56f1d72fcdf20eb93d271d286e7f0842593cfe4536bbe88c1/BuilderIO/gpt-crawler",
        "platform": "telegram",
        "quality_score": 0.8
    },
    {
        "project_id": 125883928,
        "content": "ðŸ”¥ <b>youtube_channel_archiver</b> | Shell\n<br>\nðŸŽ¯ <b>Primary Use Case:</b>\nArchiving YouTube channels by downloading all videos\n<br>\nâœ¨ <b>Key Features:</b>\nâ€¢ Download entire YouTube channels\nâ€¢ Update channel downloads without re-downloading existing videos\nâ€¢ Uses yt-dlp for video downloading\nâ€¢ Supports Linux and Windows\nâ€¢ Maintains a list of downloaded video IDs to avoid duplicates\n<br>\nðŸ“– <b>Summary:</b>\nThis repository provides configuration files and scripts to download and update YouTube channels using yt-dlp.  It tracks downloaded videos to prevent duplicates and supports both Linux and Windows.  The primary use case is creating a local archive of YouTube channels.\n<br>\nðŸ”— <b>Links:</b>\nâ€¢ <a href=\"https://github.com/dmn001/youtube_channel_archiver?embed=0\">View Project</a>\n================\n<a href='https://t.me/GitHub_Open_Source'>ðŸ”“ Open Source</a>",
        "media_url": "https://opengraph.githubassets.com/6ddc407f8367fc75589bff71b76bf87044a3333afb21588037e4c78afd28b701/dmn001/youtube_channel_archiver",
        "platform": "telegram",
        "quality_score": 0.55
    },
    {
        "project_id": 889646003,
        "content": "âœ¨ <b>diagram-as-code</b> | Jupyter Notebook\n<br>\nðŸŽ¯ <b>Primary Use Case:</b>\nCreating and managing diagrams for software projects, particularly architectural and flow diagrams, programmatically.\n<br>\nâœ¨ <b>Key Features:</b>\nâ€¢ Diagram as Code approach\nâ€¢ Python library\nâ€¢ creation of architectural infrastructure diagrams\nâ€¢ support for AWS, Azure, and GCP components\nâ€¢ generation of graphical images from code\n<br>\nðŸ“– <b>Summary:</b>\nThe Diagrams Python library implements a Diagram as Code approach, allowing users to generate various diagrams (including cloud infrastructure diagrams) from code.  This enables automated documentation, change control, and easy integration into software development workflows.  The library supports major cloud providers like AWS, Azure, and GCP.\n<br>\nðŸ”— <b>Links:</b>\nâ€¢ <a href=\"https://github.com/r0mymendez/diagram-as-code?embed=0\">View Project</a>\n================\n<a href='https://t.me/GitHub_Open_Source'>ðŸ”“ Open Source</a>",
        "media_url": "https://opengraph.githubassets.com/5b4e8ddad3e1352b9e0af5a7bf3c12d3e437ca3633990bc26f7b197166aaf212/r0mymendez/diagram-as-code",
        "platform": "telegram",
        "quality_score": 0.15
    },
    {
        "project_id": 242139417,
        "content": "ðŸŒŸ <b>slowapi</b> | Python\n<br>\nðŸŽ¯ <b>Primary Use Case:</b>\nRate limiting for Starlette and FastAPI applications\n<br>\nâœ¨ <b>Key Features:</b>\nâ€¢ Rate limiting for Starlette and FastAPI\nâ€¢ Support for sync and async HTTP endpoints\nâ€¢ Redis, memcached, and memory backends\nâ€¢ Single and multiple limit decorators\nâ€¢ Shared limits across routes\n<br>\nðŸ“– <b>Summary:</b>\nSlowAPI is a rate-limiting library built for Starlette and FastAPI frameworks.  It supports various backends for tracking limits and allows applying limits to individual endpoints or groups of endpoints.  The library is designed to handle high request volumes and offers both synchronous and asynchronous support.\n<br>\nðŸ”— <b>Links:</b>\nâ€¢ <a href=\"https://github.com/laurentS/slowapi?embed=0\">View Project</a>\nâ€¢ <a href=\"https://pypi.org/project/slowapi/?embed=0\">Homepage</a>\n================\n<a href='https://t.me/GitHub_Open_Source'>ðŸ”“ Open Source</a>",
        "media_url": "https://opengraph.githubassets.com/b81ce7beebe309dbcfef06e3e19de2b53d327dcab8ebaebf8c4c5b9e15184f1f/laurentS/slowapi",
        "platform": "telegram",
        "quality_score": 0.75
    },
    {
        "project_id": 610292163,
        "content": "âœ¨ <b>mail-server</b> | Rust\n<br>\nðŸŽ¯ <b>Primary Use Case:</b>\nSecure and modern all-in-one mail server\n<br>\nâœ¨ <b>Key Features:</b>\nâ€¢ JMAP server with Sieve scripts, WebSocket, Blob Management, and Quotas extensions\nâ€¢ IMAP4rev2 and IMAP4rev1 server with numerous extensions\nâ€¢ POP3 server with extensions, STLS, and SASL support\nâ€¢ ManageSieve server for managing Sieve scripts\nâ€¢ SMTP server with built-in DMARC, DKIM, SPF, and ARC support\n<br>\nðŸ“– <b>Summary:</b>\nThis repository provides an open-source mail server solution supporting JMAP, IMAP4, POP3, and SMTP protocols.  It features robust security measures, spam filtering, and advanced functionalities like distributed queues and message modification, making it suitable for various email handling needs.\n<br>\nðŸ”— <b>Links:</b>\nâ€¢ <a href=\"https://github.com/stalwartlabs/mail-server?embed=0\">View Project</a>\nâ€¢ <a href=\"https://stalw.art?embed=0\">Homepage</a>\n================\n<a href='https://t.me/GitHub_Open_Source'>ðŸ”“ Open Source</a>",
        "media_url": "https://opengraph.githubassets.com/7f6f5e4969f06b8d1808181b6ab81f62df95cd9e0dc73f8c866c42fd3b612b88/stalwartlabs/mail-server",
        "platform": "telegram",
        "quality_score": 1.05
    },
    {
        "project_id": 873824041,
        "content": "ðŸ’¡ <b>rustowl</b> | Rust\n<br>\nðŸŽ¯ <b>Primary Use Case:</b>\nDebugging and optimization of Rust code by visualizing ownership and lifetimes\n<br>\nâœ¨ <b>Key Features:</b>\nâ€¢ Visualizes Rust ownership and lifetimes\nâ€¢ Provides underlines to represent variable lifetimes (green: actual, blue: immutable borrow, purple: mutable borrow, orange: moved/function call, red: lifetime error)\n<br>\nðŸ“– <b>Summary:</b>\nRustOwl is a tool that visualizes ownership and lifetimes in Rust code to aid debugging and optimization.  It uses color-coded underlines to represent different states of variables and integrates with various editors via VSCode extension, Neovim plugin, Emacs package, or a custom LSP client.  The tool analyzes Rust source code and provides visualizations upon hovering over variables or function calls.\n<br>\nðŸ”— <b>Links:</b>\nâ€¢ <a href=\"https://github.com/cordx56/rustowl?embed=0\">View Project</a>\n================\n<a href='https://t.me/GitHub_Open_Source'>ðŸ”“ Open Source</a>",
        "media_url": "https://opengraph.githubassets.com/99e8a78231baa669287d8675963cde9800884cc67fd87a40cfec0e261c8a47b0/cordx56/rustowl",
        "platform": "telegram",
        "quality_score": 0.9500000000000001
    }
]