[
    {
        "project_id": 999138733,
        "content": "ðŸ”¥ <b>ip-nose</b> | C++\n<br>\nðŸŽ¯ <b>Primary Use Case:</b>\nIP geolocation and information retrieval from the command line.\n<br>\nâœ¨ <b>Key Features:</b>\nâ€¢ IP Geolocation\nâ€¢ IP Detection\nâ€¢ Matrix-themed Interface\nâ€¢ Search History\nâ€¢ Customizable Configuration\n<br>\nðŸ“– <b>Summary:</b>\nip-nose is a C++ command-line tool for IP geolocation, providing detailed information about IP addresses. It features a unique Matrix-inspired interface, IP detection, search history, and customizable settings. It is designed for developers and network enthusiasts seeking a stylish and efficient IP geolocation solution.\n<br>\nðŸ”— <b>Links:</b>\nâ€¢ <a href=\"https://github.com/Karim93160/ip-nose?embed=0\">View Project</a>\nâ€¢ <a href=\"https://github.com/Karim93160/ip-nose?embed=0\">Homepage</a>\n================\n<a href='https://t.me/GitHub_Open_Source'>ðŸ”“ Open Source</a>",
        "media_url": "https://repository-images.githubusercontent.com/999138733/0a9596f8-6a73-4952-a6a1-dde0858dc177",
        "platform": "telegram",
        "quality_score": 0.7
    },
    {
        "project_id": 606311829,
        "content": "ðŸŒŸ <b>munal-os</b> | Rust\n<br>\nðŸŽ¯ <b>Primary Use Case:</b>\nAn experimental operating system for exploring OS design principles and WASM sandboxing.\n<br>\nâœ¨ <b>Key Features:</b>\nâ€¢ Unikernel design\nâ€¢ Cooperative scheduling\nâ€¢ WASM sandboxing for security\nâ€¢ Graphical interface with mouse and keyboard support\nâ€¢ Network driver and TCP stack\n<br>\nðŸ“– <b>Summary:</b>\nMunal OS is an experimental, Rust-based operating system employing a unikernel architecture and cooperative scheduling. It leverages WASM sandboxing to provide a secure environment for applications. The OS features a graphical interface, network stack, UI toolkit, and embedded applications, primarily using VirtIO drivers and avoiding traditional OS components like bootloaders and interrupts for simplicity.\n<br>\nðŸ”— <b>Links:</b>\nâ€¢ <a href=\"https://github.com/Askannz/munal-os?embed=0\">View Project</a>\n================\n<a href='https://t.me/GitHub_Open_Source'>ðŸ”“ Open Source</a>",
        "media_url": "https://opengraph.githubassets.com/22661dfe736c6787d1d686ed871621802c903c864bcc032d0ce69ec48abf9481/Askannz/munal-os",
        "platform": "telegram",
        "quality_score": 0.6
    },
    {
        "project_id": 362234372,
        "content": "ðŸ’¡ <b>cariddi</b> | Go\n<br>\nðŸŽ¯ <b>Primary Use Case:</b>\nSecurity scanning and reconnaissance of web applications to identify potential vulnerabilities and sensitive information exposure.\n<br>\nâœ¨ <b>Key Features:</b>\nâ€¢ Crawls URLs from a list of domains\nâ€¢ Scans for endpoints, secrets, API keys, file extensions, and tokens\n<br>\nðŸ“– <b>Summary:</b>\nCariddi is a Go-based tool designed for comprehensive web application reconnaissance. It crawls specified domains, identifies endpoints, and scans for sensitive information like secrets, API keys, and file extensions. The tool offers various scan options, supports multiple installation methods, and allows for customized configurations, making it suitable for security professionals and bug bounty hunters.\n<br>\nðŸ”— <b>Links:</b>\nâ€¢ <a href=\"https://github.com/edoardottt/cariddi?embed=0\">View Project</a>\nâ€¢ <a href=\"https://edoardottt.com/?embed=0\">Homepage</a>\n================\n<a href='https://t.me/GitHub_Open_Source'>ðŸ”“ Open Source</a>",
        "media_url": "https://opengraph.githubassets.com/184fc3a7be561628ddc52f046e50b67fd018f2f176d51980773eb4c497b48d49/edoardottt/cariddi",
        "platform": "telegram",
        "quality_score": 0.8500000000000001
    },
    {
        "project_id": 825345980,
        "content": "ðŸ’¡ <b>waypoint</b> | Go\n<br>\nðŸŽ¯ <b>Primary Use Case:</b>\nCreating and managing custom URL shorteners for internal tools, documentation, or any web resources.\n<br>\nâœ¨ <b>Key Features:</b>\nâ€¢ Human-readable Shortcuts\nâ€¢ Hierarchical Organization\nâ€¢ Real-time Updates\nâ€¢ Flexible Deployment\nâ€¢ Multiple Access Methods\n<br>\nðŸ“– <b>Summary:</b>\nWayPoint is a fast, lightweight URL mapping and redirection system that dynamically manages URL shortcuts through YAML configuration files. It offers features like human-readable shortcuts, hierarchical organization, real-time updates, and flexible deployment options. WayPoint can be used as a server for web access or integrated with the shell for command-line usage, making it ideal for creating and managing custom URL shorteners.\n<br>\nðŸ”— <b>Links:</b>\nâ€¢ <a href=\"https://github.com/NishantJoshi00/waypoint?embed=0\">View Project</a>\n================\n<a href='https://t.me/GitHub_Open_Source'>ðŸ”“ Open Source</a>",
        "media_url": "https://opengraph.githubassets.com/e30fcd98476047fd1cf5c0e74b46add01365c6a79c85f30b1b8a030d392bb8fa/NishantJoshi00/waypoint",
        "platform": "telegram",
        "quality_score": 0.3
    },
    {
        "project_id": 378998405,
        "content": "ðŸŒŸ <b>minecraft-building-assistance-game</b> | Python\n<br>\nðŸŽ¯ <b>Primary Use Case:</b>\nResearch and development of AI assistants for complex building tasks in Minecraft.\n<br>\nâœ¨ <b>Key Features:</b>\nâ€¢ Minecraft Building Assistance Game (MBAG) environment\nâ€¢ AssistanceZero training for AI assistants\n<br>\nðŸ“– <b>Summary:</b>\nThis repository provides the Minecraft Building Assistance Game (MBAG) environment for studying complex assistance games. It includes the implementation of AssistanceZero for training AI assistants and allows integration with Minecraft via Project Malmo. The repository also provides a house dataset for training and evaluation, enabling researchers to develop and test AI agents capable of assisting human players in building tasks within Minecraft.\n<br>\nðŸ”— <b>Links:</b>\nâ€¢ <a href=\"https://github.com/cassidylaidlaw/minecraft-building-assistance-game?embed=0\">View Project</a>\n================\n<a href='https://t.me/GitHub_Open_Source'>ðŸ”“ Open Source</a>",
        "media_url": "https://opengraph.githubassets.com/22eb004413e21c21d4a57d58aeda17a3a249574860ee7ee07be7bf5c9768d5dd/cassidylaidlaw/minecraft-building-assistance-game",
        "platform": "telegram",
        "quality_score": 0.7999999999999999
    },
    {
        "project_id": 963971159,
        "content": "ðŸš€ <b>Prompt2Flutter</b> | TypeScript\n<br>\nðŸŽ¯ <b>Primary Use Case:</b>\nTransforming text descriptions into Flutter applications\n<br>\nâœ¨ <b>Key Features:</b>\nâ€¢ Convert natural language descriptions into Flutter code\nâ€¢ Create complete Flutter projects with proper structure\nâ€¢ Manage Flutter dependencies automatically\nâ€¢ Generate UI components and app logic\nâ€¢ Support for Flutter best practices and patterns\n<br>\nðŸ“– <b>Summary:</b>\nPrompt2Flutter is a proof-of-concept project that uses AI, specifically Google's Gemini model, to convert natural language descriptions into fully functional Flutter applications. It aims to automate the process of Flutter app development by generating code, managing dependencies, and creating UI components based on user input.\n<br>\nðŸ”— <b>Links:</b>\nâ€¢ <a href=\"https://github.com/filippofinke/Prompt2Flutter?embed=0\">View Project</a>\nâ€¢ <a href=\"https://github.com/filippofinke/Prompt2Flutter?embed=0\">Homepage</a>\n================\n<a href='https://t.me/GitHub_Open_Source'>ðŸ”“ Open Source</a>",
        "media_url": "https://opengraph.githubassets.com/7a67e9b961ecf862f54d2359ac19ac27a27905e0945657c29f205df18be6d989/filippofinke/Prompt2Flutter",
        "platform": "telegram",
        "quality_score": 0.3
    },
    {
        "project_id": 859072628,
        "content": "ðŸ’¡ <b>napkins</b> | TypeScript\n<br>\nðŸŽ¯ <b>Primary Use Case:</b>\nGenerating applications from wireframes.\n<br>\nâœ¨ <b>Key Features:</b>\nâ€¢ Wireframe to app generation\nâ€¢ Powered by Llama 4 and Together.ai\nâ€¢ Code sandbox using Sandpack\nâ€¢ Image storage using S3\nâ€¢ Next.js app router with Tailwind CSS\n<br>\nðŸ“– <b>Summary:</b>\nThe napkins.dev repository provides an open-source wireframe-to-app generator. It leverages Llama 4 and Together.ai for LLM inference, Sandpack for a code sandbox environment, and S3 for image storage. The application is built using Next.js with Tailwind CSS, and incorporates Helicone for observability and Plausible for website analytics.\n<br>\nðŸ”— <b>Links:</b>\nâ€¢ <a href=\"https://github.com/Nutlope/napkins?embed=0\">View Project</a>\nâ€¢ <a href=\"https://www.napkins.dev/?embed=0\">Homepage</a>\n================\n<a href='https://t.me/GitHub_Open_Source'>ðŸ”“ Open Source</a>",
        "media_url": "https://opengraph.githubassets.com/f4b89c86b8ae22fc3e765c76c9350d5d491c06f54c5ac7ea9799a987bc65d78b/Nutlope/napkins",
        "platform": "telegram",
        "quality_score": 0.6
    },
    {
        "project_id": 40556106,
        "content": "âœ¨ <b>wazuh</b> | C\n<br>\nðŸŽ¯ <b>Primary Use Case:</b>\nThreat prevention, detection, and response across various environments (on-premises, virtualized, containerized, and cloud-based).\n<br>\nâœ¨ <b>Key Features:</b>\nâ€¢ Intrusion detection\nâ€¢ Log data analysis\nâ€¢ File integrity monitoring\nâ€¢ Vulnerability detection\nâ€¢ Configuration assessment\n<br>\nðŸ“– <b>Summary:</b>\nWazuh is an open-source security platform that provides XDR and SIEM capabilities. It uses agents to collect data from endpoints, which is then analyzed by a central server. Wazuh integrates with the Elastic Stack for data visualization and offers features like intrusion detection, log analysis, file integrity monitoring, vulnerability detection, configuration assessment, and incident response.\n<br>\nðŸ”— <b>Links:</b>\nâ€¢ <a href=\"https://github.com/wazuh/wazuh?embed=0\">View Project</a>\nâ€¢ <a href=\"https://wazuh.com/?embed=0\">Homepage</a>\n================\n<a href='https://t.me/GitHub_Open_Source'>ðŸ”“ Open Source</a>",
        "media_url": "https://opengraph.githubassets.com/79143de1fc41fe91fd962559c91fc729f04bb6822647b2ea5bd521ac3966064e/wazuh/wazuh",
        "platform": "telegram",
        "quality_score": 1.1000000000000003
    }
]