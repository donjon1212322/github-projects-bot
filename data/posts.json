[
    {
        "project_id": 65616765,
        "content": "ðŸš€ <b>lf</b> | Go\n<br>\nðŸŽ¯ <b>Primary Use Case:</b>\nTerminal-based file management.\n<br>\nâœ¨ <b>Key Features:</b>\nâ€¢ Cross-platform compatibility\nâ€¢ Single binary with no runtime dependencies\nâ€¢ Fast startup and low memory footprint\nâ€¢ Asynchronous IO operations\nâ€¢ Server/client architecture and remote commands\n<br>\nðŸ“– <b>Summary:</b>\nLF is a terminal file manager written in Go, designed for efficient file system navigation and management. It offers cross-platform compatibility, a small footprint, and asynchronous operations. LF is highly customizable and extendable through shell commands, making it a powerful tool for users who prefer a terminal-based workflow.\n<br>\nðŸ”— <b>Links:</b>\nâ€¢ <a href=\"https://github.com/gokcehan/lf?embed=0\">View Project</a>\n================\n<a href='https://t.me/GitHub_Open_Source'>ðŸ”“ Open Source</a>",
        "media_url": "https://opengraph.githubassets.com/8fe586f3fc233413cd8f0c1aaef84c92137fc4ae97b4c830eed014faba2edc0b/gokcehan/lf",
        "platform": "telegram",
        "quality_score": 0.85
    },
    {
        "project_id": 964909544,
        "content": "ðŸš€ <b>telegram-scraper-TeleGraphite</b> | Python\n<br>\nðŸŽ¯ <b>Primary Use Case:</b>\nScraping and archiving posts from public Telegram channels, including extracting contact information and media.\n<br>\nâœ¨ <b>Key Features:</b>\nâ€¢ Fetches posts from multiple Telegram channels\nâ€¢ Saves posts as JSON files with contact exports\nâ€¢ Downloads and saves media files\nâ€¢ Deduplicates posts\nâ€¢ Runs once or continuously\n<br>\nðŸ“– <b>Summary:</b>\nTeleGraphite is a Python-based Telegram channel scraper that fetches posts from public channels and exports them to JSON format. It supports features like media downloading, deduplication, filtering, and scheduled execution. The tool is designed for archiving and analyzing Telegram channel content.\n<br>\nðŸ”— <b>Links:</b>\nâ€¢ <a href=\"https://github.com/hamodywe/telegram-scraper-TeleGraphite?embed=0\">View Project</a>\n================\n<a href='https://t.me/GitHub_Open_Source'>ðŸ”“ Open Source</a>",
        "media_url": "https://opengraph.githubassets.com/5b8a325394e680a15a0ad7208f8bdd082d8804fecce713743231a853007e8c9d/hamodywe/telegram-scraper-TeleGraphite",
        "platform": "telegram",
        "quality_score": 0.5499999999999999
    },
    {
        "project_id": 445594012,
        "content": "ðŸ’¡ <b>Hunt-Sleeping-Beacons</b> | C\n<br>\nðŸŽ¯ <b>Primary Use Case:</b>\nIdentifying sleeping beacons in C2 agents by analyzing callstacks and enumerating timers.\n<br>\nâœ¨ <b>Key Features:</b>\nâ€¢ Identifies unbacked memory regions in callstacks, indicative of unpacked or injected code.\nâ€¢ Detects non-executable memory pages, a common sleepmask technique.\n<br>\nðŸ“– <b>Summary:</b>\nHunt-Sleeping-Beacons is a callstack scanner designed to identify Indicators of Compromise (IOCs) associated with unpacked or injected C2 agents. It analyzes callstacks for suspicious memory regions, module stomping, abnormal intermodular calls, and return address spoofing. The tool also enumerates timers and their callbacks to detect timer-based sleepmasks, providing a comprehensive approach to detecting sleeping beacons.\n<br>\nðŸ”— <b>Links:</b>\nâ€¢ <a href=\"https://github.com/thefLink/Hunt-Sleeping-Beacons?embed=0\">View Project</a>\n================\n<a href='https://t.me/GitHub_Open_Source'>ðŸ”“ Open Source</a>",
        "media_url": "https://opengraph.githubassets.com/3ea3902262f1b225c60f0fb72feaf988d9665180e2e7e589ed0864218b2857ff/thefLink/Hunt-Sleeping-Beacons",
        "platform": "telegram",
        "quality_score": 0.35
    },
    {
        "project_id": 880183057,
        "content": "ðŸŒŸ <b>JShunter</b> | Go\n<br>\nðŸŽ¯ <b>Primary Use Case:</b>\nAnalyzing JavaScript files to extract endpoints and identify sensitive data.\n<br>\nâœ¨ <b>Key Features:</b>\nâ€¢ Endpoint Extraction\nâ€¢ Sensitive Data Detection\nâ€¢ Customizable Options\nâ€¢ Flexible Input\nâ€¢ Output Options\n<br>\nðŸ“– <b>Summary:</b>\nJShunter is a command-line tool designed for analyzing JavaScript files and extracting endpoints. It specializes in identifying sensitive data, such as API endpoints and potential security vulnerabilities. The tool supports flexible input options, customizable parameters, and output saving, making it an essential resource for bug bounty hunters and security researchers.\n<br>\nðŸ”— <b>Links:</b>\nâ€¢ <a href=\"https://github.com/cc1a2b/JShunter?embed=0\">View Project</a>\n================\n<a href='https://t.me/GitHub_Open_Source'>ðŸ”“ Open Source</a>",
        "media_url": "https://opengraph.githubassets.com/f86f1ee8a81e1c4e9dd17c2fee65f5f6f53b014408c7ef8639d28a99df0a289a/cc1a2b/JShunter",
        "platform": "telegram",
        "quality_score": 0.5
    },
    {
        "project_id": 907686106,
        "content": "ðŸ”¥ <b>TransPixar</b> | Python\n<br>\nðŸŽ¯ <b>Primary Use Case:</b>\nGenerating RGBA videos with transparency for visual effects (VFX) and interactive content creation.\n<br>\nâœ¨ <b>Key Features:</b>\nâ€¢ RGBA video generation\nâ€¢ Transparency support in text-to-video models\nâ€¢ Diffusion transformer (DiT) architecture\nâ€¢ LoRA-based fine-tuning\nâ€¢ Joint RGB and alpha channel generation\n<br>\nðŸ“– <b>Summary:</b>\nTransPixeler is a method for extending pretrained video models to generate RGBA videos, which include alpha channels for transparency. It uses a diffusion transformer architecture and LoRA-based fine-tuning to jointly generate RGB and alpha channels with high consistency, enabling the creation of diverse and realistic visual effects.\n<br>\nðŸ”— <b>Links:</b>\nâ€¢ <a href=\"https://github.com/wileewang/TransPixar?embed=0\">View Project</a>\n================\n<a href='https://t.me/GitHub_Open_Source'>ðŸ”“ Open Source</a>",
        "media_url": "https://opengraph.githubassets.com/367ca86b0f12815ff89625dd230b0fccd8991defe5c5278a71f4e6d36b1ddc65/wileewang/TransPixar",
        "platform": "telegram",
        "quality_score": 0.75
    },
    {
        "project_id": 34707448,
        "content": "âœ¨ <b>wpsploit</b> | Ruby\n<br>\nðŸŽ¯ <b>Primary Use Case:</b>\nExploiting WordPress vulnerabilities using Metasploit modules.\n<br>\nâœ¨ <b>Key Features:</b>\nâ€¢ WordPress exploitation using Metasploit\nâ€¢ Collection of exploit and auxiliary modules\nâ€¢ Based on WPScan Vulnerability Database\n<br>\nðŸ“– <b>Summary:</b>\nWPSploit is a repository containing Metasploit modules designed for exploiting WordPress vulnerabilities. It provides a collection of both exploit and auxiliary modules, leveraging the WPScan Vulnerability Database to target known weaknesses in WordPress installations.\n<br>\nðŸ”— <b>Links:</b>\nâ€¢ <a href=\"https://github.com/espreto/wpsploit?embed=0\">View Project</a>\n================\n<a href='https://t.me/GitHub_Open_Source'>ðŸ”“ Open Source</a>",
        "media_url": "https://opengraph.githubassets.com/8e60ccf8680c15e00a76f0f45fa7de9ed29bbb658b686393ad5491f311ea3433/espreto/wpsploit",
        "platform": "telegram",
        "quality_score": 0.45
    },
    {
        "project_id": 382835373,
        "content": "ðŸ”¥ <b>hoard</b> | Rust\n<br>\nðŸŽ¯ <b>Primary Use Case:</b>\nOrganizing and retrieving frequently used, complex command-line commands.\n<br>\nâœ¨ <b>Key Features:</b>\nâ€¢ Saves commands with name, description, namespace, and tags\nâ€¢ Customizable parameter tokens\nâ€¢ ChatGPT integration\nâ€¢ Shell plugin for autocomplete (bash, zsh, fish)\n<br>\nðŸ“– <b>Summary:</b>\nHoard is a command-line tool written in Rust that helps users organize and save frequently used commands. It allows users to store commands with names, descriptions, namespaces, and tags for easy retrieval. Hoard also offers features like customizable parameter tokens, ChatGPT integration, and shell plugins for autocomplete.\n<br>\nðŸ”— <b>Links:</b>\nâ€¢ <a href=\"https://github.com/Hyde46/hoard?embed=0\">View Project</a>\nâ€¢ <a href=\"https://hyde46.github.io/hoard/?embed=0\">Homepage</a>\n================\n<a href='https://t.me/GitHub_Open_Source'>ðŸ”“ Open Source</a>",
        "media_url": "https://opengraph.githubassets.com/c17a7ae21b05f946739666c3ac4a253aceefcae019a8006217622bf22561891f/Hyde46/hoard",
        "platform": "telegram",
        "quality_score": 0.55
    },
    {
        "project_id": 491527855,
        "content": "ðŸ”¥ <b>xdg-ninja</b> | Haskell\n<br>\nðŸŽ¯ <b>Primary Use Case:</b>\nAuditing and cleaning up a user's $HOME directory to ensure compliance with the XDG Base Directory Specification.\n<br>\nâœ¨ <b>Key Features:</b>\nâ€¢ Checks $HOME directory for non-XDG-compliant files and directories.\nâ€¢ Provides instructions on how to move files to appropriate XDG locations.\n<br>\nðŸ“– <b>Summary:</b>\nxdg-ninja is a shell script designed to scan your $HOME directory for files and directories that do not conform to the XDG Base Directory Specification. It identifies these misplaced items and provides instructions on how to relocate them to their proper XDG-compliant locations, helping users maintain a clean and organized home directory. The tool supports various installation methods and offers a configuration generator for x86_64 Linux systems.\n<br>\nðŸ”— <b>Links:</b>\nâ€¢ <a href=\"https://github.com/b3nj5m1n/xdg-ninja?embed=0\">View Project</a>\n================\n<a href='https://t.me/GitHub_Open_Source'>ðŸ”“ Open Source</a>",
        "media_url": "https://opengraph.githubassets.com/48633b7186369bef1ccd05e86f22dee507d008e75f771b4d8c3de9c42f75d7f6/b3nj5m1n/xdg-ninja",
        "platform": "telegram",
        "quality_score": 0.7
    }
]