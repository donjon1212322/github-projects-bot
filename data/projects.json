[
    {
        "id": 200275124,
        "name": "dicio-android",
        "description": "Dicio assistant app for Android",
        "url": "https://github.com/Stypox/dicio-android",
        "language": "Kotlin",
        "stars": 1070,
        "forks": 112,
        "created_at": "2019-08-02T17:43:01Z",
        "updated_at": "2025-09-19T10:08:24Z",
        "topics": [
            "android",
            "assistant",
            "assistive-technology",
            "dicio",
            "dicio-assistant",
            "personal-assistant",
            "personal-assistant-framework",
            "voice-assistant",
            "vosk"
        ],
        "quality_score": 0.7,
        "contributors_count": 0,
        "last_commit_date": "2025-07-06T11:32:28Z",
        "media_urls": [
            "https://repository-images.githubusercontent.com/200275124/34b32b65-7ea6-4a22-94b4-1b2e06f7b046"
        ],
        "homepage": "",
        "readme_summary": "Dicio is a free and open-source voice assistant for Android that operates on-device for privacy. It supports multiple languages and skills, providing both speech and graphical feedback. It utilizes Vosk for speech-to-text and offers various functionalities like searching, weather updates, lyrics, app opening, calculations, contact management, timers, time queries, navigation, and media control.",
        "key_features": [
            "Voice assistant",
            "On-device processing",
            "Multilanguage support",
            "Speech and graphical feedback",
            "Vosk STT engine",
            "Skills: search, weather, lyrics, open app, calculator, telephone, timer, current time, navigation, media"
        ],
        "primary_use_case": "Providing a private and versatile voice assistant experience on Android devices.",
        "open_issues": 89,
        "cover_image_prompt": "Imagine a friendly robot butler standing in a modern kitchen, listening intently to a user. The user speaks into a smartphone, and the butler visually represents the request: a weather icon appears above the butler's head, a calculator hovers nearby, and a map unfolds on the countertop. The robot seamlessly translates the spoken words into actions. Subtle UI elements float around the scene, showing snippets of code and language processing. The repository name, 'Dicio,' is subtly displayed on the robot's apron. The scene is brightly lit and inviting. The image should be in a clean, 3D isometric illustration style with vibrant colors."
    },
    {
        "id": 1055153288,
        "name": "onion-vanity-address",
        "description": "Fast Tor Onion Service vanity address generator",
        "url": "https://github.com/AlexanderYastrebov/onion-vanity-address",
        "language": "Go",
        "stars": 24,
        "forks": 0,
        "created_at": "2025-09-11T21:08:48Z",
        "updated_at": "2025-09-19T10:06:08Z",
        "topics": [
            "ed25519",
            "onion-services",
            "tor",
            "vanity"
        ],
        "quality_score": 0.5499999999999999,
        "contributors_count": 0,
        "last_commit_date": "2025-09-16T19:04:06Z",
        "media_urls": [
            "https://opengraph.githubassets.com/054e3d3cbc65a3339e0305bf498ff6d077a11d8c307aefad3abaccf32bc58050/AlexanderYastrebov/onion-vanity-address"
        ],
        "homepage": "",
        "readme_summary": "The `onion-vanity-address` repository provides a tool written in Go for generating Tor Onion Service v3 vanity addresses with a specified prefix. It boasts a fast search algorithm and offers both local installation and Docker image usage, including Kubernetes deployment for distributed searching.",
        "key_features": [
            "Fast vanity address generation for Tor Onion Services",
            "Supports prefix-based searching",
            "Offers local installation via `go install`",
            "Provides a Docker image for containerized usage",
            "Includes Kubernetes deployment manifest for distributed searching",
            "Performance of ~45 million keys checked per second"
        ],
        "primary_use_case": "Generating custom Tor Onion Service addresses with a desired prefix for improved memorability or branding.",
        "open_issues": 0,
        "cover_image_prompt": "Imagine a goldsmith meticulously crafting a shimmering onion, each layer representing a level of encryption. The goldsmith uses a set of specialized tools, resembling code editors and cryptographic keys, to carefully shape the onion. A holographic display nearby shows a Tor network visualization, with data packets flowing through the onion's layers. The scene is set in a futuristic workshop with soft, ambient lighting. Subtle digital elements, like glowing code snippets and data visualizations, are integrated into the scene. The image should be in a 3D isometric illustration style with intricate details and a vibrant color scheme."
    },
    {
        "id": 157766521,
        "name": "broot",
        "description": "A new way to see and navigate directory trees : https://dystroy.org/broot",
        "url": "https://github.com/Canop/broot",
        "language": "Rust",
        "stars": 11810,
        "forks": 256,
        "created_at": "2018-11-15T20:09:19Z",
        "updated_at": "2025-09-19T10:12:20Z",
        "topics": [
            "balanced-bfs-descent",
            "command-line",
            "command-line-tool",
            "fuzzy-search",
            "hacktoberfest",
            "linux",
            "rust",
            "tree"
        ],
        "quality_score": 0.95,
        "contributors_count": 0,
        "last_commit_date": "2025-09-18T13:38:21Z",
        "media_urls": [
            "https://repository-images.githubusercontent.com/157766521/1ba51500-61fb-11e9-8dff-9189928d6dbb"
        ],
        "homepage": "",
        "readme_summary": "Broot is a command-line tool written in Rust that provides a better way to navigate directory trees, find files, and launch commands. It aims to improve upon traditional tools like `tree` by offering features like fuzzy search, directory overview with unlisted items, and easy `cd` functionality.",
        "key_features": [
            "Directory tree overview with unlisted items",
            "Fuzzy search for files and directories",
            "Navigation with minimal keystrokes",
            "Toggling visibility of hidden and gitignored files",
            "Regular expression and content-based search",
            "File manipulation through verbs",
            "Integration with shell for `cd`"
        ],
        "primary_use_case": "Efficiently navigating and exploring directory structures, finding files, and executing commands within those directories.",
        "open_issues": 224,
        "cover_image_prompt": "A cartographer standing atop a mountain of folders, using a glowing compass to chart a path through a dense forest of files. The compass emits beams of light that illuminate hidden trails and shortcuts. A small screen on the cartographer's wrist displays a simplified map of the file system. The scene is set in a vibrant, stylized world with clear visual indicators of file types and directory structures. The composition is focused and clean, with a blue and green color scheme. The image should be in a 3D isometric illustration style with rich details and vibrant colors."
    },
    {
        "id": 716785366,
        "name": "slog-context",
        "description": "Use golang structured logging (slog) with context. Add and retrieve logger to and from context. Add attributes to context. Automatically read any custom context values, such as OpenTelemetry TraceID.",
        "url": "https://github.com/veqryn/slog-context",
        "language": "Go",
        "stars": 138,
        "forks": 6,
        "created_at": "2023-11-09T21:43:51Z",
        "updated_at": "2025-09-17T14:38:25Z",
        "topics": [
            "context",
            "golang",
            "golang-library",
            "logging",
            "opentelemetry",
            "slog",
            "structured-logging"
        ],
        "quality_score": 1.0000000000000002,
        "contributors_count": 0,
        "last_commit_date": "2025-08-29T07:35:22Z",
        "media_urls": [
            "https://opengraph.githubassets.com/c4121140161c17ab9ec9c57bc12977e35970b9c1e45ed0cf686fb9d3d259dfd8/veqryn/slog-context"
        ],
        "homepage": "",
        "readme_summary": "The `slog-context` Go library provides utilities for integrating structured logging (slog) with Go's context package. It allows adding and retrieving loggers from contexts, adding attributes to contexts for automatic inclusion in log lines, and extracting custom context values like OpenTelemetry TraceIDs for logging.",
        "key_features": [
            "Adding and retrieving loggers to/from context.",
            "Adding attributes to context for automatic inclusion in log lines.",
            "Extracting custom context values (e.g., OpenTelemetry TraceID) for logging.",
            "Compatibility with both standard library slog and logr.",
            "Support for prepending and appending attributes to log lines via a custom handler.",
            "Optional extractors for OpenTelemetry Trace/Span IDs and attributes added by sloghttp middleware."
        ],
        "primary_use_case": "Integrating structured logging with Go's context package for enhanced log enrichment and context-aware logging.",
        "open_issues": 1,
        "cover_image_prompt": "A skilled cartographer meticulously charting a vast, interconnected network of glowing cityscapes, each representing a different application. The cartographer uses a special quill that emits streams of light, symbolizing log data, which automatically attach to the relevant cityscapes. A magnifying glass reveals hidden details within each city, representing context attributes. A small screen displays a simplified code snippet showing the `slog-context` API. The scene is set in a futuristic library with soft, ambient lighting. The image should be in a 3D isometric illustration style with vibrant colors and intricate details."
    },
    {
        "id": 104261253,
        "name": "mage",
        "description": "a Make/rake-like dev tool using Go",
        "url": "https://github.com/magefile/mage",
        "language": "Go",
        "stars": 4459,
        "forks": 271,
        "created_at": "2017-09-20T19:52:55Z",
        "updated_at": "2025-09-19T09:59:48Z",
        "topics": [
            "buildscript",
            "go",
            "golang",
            "mage",
            "magefile",
            "make"
        ],
        "quality_score": 0.55,
        "contributors_count": 0,
        "last_commit_date": "2025-06-15T14:01:42Z",
        "media_urls": [
            "https://repository-images.githubusercontent.com/104261253/9b12d380-7570-11e9-9bab-1bf0e44fa7ee"
        ],
        "homepage": "https://magefile.org",
        "readme_summary": "Mage is a build tool similar to Make or Rake, but uses Go for writing build scripts. It allows developers to define build tasks as plain Go functions, which Mage then executes as targets, simplifying build processes and eliminating the complexities of traditional Makefiles.",
        "key_features": [
            "Uses Go for build scripts",
            "No external dependencies (besides Go)",
            "Supports multiple magefiles",
            "Customizable for different operating systems",
            "Can be used as a library"
        ],
        "primary_use_case": "Automating build processes and other development tasks using Go instead of Makefiles or similar tools.",
        "open_issues": 95,
        "cover_image_prompt": "A skilled artisan meticulously crafting a complex clockwork mechanism using gears made of Go code. The artisan carefully fits each gear into place, representing the precise execution of build tasks. The finished mechanism powers a miniature factory, efficiently producing software components. A blueprint on the workbench shows the overall design, with snippets of Go code integrated into the schematic. Digital particles flow around the gears, symbolizing the automated build process. The scene is set in a brightly lit workshop with a clean, organized aesthetic. The image should be in a 3D isometric illustration style with vibrant colors and sharp details."
    },
    {
        "id": 1018413020,
        "name": "GopherTube",
        "description": "A modern terminal user interface for searching and watching  YouTube videos using mpv and chafa",
        "url": "https://github.com/KrishnaSSH/GopherTube",
        "language": "Go",
        "stars": 253,
        "forks": 17,
        "created_at": "2025-07-12T07:51:28Z",
        "updated_at": "2025-09-19T10:08:39Z",
        "topics": [
            "chafa",
            "go",
            "golang",
            "terminal-based",
            "terminal-ui",
            "youtube",
            "youtube-dl"
        ],
        "quality_score": 0.85,
        "contributors_count": 0,
        "last_commit_date": "2025-08-30T06:40:59Z",
        "media_urls": [
            "https://repository-images.githubusercontent.com/1018413020/bd95d8b3-9b5a-419a-b037-0468ab03a231"
        ],
        "homepage": "",
        "readme_summary": "GopherTube is a terminal-based YouTube client written in Go. It allows users to search and watch YouTube videos directly from their terminal using `mpv` for playback and `yt-dlp` for downloading. The UI is minimal and keyboard-driven, leveraging `fzf` for a streamlined experience.",
        "key_features": [
            "Fast YouTube search (scrapes YouTube directly)",
            "Play videos with mpv",
            "Minimal terminal UI (fzf)",
            "Keyboard navigation",
            "TOML config",
            "Download videos with quality selection (yt-dlp)",
            "Downloads menu",
            "Thumbnail preview in downloads menu"
        ],
        "primary_use_case": "Searching and watching YouTube videos from the terminal.",
        "open_issues": 1,
        "cover_image_prompt": "A gopher wearing headphones, sitting in front of a glowing terminal that displays a YouTube video. The gopher is using a keyboard to control the video playback. Behind the gopher, a cascade of video thumbnails flows from the YouTube website into the terminal. Small code snippets and UI elements float around the gopher, subtly connecting the scene to software. The scene is set in a cozy, futuristic workspace with soft, ambient lighting. The image should be in a 3D isometric illustration style with vibrant colors and rich details."
    },
    {
        "id": 964567893,
        "name": "MIRIX",
        "description": "Mirix is a multi-agent personal assistant designed to track on-screen activities and answer user questions intelligently. By capturing real-time visual data and consolidating it into structured memories, Mirix transforms raw inputs into a rich knowledge base that adapts to your digital experiences.",
        "url": "https://github.com/Mirix-AI/MIRIX",
        "language": "Python",
        "stars": 1425,
        "forks": 156,
        "created_at": "2025-04-11T12:24:52Z",
        "updated_at": "2025-09-19T10:09:02Z",
        "topics": [
            "llm-agents",
            "llm-memory",
            "memory-agents",
            "personal-assistant"
        ],
        "quality_score": 1.0000000000000002,
        "contributors_count": 0,
        "last_commit_date": "2025-09-18T01:10:40Z",
        "media_urls": [
            "https://opengraph.githubassets.com/3de28689cb9db94fd548687452b1130d33d59a078022b49da9a6efe228402d0a/Mirix-AI/MIRIX"
        ],
        "homepage": "https://mirix.io/",
        "readme_summary": "MIRIX is a multi-agent personal assistant that learns and remembers user interactions by tracking on-screen activities and natural language conversations. It consolidates visual and textual data into a structured knowledge base, enabling intelligent responses and personalized assistance.",
        "key_features": [
            "Multi-Agent Memory System",
            "Screen Activity Tracking",
            "Privacy-First Design",
            "Advanced Search",
            "Multi-Modal Input"
        ],
        "primary_use_case": "Building a personal AI assistant with advanced memory capabilities.",
        "open_issues": 13,
        "cover_image_prompt": "A diligent librarian meticulously organizing memories represented as glowing orbs into a vast, interconnected digital library. The librarian uses a magnifying glass to examine each orb, extracting information and categorizing it into different sections labeled 'Episodic,' 'Semantic,' and 'Procedural.' Screens display real-time screen captures and conversation snippets being processed. The library is filled with subtle UI elements and data visualizations. The scene is set in a futuristic, yet cozy study with soft, warm lighting. The image should be in 3D isometric illustration style with rich details and vibrant colors."
    },
    {
        "id": 847453935,
        "name": "cli",
        "description": "Next generation autonomous AI agent for end-to-end testing of web & desktop",
        "url": "https://github.com/testdriverai/cli",
        "language": "JavaScript",
        "stars": 186,
        "forks": 27,
        "created_at": "2024-08-25T21:30:13Z",
        "updated_at": "2025-09-18T21:22:11Z",
        "topics": [],
        "quality_score": 0.85,
        "contributors_count": 0,
        "last_commit_date": "2025-09-10T00:09:04Z",
        "media_urls": [
            "https://opengraph.githubassets.com/5939430de2f98ae69767632e7fa319300025bb86208c0dc95f1d9206508453f8/testdriverai/cli"
        ],
        "homepage": null,
        "readme_summary": "TestDriver.ai is an autonomous AI agent designed for end-to-end testing of web and desktop applications. It uses AI vision and emulated mouse/keyboard actions to automate QA processes, offering advantages like easier setup, reduced maintenance, and broader application testing capabilities compared to traditional test frameworks.",
        "key_features": [
            "AI-powered vision and control",
            "End-to-end testing of web and desktop applications",
            "Black-box testing approach",
            "Natural language test instruction",
            "Integration with CI/CD via GitHub Actions"
        ],
        "primary_use_case": "Automating and scaling QA processes for web and desktop applications.",
        "open_issues": 0,
        "cover_image_prompt": "A diligent robot QA engineer meticulously testing a complex web application interface displayed on a large monitor. The robot uses its optical sensors to analyze the screen and its robotic arms to interact with the UI elements. The monitor displays various application screens, including forms, buttons, and data visualizations. Subtle digital particles flow around the robot, representing the flow of data and automated processes. Small UI elements and code snippets are subtly incorporated into the scene. The setting is a modern, brightly lit testing lab. The image should be in a 3D isometric illustration style with clean lines and vibrant colors."
    }
]