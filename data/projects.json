[
    {
        "id": 956393555,
        "name": "HackberryPiCM5",
        "description": "An ultra portable handheld Linux device using Raspberry CM5 unit as Core with 4\" 720X720 TFT Touch display and the original blackberry keyboard",
        "url": "https://github.com/ZitaoTech/HackberryPiCM5",
        "language": "HTML",
        "stars": 615,
        "forks": 36,
        "created_at": "2025-03-28T07:17:57Z",
        "updated_at": "2025-09-14T08:14:00Z",
        "topics": [],
        "quality_score": 0.55,
        "contributors_count": 0,
        "last_commit_date": "2025-07-09T15:08:39Z",
        "media_urls": [
            "https://opengraph.githubassets.com/5804b47684fb1d569038062cc9665e9681e37e3726e050642cf92ed232abc320/ZitaoTech/HackberryPiCM5"
        ],
        "homepage": null,
        "readme_summary": "The HackberryPi_CM5 project is about creating an ultra-portable, handheld Linux device powered by the Raspberry Pi CM5. It reuses Blackberry phone keyboards and aims to provide users with a deeper understanding of Linux and hardware/software architecture.",
        "key_features": [
            "Raspberry Pi CM5 compatibility",
            "Blackberry keyboard integration",
            "4\" 720x720 TFT touch display",
            "2242 NVME slot for SSD or AI accelerator",
            "Dual speakers via Bluetooth",
            "Aluminum and 3D-printed case",
            "RTC Battery"
        ],
        "primary_use_case": "Creating a portable, Linux-powered handheld computer for exploring hardware, software, and the Linux kernel.",
        "open_issues": 11,
        "cover_image_prompt": "A miniaturized Linux penguin tinkerer, hunched over a disassembled Blackberry phone, carefully extracting the keyboard. The penguin is integrating the keyboard into a sleek, metallic handheld device resembling a miniature computer. Wires and circuits subtly glow with digital energy. A small screen on the device displays a simplified Linux terminal. The scene is set in a brightly lit workshop filled with tools and components. The repository name, 'HackberryPi_CM5', is subtly etched onto a workbench. The image should be in a 3D isometric illustration style with clean lines and vibrant colors."
    },
    {
        "id": 1033259976,
        "name": "soundscope",
        "description": "A TUI app for analyzing audio data such as frequencies and loudness (LUFS)",
        "url": "https://github.com/bananaofhappiness/soundscope",
        "language": "Rust",
        "stars": 28,
        "forks": 0,
        "created_at": "2025-08-06T14:37:31Z",
        "updated_at": "2025-09-14T09:31:01Z",
        "topics": [
            "audio-analysis",
            "audio-visualizer",
            "cli",
            "rust",
            "tui"
        ],
        "quality_score": 0.5499999999999999,
        "contributors_count": 0,
        "last_commit_date": "2025-09-09T20:06:39Z",
        "media_urls": [
            "https://opengraph.githubassets.com/f153b889cdec2626dc88b7fec2808d1cbf4374b538da4378bda18e84557358f4/bananaofhappiness/soundscope"
        ],
        "homepage": "",
        "readme_summary": "Soundscope is a cross-platform command-line tool written in Rust for analyzing audio files and microphone input. It provides real-time analysis, including FFT spectrum visualization, waveform display, and LUFS metering, making it a comprehensive audio analysis solution for the terminal.",
        "key_features": [
            "Audio file and microphone input analysis",
            "FFT Spectrum visualization",
            "Waveform display",
            "LUFS metering and True Peak measurement"
        ],
        "primary_use_case": "Analyzing audio files and microphone input in the terminal for frequency distribution, amplitude over time, and loudness.",
        "open_issues": 0,
        "cover_image_prompt": "A sound engineer standing in front of a large mixing console, visualizing sound waves as colorful, tangible forms. The sound waves emanate from a microphone and an audio file loaded on a nearby computer, flowing into the console where they are analyzed and displayed as vibrant spectrums and waveforms. Small UI elements on the console show LUFS metering and frequency data. The scene is set in a modern recording studio with soft, ambient lighting. The image should be in 3D isometric illustration style with rich details and vibrant colors."
    },
    {
        "id": 1050783683,
        "name": "youtube-smart-speed",
        "description": "[TESTING]: Intelligent YouTube playback speed control using AI. Automatically speeds up during silence and slows down during speech. Fully configurable by user.",
        "url": "https://github.com/skorotkiewicz/youtube-smart-speed",
        "language": "JavaScript",
        "stars": 7,
        "forks": 0,
        "created_at": "2025-09-04T23:55:41Z",
        "updated_at": "2025-09-13T21:37:51Z",
        "topics": [
            "firefox",
            "playback-speed",
            "youtube"
        ],
        "quality_score": 0.6,
        "contributors_count": 0,
        "last_commit_date": "2025-09-05T01:38:16Z",
        "media_urls": [
            "https://opengraph.githubassets.com/b16cd04252dbe3a9a6cf3354d9a0b1d9c3aad5a07a147e17f088171c023f8ac5/skorotkiewicz/youtube-smart-speed"
        ],
        "homepage": "",
        "readme_summary": "The YouTube Smart Speed extension intelligently adjusts YouTube playback speed based on real-time audio analysis using AI. It speeds up during silence and slows down during speech, with user-configurable parameters and a machine learning component that adapts to usage patterns. The extension provides a seamless way to optimize YouTube viewing by automatically adjusting the playback speed to match the content.",
        "key_features": [
            "Intelligent speed control",
            "Adaptive acceleration",
            "Controlled deceleration",
            "Machine learning",
            "Manual speed control",
            "Full configuration"
        ],
        "primary_use_case": "Automatically adjusting YouTube playback speed based on audio analysis to optimize viewing experience.",
        "open_issues": 0,
        "cover_image_prompt": "Imagine a diligent film editor sitting at a digital workstation, carefully adjusting the speed of a film reel displayed on a large monitor. The editor uses a soundwave visualizer to identify silent moments, represented by quiet, still waters, and spoken sections, depicted as lively, flowing streams. The editor speeds up the reel during the silent waters and slows it down during the flowing streams. Small UI elements on the workstation show playback speed settings and AI training progress. The scene is set in a modern editing suite with soft, diffused lighting. The image should be in 3D isometric illustration style with clean lines and vibrant colors."
    },
    {
        "id": 958149597,
        "name": "answergit",
        "description": "AnswerGit is a platform that allows you to analyze Git repositories and ask AI questions about the code. It uses AI to provide detailed explanations and summaries of Git commands, workflows, and code structure, making it easier to understand and interact with code repositories.",
        "url": "https://github.com/TharaneshA/answergit",
        "language": "TypeScript",
        "stars": 64,
        "forks": 10,
        "created_at": "2025-03-31T18:13:25Z",
        "updated_at": "2025-09-14T08:31:57Z",
        "topics": [
            "ai",
            "answergit",
            "explanation",
            "gemini",
            "git",
            "git-repository",
            "github",
            "github-repositories",
            "github-repository",
            "github-search-repository",
            "repo",
            "repository",
            "vercel"
        ],
        "quality_score": 0.44999999999999996,
        "contributors_count": 0,
        "last_commit_date": "2025-08-08T12:13:37Z",
        "media_urls": [
            "https://opengraph.githubassets.com/238e8a120ba1a9798e3a63ee2bafede2ad1b47d97434f5d9d318da2cbf662f3c/TharaneshA/answergit"
        ],
        "homepage": "https://answergit.vercel.app",
        "readme_summary": "AnswerGit is an AI-powered platform designed to analyze Git repositories and provide intelligent insights about the code. It leverages Google's Gemini AI to offer detailed explanations, summaries of Git commands and workflows, and insights into code structure, making it easier to understand and interact with code repositories.",
        "key_features": [
            "AI-Powered Analysis using Google's Gemini AI",
            "Smart File Explorer for easy navigation",
            "Interactive Chat for asking questions about the codebase",
            "Modern UI with dark-mode interface built with TailwindCSS",
            "Real-time Updates for instant responses",
            "Responsive Design for desktop and mobile devices"
        ],
        "primary_use_case": "Analyzing and understanding Git repositories using AI.",
        "open_issues": 0,
        "cover_image_prompt": "A detective, Sherlock Holmes-esque, standing in a library filled with towering stacks of code files, using a magnifying glass that emits a soft, blue AI glow to examine a Git repository blueprint. The blueprint reveals the structure and dependencies of the code. Small UI elements float around the detective, showing snippets of code and AI-generated explanations. The scene is set in a dimly lit, classic library with warm lighting. The image should be in a 3D isometric illustration style with rich details and a vintage color scheme."
    },
    {
        "id": 1009192288,
        "name": "arch-cleaner",
        "description": "A bash script to perform routine maintenance and cleanup tasks on Arch Linux systems.",
        "url": "https://github.com/antonio-foti/arch-cleaner",
        "language": "Shell",
        "stars": 31,
        "forks": 1,
        "created_at": "2025-06-26T18:15:47Z",
        "updated_at": "2025-09-14T07:11:18Z",
        "topics": [
            "archlinux"
        ],
        "quality_score": 0.3,
        "contributors_count": 0,
        "last_commit_date": "2025-07-02T09:44:49Z",
        "media_urls": [
            "https://opengraph.githubassets.com/546c6d4b6f9191e090aecc0a7a13af00acea4a6aea1a14bac89303aa4a621b91/antonio-foti/arch-cleaner"
        ],
        "homepage": "",
        "readme_summary": "Arch-Cleaner is a bash script designed for Arch Linux systems to automate routine maintenance and cleanup tasks. It provides features such as system updates, removal of orphaned packages, cleaning the pacman cache and journal logs, and temporary file removal, aiming to keep the system clean and optimized.",
        "key_features": [
            "System updates (standard and aggressive)",
            "Removal of orphaned & unused packages",
            "Pacman cache cleaning",
            "Journal log cleaning",
            "Temporary file removal",
            "User cache cleaning",
            "Optional trash emptying",
            "Optional post-cleanup reboot"
        ],
        "primary_use_case": "Automating system maintenance and cleanup on Arch Linux systems.",
        "open_issues": 0,
        "cover_image_prompt": "A meticulous housekeeper robot tidying up a digital cityscape made of computer parts and server racks. The robot uses a vacuum cleaner to suck up dust bunnies made of old code files and broken dependencies. A small screen on the robot's chest displays the Arch-Cleaner logo and progress. One hand holds a trash bin labeled 'Orphaned Packages'. The cityscape glows with a clean, organized feel. The scene is set in a bright, futuristic environment with subtle data streams flowing in the background. The image should be in 3D isometric illustration style with clean lines and vibrant colors."
    },
    {
        "id": 1041382729,
        "name": "PyMax",
        "description": "Асинхронный Python-враппер для работы с внутренним API MAX Manager (Userbot). Упрощает автоматизацию и интеграцию.",
        "url": "https://github.com/noxzion/PyMax",
        "language": "Python",
        "stars": 17,
        "forks": 3,
        "created_at": "2025-08-20T12:05:40Z",
        "updated_at": "2025-09-14T09:06:37Z",
        "topics": [
            "api",
            "max",
            "max-api-selfbot",
            "max-api-userbot",
            "max-messenger",
            "maxapi-python",
            "pymax",
            "python",
            "selfbot",
            "userbot",
            "vk",
            "vkontakte",
            "websockets"
        ],
        "quality_score": 0.9,
        "contributors_count": 0,
        "last_commit_date": "2025-09-14T08:47:00Z",
        "media_urls": [
            "https://opengraph.githubassets.com/1eef205a6eb82adb583ed90751316b1bbb3234bd6903c978ed50d356a70a3583/noxzion/PyMax"
        ],
        "homepage": "",
        "readme_summary": "PyMax is an asynchronous Python wrapper for the Max Messenger API, designed for userbot automation. It provides an interface for sending messages, managing chats, and accessing message history via WebSocket, enabling developers to automate tasks within the Max messaging platform.",
        "key_features": [
            "Asynchronous API wrapper",
            "Message sending, editing, and deletion",
            "Chat and channel management",
            "Message history retrieval",
            "Login by phone number"
        ],
        "primary_use_case": "Automating tasks and interactions within the Max Messenger platform using a Python-based userbot.",
        "open_issues": 0,
        "cover_image_prompt": "A diligent clockwork messenger robot meticulously crafting and dispatching paper airplanes carrying messages across a bustling cityscape made of interconnected chat bubbles. The robot stands at a central control panel with glowing screens displaying message logs and chat interfaces. Digital particles swirl around the robot, subtly forming Python code snippets. The cityscape is vibrant and dynamic, with each chat bubble representing a different conversation. The repository name, 'PyMax,' is subtly displayed on the robot's chassis. The scene is in a 3D isometric illustration style with clean lines, bright colors, and a focus on clarity."
    },
    {
        "id": 896163475,
        "name": "YTSage",
        "description": "Modern YouTube downloader with a clean PySide6 interface. Download videos in any quality, extract audio, fetch subtitles, sponsorBlock, and view video metadata. Built with yt-dlp for reliable performance.",
        "url": "https://github.com/oop7/YTSage",
        "language": "Python",
        "stars": 2345,
        "forks": 153,
        "created_at": "2024-11-29T17:15:45Z",
        "updated_at": "2025-09-14T09:40:11Z",
        "topics": [
            "pyside6",
            "python",
            "youtube-dl",
            "youtube-downloader",
            "yt-dlp",
            "yt-dlp-gui"
        ],
        "quality_score": 0.9,
        "contributors_count": 0,
        "last_commit_date": "2025-09-09T11:55:49Z",
        "media_urls": [
            "https://opengraph.githubassets.com/2f08b051055f8bf077b392c41bc881157359364371214c1b9d482b1118020e60/oop7/YTSage"
        ],
        "homepage": "",
        "readme_summary": "YTSage is a modern, user-friendly YouTube downloader built with Python and PySide6. It leverages yt-dlp for reliable video downloading, audio extraction, subtitle fetching, and includes advanced features like SponsorBlock integration and playlist support, offering a seamless experience for users seeking a powerful yet simple downloading solution.",
        "key_features": [
            "Clean PySide6 interface",
            "Video downloading in any quality",
            "Audio extraction",
            "Subtitle fetching",
            "SponsorBlock integration",
            "Playlist support",
            "Multi-subtitle selection and merging",
            "Speed limiter",
            "Trim video sections",
            "Auto-update yt-dlp",
            "Save download path",
            "Custom commands",
            "Login with cookies"
        ],
        "primary_use_case": "Downloading YouTube videos, extracting audio, and fetching subtitles with a user-friendly interface and advanced features.",
        "open_issues": 4,
        "cover_image_prompt": "An artisan meticulously crafting a digital river from a YouTube stream, using a set of fine tools. The river flows into a pristine lake representing downloaded content, with options to filter for audio, video, and subtitles appearing as separate tributaries. Small UI elements showing download progress and format options float nearby. The scene is set in a bright, organized workshop with a large window overlooking a digital landscape. The repository name, 'YTSage,' is subtly etched onto one of the tools. The image should be in a 3D isometric illustration style with clean lines and vibrant colors."
    }
]