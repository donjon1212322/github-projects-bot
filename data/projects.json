[
    {
        "id": 65616765,
        "name": "lf",
        "description": "Terminal file manager",
        "url": "https://github.com/gokcehan/lf",
        "language": "Go",
        "stars": 8111,
        "forks": 330,
        "created_at": "2016-08-13T12:45:44Z",
        "updated_at": "2025-04-15T09:46:34Z",
        "topics": [
            "file-manager",
            "terminal"
        ],
        "quality_score": 0.85,
        "contributors_count": 0,
        "last_commit_date": "2025-04-13T01:14:00Z",
        "media_urls": [
            "https://opengraph.githubassets.com/8fe586f3fc233413cd8f0c1aaef84c92137fc4ae97b4c830eed014faba2edc0b/gokcehan/lf"
        ],
        "homepage": "",
        "readme_summary": "LF is a terminal file manager written in Go, designed for efficient file system navigation and management. It offers cross-platform compatibility, a small footprint, and asynchronous operations. LF is highly customizable and extendable through shell commands, making it a powerful tool for users who prefer a terminal-based workflow.",
        "key_features": [
            "Cross-platform compatibility",
            "Single binary with no runtime dependencies",
            "Fast startup and low memory footprint",
            "Asynchronous IO operations",
            "Server/client architecture and remote commands",
            "Extendable and configurable with shell commands",
            "Customizable keybindings"
        ],
        "primary_use_case": "Terminal-based file management.",
        "open_issues": 126,
        "cover_image_prompt": "Imagine a skilled librarian in a vast, digital library, effortlessly managing and organizing countless files represented as glowing books. The librarian, using a sleek, minimalist terminal interface, swiftly navigates through the shelves, rearranging and accessing files with ease. Digital particles swirl around the librarian, symbolizing the asynchronous IO operations. The library's architecture is clean and efficient, reflecting the single binary design. Small UI elements float nearby, displaying file paths and commands. The scene is bathed in soft, ambient light, creating a sense of calm efficiency. The image should be in a flat design style with clear iconography and a pastel color scheme."
    },
    {
        "id": 964909544,
        "name": "telegram-scraper-TeleGraphite",
        "description": "A fast and reliable Telegram channel scraper that fetches posts and exports them to JSON.",
        "url": "https://github.com/hamodywe/telegram-scraper-TeleGraphite",
        "language": "Python",
        "stars": 43,
        "forks": 3,
        "created_at": "2025-04-12T02:30:35Z",
        "updated_at": "2025-04-15T10:00:15Z",
        "topics": [
            "chanels",
            "telegram",
            "telegram-channel-scraper",
            "telegram-json",
            "telegram-scrape-channels",
            "telegram-scraper"
        ],
        "quality_score": 0.5499999999999999,
        "contributors_count": 0,
        "last_commit_date": "2025-04-15T08:32:41Z",
        "media_urls": [
            "https://opengraph.githubassets.com/5b8a325394e680a15a0ad7208f8bdd082d8804fecce713743231a853007e8c9d/hamodywe/telegram-scraper-TeleGraphite"
        ],
        "homepage": "",
        "readme_summary": "TeleGraphite is a Python-based Telegram channel scraper that fetches posts from public channels and exports them to JSON format. It supports features like media downloading, deduplication, filtering, and scheduled execution. The tool is designed for archiving and analyzing Telegram channel content.",
        "key_features": [
            "Fetches posts from multiple Telegram channels",
            "Saves posts as JSON files with contact exports",
            "Downloads and saves media files",
            "Deduplicates posts",
            "Runs once or continuously",
            "Filters posts by keywords or content type",
            "Schedules fetching"
        ],
        "primary_use_case": "Scraping and archiving posts from public Telegram channels, including extracting contact information and media.",
        "open_issues": 0,
        "cover_image_prompt": "Imagine a diligent librarian meticulously archiving telegram posts. She stands amidst towering shelves filled with glowing digital scrolls, each representing a telegram channel. She carefully extracts messages from incoming streams of data, represented by shimmering threads, and neatly files them into labeled JSON containers. A magnifying glass reveals contact details being extracted and stored. The scene is bathed in soft, ethereal light, highlighting the librarian's focused expression. Subtle UI elements float nearby, displaying channel names and data structures. The image should be in a detailed digital painting style with a focus on clarity and organization."
    },
    {
        "id": 445594012,
        "name": "Hunt-Sleeping-Beacons",
        "description": "Aims to identify sleeping beacons",
        "url": "https://github.com/thefLink/Hunt-Sleeping-Beacons",
        "language": "C",
        "stars": 582,
        "forks": 56,
        "created_at": "2022-01-07T17:03:44Z",
        "updated_at": "2025-04-10T08:03:11Z",
        "topics": [],
        "quality_score": 0.35,
        "contributors_count": 0,
        "last_commit_date": "2024-12-09T13:25:20Z",
        "media_urls": [
            "https://opengraph.githubassets.com/3ea3902262f1b225c60f0fb72feaf988d9665180e2e7e589ed0864218b2857ff/thefLink/Hunt-Sleeping-Beacons"
        ],
        "homepage": null,
        "readme_summary": "Hunt-Sleeping-Beacons is a callstack scanner designed to identify Indicators of Compromise (IOCs) associated with unpacked or injected C2 agents. It analyzes callstacks for suspicious memory regions, module stomping, abnormal intermodular calls, and return address spoofing. The tool also enumerates timers and their callbacks to detect timer-based sleepmasks, providing a comprehensive approach to detecting sleeping beacons.",
        "key_features": [
            "Identifies unbacked memory regions in callstacks, indicative of unpacked or injected code.",
            "Detects non-executable memory pages, a common sleepmask technique.",
            "Detects module stomping by analyzing memory page attributes.",
            "Identifies suspicious APC usage related to sleepmask implementations.",
            "Enumerates timers and their callbacks to detect timer-based sleepmasks.",
            "Detects abnormal intermodular calls (module proxying) used to bypass ETW stack tracing.",
            "Identifies return address spoofing by searching for jump gadget patterns in callstacks."
        ],
        "primary_use_case": "Identifying sleeping beacons in C2 agents by analyzing callstacks and enumerating timers.",
        "open_issues": 0,
        "cover_image_prompt": "A detective meticulously examining the inner workings of a clock tower, representing a computer system. The detective uses specialized tools to identify hidden, dormant mechanisms (sleeping beacons) within the complex machinery. Glowing threads of code subtly weave through the clockwork, highlighting the software aspect. The scene is set in a dimly lit, steampunk-inspired environment with intricate details. The image should be in a digital painting style with a focus on clarity and detail, emphasizing the investigative nature of the tool."
    },
    {
        "id": 880183057,
        "name": "JShunter",
        "description": "jshunter is a command-line tool designed for analyzing JavaScript files and extracting endpoints. This tool specializes in identifying sensitive data, such as API endpoints and potential security vulnerabilities, making it an essential resource for and bug bounty hunters and security researchers.",
        "url": "https://github.com/cc1a2b/JShunter",
        "language": "Go",
        "stars": 345,
        "forks": 43,
        "created_at": "2024-10-29T09:17:51Z",
        "updated_at": "2025-04-15T09:53:08Z",
        "topics": [
            "bugbounty",
            "bugbounty-tool",
            "bugbountytips",
            "cybersecurity",
            "hacker",
            "javascript",
            "javascript-tools",
            "jshunter",
            "osint-tool",
            "pentest",
            "pentest-tool",
            "pentesting",
            "security",
            "security-tools",
            "sensitive"
        ],
        "quality_score": 0.5,
        "contributors_count": 0,
        "last_commit_date": "2024-12-20T13:12:31Z",
        "media_urls": [
            "https://opengraph.githubassets.com/f86f1ee8a81e1c4e9dd17c2fee65f5f6f53b014408c7ef8639d28a99df0a289a/cc1a2b/JShunter"
        ],
        "homepage": "",
        "readme_summary": "JShunter is a command-line tool designed for analyzing JavaScript files and extracting endpoints. It specializes in identifying sensitive data, such as API endpoints and potential security vulnerabilities. The tool supports flexible input options, customizable parameters, and output saving, making it an essential resource for bug bounty hunters and security researchers.",
        "key_features": [
            "Endpoint Extraction",
            "Sensitive Data Detection",
            "Customizable Options",
            "Flexible Input",
            "Output Options"
        ],
        "primary_use_case": "Analyzing JavaScript files to extract endpoints and identify sensitive data.",
        "open_issues": 0,
        "cover_image_prompt": "A detective meticulously examining a tangled web of JavaScript code with a magnifying glass, revealing hidden API endpoints and sensitive data like glowing threads. The detective wears a fedora and trench coat, standing in a dimly lit, high-tech office filled with monitors displaying code snippets and network diagrams. The magnifying glass emits a beam of light that highlights vulnerabilities. The repository name, 'jshunter,' is subtly displayed on a monitor in the background. The image should be in a digital painting style with a focus on detail and dramatic lighting, using a color scheme of blues, greens, and oranges to represent security and discovery."
    },
    {
        "id": 907686106,
        "name": "TransPixar",
        "description": "CVPR2025",
        "url": "https://github.com/wileewang/TransPixar",
        "language": "Python",
        "stars": 825,
        "forks": 68,
        "created_at": "2024-12-24T06:37:35Z",
        "updated_at": "2025-04-15T06:14:25Z",
        "topics": [],
        "quality_score": 0.75,
        "contributors_count": 0,
        "last_commit_date": "2025-03-21T05:19:45Z",
        "media_urls": [
            "https://opengraph.githubassets.com/367ca86b0f12815ff89625dd230b0fccd8991defe5c5278a71f4e6d36b1ddc65/wileewang/TransPixar"
        ],
        "homepage": "",
        "readme_summary": "TransPixeler is a method for extending pretrained video models to generate RGBA videos, which include alpha channels for transparency. It uses a diffusion transformer architecture and LoRA-based fine-tuning to jointly generate RGB and alpha channels with high consistency, enabling the creation of diverse and realistic visual effects.",
        "key_features": [
            "RGBA video generation",
            "Transparency support in text-to-video models",
            "Diffusion transformer (DiT) architecture",
            "LoRA-based fine-tuning",
            "Joint RGB and alpha channel generation",
            "Consistency between RGB and alpha channels"
        ],
        "primary_use_case": "Generating RGBA videos with transparency for visual effects (VFX) and interactive content creation.",
        "open_issues": 15,
        "cover_image_prompt": "Imagine a digital artist meticulously layering transparent elements onto a video scene, creating stunning visual effects. The artist uses a specialized palette that blends RGB colors with shimmering alpha channels, represented by glowing particles. The video scene, displayed on a holographic screen, shows a cityscape with realistic smoke and reflections seamlessly integrated. Small UI elements around the artist display code snippets and alpha channel visualizations. The scene is set in a modern digital studio with soft, diffused lighting. The composition is clean and focused, emphasizing the layering process. The color scheme is vibrant, with blues and greens dominating. The image should be in 3D isometric illustration style with rich details and a futuristic feel."
    },
    {
        "id": 34707448,
        "name": "wpsploit",
        "description": "WPSploit - Exploiting Wordpress With Metasploit",
        "url": "https://github.com/espreto/wpsploit",
        "language": "Ruby",
        "stars": 226,
        "forks": 66,
        "created_at": "2015-04-28T04:04:42Z",
        "updated_at": "2025-04-15T07:36:19Z",
        "topics": [],
        "quality_score": 0.45,
        "contributors_count": 0,
        "last_commit_date": "2016-11-26T09:52:14Z",
        "media_urls": [
            "https://opengraph.githubassets.com/8e60ccf8680c15e00a76f0f45fa7de9ed29bbb658b686393ad5491f311ea3433/espreto/wpsploit"
        ],
        "homepage": null,
        "readme_summary": "WPSploit is a repository containing Metasploit modules designed for exploiting WordPress vulnerabilities. It provides a collection of both exploit and auxiliary modules, leveraging the WPScan Vulnerability Database to target known weaknesses in WordPress installations.",
        "key_features": [
            "WordPress exploitation using Metasploit",
            "Collection of exploit and auxiliary modules",
            "Based on WPScan Vulnerability Database"
        ],
        "primary_use_case": "Exploiting WordPress vulnerabilities using Metasploit modules.",
        "open_issues": 1,
        "cover_image_prompt": "A skilled locksmith meticulously picking the lock of a heavily fortified WordPress website, revealing its inner workings. The locksmith uses a set of Metasploit-branded lockpicks, each representing a different exploit module. Digital code streams out from the opened lock, forming a pathway to a treasure chest filled with data. Small screens display WPScan vulnerability reports and Metasploit console outputs. The scene is set in a dimly lit, high-tech workshop with a focus on the lock and locksmith. The image should be in a detailed digital painting style with a dramatic, suspenseful atmosphere."
    },
    {
        "id": 382835373,
        "name": "hoard",
        "description": "cli command organizer written in rust",
        "url": "https://github.com/Hyde46/hoard",
        "language": "Rust",
        "stars": 579,
        "forks": 26,
        "created_at": "2021-07-04T11:32:51Z",
        "updated_at": "2025-04-15T07:54:39Z",
        "topics": [
            "bash",
            "cli",
            "command",
            "command-line-tool",
            "gpt",
            "gpt-3",
            "organizer",
            "rust",
            "tool",
            "zsh"
        ],
        "quality_score": 0.55,
        "contributors_count": 0,
        "last_commit_date": "2024-06-13T06:40:11Z",
        "media_urls": [
            "https://opengraph.githubassets.com/c17a7ae21b05f946739666c3ac4a253aceefcae019a8006217622bf22561891f/Hyde46/hoard"
        ],
        "homepage": "https://hyde46.github.io/hoard/",
        "readme_summary": "Hoard is a command-line tool written in Rust that helps users organize and save frequently used commands. It allows users to store commands with names, descriptions, namespaces, and tags for easy retrieval. Hoard also offers features like customizable parameter tokens, ChatGPT integration, and shell plugins for autocomplete.",
        "key_features": [
            "Saves commands with name, description, namespace, and tags",
            "Customizable parameter tokens",
            "ChatGPT integration",
            "Shell plugin for autocomplete (bash, zsh, fish)"
        ],
        "primary_use_case": "Organizing and retrieving frequently used, complex command-line commands.",
        "open_issues": 18,
        "cover_image_prompt": "Imagine a librarian, the 'Command Keeper,' in a vast, glowing digital library, carefully organizing glowing orbs representing commands. Each orb is labeled with a name and description. The librarian uses a magical tool to categorize and tag the orbs, placing them into specific namespaces. Around the librarian, holographic screens display snippets of code and command structures. The library is filled with swirling digital particles, and the repository name, 'Hoard,' is subtly etched into the archway. The scene is in a 3D isometric illustration style with soft, ethereal lighting and a color scheme of blues, greens, and purples."
    },
    {
        "id": 491527855,
        "name": "xdg-ninja",
        "description": "A shell script which checks your $HOME for unwanted files and directories.",
        "url": "https://github.com/b3nj5m1n/xdg-ninja",
        "language": "Haskell",
        "stars": 2803,
        "forks": 154,
        "created_at": "2022-05-12T13:35:20Z",
        "updated_at": "2025-04-15T02:09:38Z",
        "topics": [
            "linux",
            "shell",
            "terminal",
            "xdg",
            "xdg-basedir",
            "xdg-compliance"
        ],
        "quality_score": 0.7,
        "contributors_count": 0,
        "last_commit_date": "2025-03-09T22:18:24Z",
        "media_urls": [
            "https://opengraph.githubassets.com/48633b7186369bef1ccd05e86f22dee507d008e75f771b4d8c3de9c42f75d7f6/b3nj5m1n/xdg-ninja"
        ],
        "homepage": "",
        "readme_summary": "xdg-ninja is a shell script designed to scan your $HOME directory for files and directories that do not conform to the XDG Base Directory Specification. It identifies these misplaced items and provides instructions on how to relocate them to their proper XDG-compliant locations, helping users maintain a clean and organized home directory. The tool supports various installation methods and offers a configuration generator for x86_64 Linux systems.",
        "key_features": [
            "Checks $HOME directory for non-XDG-compliant files and directories.",
            "Provides instructions on how to move files to appropriate XDG locations.",
            "Offers configurations based on Arch Wiki, Antidot, and user contributions.",
            "Supports manual installation, Nix, and Homebrew package managers.",
            "Provides a tool for automatically generating configuration files (x86_64 Linux)."
        ],
        "primary_use_case": "Auditing and cleaning up a user's $HOME directory to ensure compliance with the XDG Base Directory Specification.",
        "open_issues": 27,
        "cover_image_prompt": "A meticulous housekeeper, armed with a feather duster and magnifying glass, inspects the interior of a digital house ($HOME directory). The housekeeper identifies misplaced files (icons representing common config files) and gently guides them into labeled XDG-compliant folders. A small screen in the background displays the xdg-ninja logo and a simplified file system tree. The scene is brightly lit and cheerful, with a clean, organized aesthetic. The image should be in a 3D isometric illustration style with pastel colors and clear details."
    }
]