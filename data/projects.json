[
    {
        "id": 953873439,
        "name": "csswaf",
        "description": "A CSS-based NoJS Anti-BOT WAF (Proof of Concept)",
        "url": "https://github.com/yzqzss/csswaf",
        "language": "Go",
        "stars": 19,
        "forks": 0,
        "created_at": "2025-03-24T08:08:22Z",
        "updated_at": "2025-03-26T09:48:13Z",
        "topics": [],
        "quality_score": 0.55,
        "contributors_count": 0,
        "last_commit_date": "2025-03-24T16:12:21Z",
        "media_urls": [
            "https://opengraph.githubassets.com/dab04722f730c074dda455198255df3e8bb304e8b7832dd085bb2a92d9e3bebb/yzqzss/csswaf"
        ],
        "homepage": "",
        "readme_summary": "CSSWAF is a proof-of-concept anti-bot web application firewall that uses CSS to detect bots by analyzing the loading order of hidden images. It also employs honeypot techniques, such as invisible links and non-loading images, to further identify and block malicious bots. This project is intended for demonstration purposes only and should not be used in production environments.",
        "key_features": [
            "CSS-based anti-bot protection",
            "Honeypot implementation using empty.gif files and invisible links",
            "Backend measures image loading order to detect bots"
        ],
        "primary_use_case": "Protecting web applications from bot traffic using CSS and honeypot techniques.",
        "open_issues": 5,
        "cover_image_prompt": "A gatekeeper meticulously inspecting incoming traffic with a magnifying glass revealing hidden bots disguised as regular users. The gatekeeper uses CSS rules as filters, allowing legitimate users to pass through while blocking malicious bots. Digital particles representing CSS code subtly float around the gate. The repository name 'CSSWAF' is subtly etched on the gate. The scene is set at the entrance to a futuristic server city with bright, focused lighting. The image should be in flat design style with clear iconography and a vibrant color scheme."
    },
    {
        "id": 10157665,
        "name": "pussh",
        "description": "Parallel SSH, batch and command line oriented",
        "url": "https://github.com/bearstech/pussh",
        "language": "Shell",
        "stars": 170,
        "forks": 12,
        "created_at": "2013-05-19T15:56:26Z",
        "updated_at": "2025-03-26T09:22:35Z",
        "topics": [],
        "quality_score": 0.5,
        "contributors_count": 0,
        "last_commit_date": "2025-02-12T15:43:41Z",
        "media_urls": [
            "https://opengraph.githubassets.com/10ebacd7983c4f3f3b439de553ee3facd3e953da982958637a258af816b7c913/bearstech/pussh"
        ],
        "homepage": null,
        "readme_summary": "Pussh is a command-line tool for executing SSH commands in parallel across multiple servers. It supports batch execution, host-prefixed output, input/output redirection, and rate limiting to manage connection establishment. Pussh is designed for system administrators and developers who need to efficiently manage and interact with a large number of servers.",
        "key_features": [
            "Parallel SSH execution",
            "Batch command execution",
            "Command-line oriented",
            "Host-prefixed output",
            "Host list from file or stdin",
            "Piping support",
            "Per-host output collection",
            "Input/output redirection",
            "Remote command execution",
            "Rate limiting"
        ],
        "primary_use_case": "Parallel execution of SSH commands across multiple servers for system administration, configuration management, and data collection.",
        "open_issues": 0,
        "cover_image_prompt": "Imagine a skilled conductor leading an orchestra of servers. Each server, represented by a musical instrument, plays its part in perfect harmony, executing commands in parallel. The conductor, standing on a platform labeled 'pussh', orchestrates the performance with a baton that emits SSH connection signals. The output of each server's instrument flows into a central recording console, where it's neatly organized and labeled with the server's name. Subtle UI elements float around the orchestra, displaying real-time command execution status and server metrics. The scene is bathed in a soft, focused light, creating a sense of precision and control. The image should be in a 3D isometric illustration style with vibrant colors and rich details."
    },
    {
        "id": 937395875,
        "name": "supermassive",
        "description": "A distributed in-memory, durable key value database designed for massive amounts of critical data and low latency.",
        "url": "https://github.com/supermassivedb/supermassive",
        "language": "Go",
        "stars": 63,
        "forks": 8,
        "created_at": "2025-02-23T00:04:26Z",
        "updated_at": "2025-03-26T08:55:29Z",
        "topics": [
            "database",
            "distributed",
            "durable",
            "in-memory",
            "keyvalue",
            "replicated",
            "scaleable",
            "sharded"
        ],
        "quality_score": 0.7999999999999999,
        "contributors_count": 0,
        "last_commit_date": "2025-02-27T22:06:27Z",
        "media_urls": [
            "https://opengraph.githubassets.com/621ce941b82233b5836a869109739069289cfef5e3fdeab0ef3912ac8170ece5/supermassivedb/supermassive"
        ],
        "homepage": "https://supermassivedb.com",
        "readme_summary": "SuperMassive is a distributed, in-memory key-value database designed for massive scalability and low latency. It features automatic failover, self-healing capabilities, and a simple protocol, making it suitable for applications requiring high availability and performance. The database is designed to be fault-tolerant and self-healing, ensuring data durability and availability.",
        "key_features": [
            "Highly scalable",
            "Distributed",
            "Robust Health Checking System",
            "Smart Data Distribution",
            "Automatic Fail-over",
            "Parallel Read Operations",
            "Consistency Management",
            "Fault-tolerant",
            "Self-healing",
            "Simple Protocol",
            "Async Node Journal",
            "Multi-platform",
            "Thoroughly Tested"
        ],
        "primary_use_case": "Storing and retrieving massive amounts of critical data with low latency.",
        "open_issues": 1,
        "cover_image_prompt": "Imagine a vast, celestial library where constellations of data points swirl around a central, glowing orb representing SuperMassive. Librarians, depicted as server nodes, diligently organize and replicate these data constellations, ensuring no information is lost. A cosmic storm rages in the background, symbolizing potential data loss, but the librarians work tirelessly, automatically recovering and distributing data to maintain order. Subtle tech elements, like glowing server racks and data streams, are woven into the library's architecture. The scene is bathed in a cool, ethereal light with a palette of blues and purples. The illustration should be in a 3D isometric style with intricate details and a sense of grand scale."
    },
    {
        "id": 330932840,
        "name": "chrome-extension-YoK",
        "description": "chrome расширение для сайта kinopoisk.ru, перейди на страницу фильма и смотри",
        "url": "https://github.com/mrzlab630/chrome-extension-YoK",
        "language": "JavaScript",
        "stars": 130,
        "forks": 12,
        "created_at": "2021-01-19T09:48:54Z",
        "updated_at": "2025-03-26T02:43:35Z",
        "topics": [],
        "quality_score": 0.25,
        "contributors_count": 0,
        "last_commit_date": "2024-06-16T11:13:30Z",
        "media_urls": [
            "https://opengraph.githubassets.com/667695ba607cf4149f98321adad86bf3edfd0e85f5b932c5240c131b224745af/mrzlab630/chrome-extension-YoK"
        ],
        "homepage": null,
        "readme_summary": "This Chrome extension helps users find online streaming links for movies listed on kinopoisk.ru. It automates the process of searching for these links, making it easier to watch movies online.",
        "key_features": [
            "Finds links to movies on kinopoisk.ru",
            "Chrome extension"
        ],
        "primary_use_case": "Finding online streaming links for movies on the kinopoisk.ru website.",
        "open_issues": 1,
        "cover_image_prompt": "A film buff sitting in a cozy armchair, surrounded by movie posters, using a magnifying glass to examine a film reel. The reel transforms into a screen displaying links to watch the movie online. Small UI elements showing the Kinopoisk website subtly appear around the scene. The setting is a warmly lit study with a vintage feel. The image should be in a digital painting style with clear outlines and rich details."
    },
    {
        "id": 525717745,
        "name": "BiRefNet",
        "description": "[CAAI AIR'24] Bilateral Reference for High-Resolution Dichotomous Image Segmentation",
        "url": "https://github.com/ZhengPeng7/BiRefNet",
        "language": "Python",
        "stars": 2018,
        "forks": 152,
        "created_at": "2022-08-17T09:13:39Z",
        "updated_at": "2025-03-26T09:04:56Z",
        "topics": [
            "background-removal",
            "birefnet",
            "camouflaged-object-detection",
            "dichotomous-image-segmentation",
            "high-resolution-image-segmentation",
            "image-segmentation",
            "salient-object-detection"
        ],
        "quality_score": 0.8500000000000001,
        "contributors_count": 0,
        "last_commit_date": "2025-03-25T15:24:16Z",
        "media_urls": [
            "https://opengraph.githubassets.com/622cc16007512136c30e5aca4697ac728825a7b7903a9a0abfe160777f913647/ZhengPeng7/BiRefNet"
        ],
        "homepage": "https://www.birefnet.top",
        "readme_summary": "BiRefNet is designed for high-resolution dichotomous image segmentation, utilizing a bilateral reference approach. It excels in tasks such as salient object detection, camouflaged object detection, and background removal by effectively referencing both foreground and background information. The repository provides the official implementation of the BiRefNet model.",
        "key_features": [
            "High-Resolution Dichotomous Image Segmentation",
            "Bilateral Reference Approach",
            "Salient Object Detection",
            "Camouflaged Object Detection",
            "Background Removal"
        ],
        "primary_use_case": "High-resolution dichotomous image segmentation, particularly for tasks like salient object detection, camouflaged object detection, and background removal.",
        "open_issues": 16,
        "cover_image_prompt": "A skilled artisan meticulously crafting a high-resolution mosaic from two distinct sets of reference tiles. One set represents foreground elements (sharp, detailed), the other background (blurred, atmospheric). The artisan uses specialized tools to seamlessly blend these references, creating a final, cohesive image where the subject is perfectly isolated. Subtle UI elements display image segmentation masks and resolution metrics. The scene is set in a bright, modern studio with natural light. The image should be in a digital painting style with clean lines and vibrant colors, emphasizing the precision and artistry of the segmentation process."
    },
    {
        "id": 575865240,
        "name": "AstrBot",
        "description": "✨ 易上手的多平台 LLM 聊天机器人及开发框架 ✨ 平台支持 QQ、QQ频道、Telegram、微信、企微、飞书 | MCP 服务器、OpenAI、DeepSeek、Gemini、硅基流动、月之暗面、Ollama、OneAPI、Dify 等。附带 WebUI。",
        "url": "https://github.com/Soulter/AstrBot",
        "language": "Python",
        "stars": 6620,
        "forks": 400,
        "created_at": "2022-12-08T13:27:46Z",
        "updated_at": "2025-03-26T10:10:04Z",
        "topics": [
            "agent",
            "ai",
            "chatbot",
            "chatgpt",
            "docker",
            "gemini",
            "gpt",
            "llama",
            "llm",
            "mcp",
            "openai",
            "python",
            "qq",
            "qqbot",
            "qqchannel",
            "telegram"
        ],
        "quality_score": 1.2000000000000002,
        "contributors_count": 0,
        "last_commit_date": "2025-03-26T09:56:55Z",
        "media_urls": [
            "https://opengraph.githubassets.com/42153b4932e90469c0857b284716b908ab2caa7d86e301a75842c33cbf6e9523/Soulter/AstrBot"
        ],
        "homepage": "https://astrbot.app",
        "readme_summary": "AstrBot is a versatile chatbot framework that simplifies the creation of multi-platform conversational AI applications. It supports integration with various LLMs and messaging platforms, offering a plugin system for extensibility and a visual management panel for easy configuration. AstrBot enables developers to quickly build and deploy intelligent chatbots across different channels.",
        "key_features": [
            "LLM dialogue support (OpenAI, Gemini, Llama, etc.)",
            "Multi-platform support (QQ, Telegram, WeChat, etc.)",
            "Agent capabilities (code execution, web search, Dify integration)",
            "Plugin extension support",
            "Visual management panel"
        ],
        "primary_use_case": "Building multi-platform chatbot applications with LLM integration.",
        "open_issues": 170,
        "cover_image_prompt": "Imagine a friendly robot chef in a bustling kitchen, effortlessly juggling ingredients representing different messaging platforms (QQ, Telegram, WeChat icons on the ingredients). The chef uses a universal adapter (labeled 'AstrBot') to seamlessly combine these ingredients into delicious dishes (chat messages) served on various plates (platform interfaces). In the background, a glowing screen displays a simplified WebUI with configuration options. The kitchen is clean and modern, with subtle code snippets decorating the walls. The image should be in a vibrant, 3D isometric illustration style with clear iconography and a focus on ease of use."
    }
]