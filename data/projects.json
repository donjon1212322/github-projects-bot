[
    {
        "id": 847536268,
        "name": "ggh",
        "description": "Recall your SSH sessions (also search your SSH config file)",
        "url": "https://github.com/byawitz/ggh",
        "language": "Go",
        "stars": 663,
        "forks": 20,
        "created_at": "2024-08-26T03:51:16Z",
        "updated_at": "2025-04-08T09:25:18Z",
        "topics": [
            "ggh",
            "go",
            "ssh"
        ],
        "quality_score": 0.9500000000000001,
        "contributors_count": 0,
        "last_commit_date": "2025-03-27T18:29:02Z",
        "media_urls": [
            "https://repository-images.githubusercontent.com/847536268/2d789280-a752-4a1d-a53c-0e834801e475"
        ],
        "homepage": "",
        "readme_summary": "GGH is a Go-based utility that helps users quickly recall and execute SSH sessions. It allows users to search their SSH history and SSH config file, providing an interactive list of previous sessions and config listings. GGH acts as a wrapper around SSH, streamlining the process of connecting to remote servers.",
        "key_features": [
            "Recalls SSH sessions",
            "Searches SSH config file",
            "Interactive list of previous sessions",
            "Interactive filtered list of SSH config listings",
            "Non-interactive list of history and config"
        ],
        "primary_use_case": "Quickly recall and execute SSH sessions from history or SSH config file.",
        "open_issues": 10,
        "cover_image_prompt": "A seasoned librarian, surrounded by towering shelves filled with SSH configuration files represented as ancient tomes, effortlessly retrieves a specific session from memory. The librarian uses a glowing 'GGH' bookmark to instantly locate the correct tome, which then projects a holographic terminal window displaying the SSH session details. Subtle digital particles flow from the bookmark, connecting the physical books to the digital representation. The scene is set in a grand, yet modern library with soft, warm lighting. The image should be in a 3D isometric illustration style with rich details and a slightly whimsical feel."
    },
    {
        "id": 957782869,
        "name": "KeyForge3D",
        "description": "KeyForge3D is an app that turns a photo of a key into a 3D-printable STL file. Ideal for locksmiths and hobbyists, it analyzes the key's bitting pattern using image processing and generates an accurate 3D model for quick replication.",
        "url": "https://github.com/makalin/KeyForge3D",
        "language": "Python",
        "stars": 68,
        "forks": 9,
        "created_at": "2025-03-31T05:55:17Z",
        "updated_at": "2025-04-08T10:01:59Z",
        "topics": [],
        "quality_score": 0.7,
        "contributors_count": 0,
        "last_commit_date": "2025-04-04T03:30:09Z",
        "media_urls": [
            "https://opengraph.githubassets.com/a3b95e1b3b0ed6adc8df1c9f6b5edabb09d3738ba9caca3cc83050f3304d490b/makalin/KeyForge3D"
        ],
        "homepage": null,
        "readme_summary": "KeyForge3D is an application that allows users to create 3D-printable models of keys from photographs. It extracts the key's shape, analyzes the bitting pattern, generates a 3D model, and exports it as an STL file, making it useful for locksmiths and hobbyists who need to quickly replicate keys.",
        "key_features": [
            "Key Shape Extraction from photo",
            "Bitting Analysis",
            "3D Model Generation",
            "STL Export",
            "User-Friendly GUI",
            "Scalability"
        ],
        "primary_use_case": "Replicating keys using 3D printing based on a photo.",
        "open_issues": 1,
        "cover_image_prompt": "A skilled artisan meticulously crafting a key from a digital blueprint displayed on a holographic screen. The artisan uses specialized tools that convert the digital design into a physical key with precise bitting. The scene is set in a modern workshop filled with 3D printers and digital calipers. Subtle UI elements on the screen show the key's bitting code and 3D model. The workshop has soft, diffused lighting with a focus on the artisan's hands and the key being crafted. The image should be in a detailed digital painting style with realistic textures and vibrant colors."
    },
    {
        "id": 958975943,
        "name": "bird-photos-classifier",
        "description": null,
        "url": "https://github.com/madhavanmalolan/bird-photos-classifier",
        "language": "Python",
        "stars": 5,
        "forks": 0,
        "created_at": "2025-04-02T04:17:49Z",
        "updated_at": "2025-04-08T03:43:53Z",
        "topics": [],
        "quality_score": 0.44999999999999996,
        "contributors_count": 0,
        "last_commit_date": "2025-04-05T03:04:43Z",
        "media_urls": [
            "https://opengraph.githubassets.com/dff227102155dd00f6f3246be348c6986bccc0f5961a5d3587472f554b8b08e9/madhavanmalolan/bird-photos-classifier"
        ],
        "homepage": null,
        "readme_summary": "This repository provides a Python script that leverages Google's Gemini AI to identify bird species within photographs. It then automatically organizes these photos into distinct folders, each named after the identified bird species. This tool is particularly useful for bird photographers who need assistance in managing and categorizing their extensive collections of bird photos.",
        "key_features": [
            "Identifies bird species in photos using Google's Gemini AI",
            "Organizes photos into folders based on identified bird species"
        ],
        "primary_use_case": "Organizing bird photos by species using AI.",
        "open_issues": 0,
        "cover_image_prompt": "A birdwatcher, surrounded by a flurry of diverse bird photos, uses a magical magnifying glass powered by the Gemini AI to identify each species. As the AI identifies a bird, the photo is automatically sorted into a corresponding folder labeled with the bird's name. The scene is set in a bright, organized digital workspace with floating UI elements displaying bird names and folder structures. Small code snippets and data visualizations subtly connect the metaphor to the software. The composition is clean and focused with a vibrant color scheme. The image should be in a flat design style with clear iconography and rich details."
    },
    {
        "id": 836259792,
        "name": "netnscli",
        "description": "NetNSCLI is a lightweight Go-based CLI tool, built with Cobra, designed to create and manage local network testbeds effortlessly from YAML configurations.",
        "url": "https://github.com/pinoOgni/netnscli",
        "language": "Go",
        "stars": 23,
        "forks": 2,
        "created_at": "2024-07-31T13:25:53Z",
        "updated_at": "2025-04-08T08:28:59Z",
        "topics": [
            "cli",
            "linux",
            "local",
            "namespace",
            "network"
        ],
        "quality_score": 0.65,
        "contributors_count": 0,
        "last_commit_date": "2025-02-28T16:14:50Z",
        "media_urls": [
            "https://repository-images.githubusercontent.com/836259792/0ab3f486-43ff-4504-8a8d-c9db409ff9c7"
        ],
        "homepage": "",
        "readme_summary": "NetNSCLI is a Go-based CLI tool that simplifies the creation and management of local network testbeds. It uses YAML configurations to define network namespaces and their interconnections, allowing users to easily create, delete, and manage complex network environments for testing and development purposes. It can also generate shell scripts from YAML configurations for manual setup.",
        "key_features": [
            "Creates local network testbeds",
            "Manages network namespaces",
            "Uses YAML configurations",
            "Generates shell scripts from YAML"
        ],
        "primary_use_case": "Creating and managing local network testbeds for testing and experimentation.",
        "open_issues": 0,
        "cover_image_prompt": "A skilled network engineer orchestrating a miniature city made of interconnected servers and routers on a tabletop. The engineer uses a control panel with YAML configurations displayed on a screen to effortlessly create and manage the network infrastructure. Each building represents a network namespace, and glowing data streams flow between them. The scene is set in a brightly lit, modern lab with subtle code snippets and network diagrams in the background. The image should be in 3D isometric illustration style with clean lines, vibrant colors, and a focus on clarity and ease of understanding."
    },
    {
        "id": 15019962,
        "name": "tldr",
        "description": "üìö Collaborative cheatsheets for console commands",
        "url": "https://github.com/tldr-pages/tldr",
        "language": "Markdown",
        "stars": 54653,
        "forks": 4407,
        "created_at": "2013-12-08T07:34:43Z",
        "updated_at": "2025-04-08T10:08:51Z",
        "topics": [
            "android",
            "bsd",
            "cheatsheet",
            "cheatsheets",
            "command-line",
            "console",
            "documentation",
            "examples",
            "hacktoberfest",
            "help",
            "linux",
            "macos",
            "man-page",
            "manpages",
            "manual",
            "osx",
            "shell",
            "terminal",
            "tldr",
            "windows"
        ],
        "quality_score": 0.9500000000000001,
        "contributors_count": 0,
        "last_commit_date": "2025-04-07T14:38:24Z",
        "media_urls": [
            "https://repository-images.githubusercontent.com/15019962/aa6a8d00-b4a3-11ea-92f4-5cca1da75be2"
        ],
        "homepage": "https://tldr.sh",
        "readme_summary": "The tldr-pages repository offers a community-driven collection of simplified help pages for command-line tools, serving as a more approachable alternative to traditional man pages. It provides practical examples for common commands across various operating systems, accessible through multiple client options, making command-line usage easier for both beginners and experienced users.",
        "key_features": [
            "Community-maintained help pages for command-line tools",
            "Simpler and more approachable alternative to traditional man pages",
            "Collection of practical examples for common command-line tools across various operating systems (UNIX, Linux, macOS, Windows, etc.)",
            "Multiple client options for accessing the pages (Node.js, Python, Rust)"
        ],
        "primary_use_case": "Providing concise and practical examples for command-line tools to simplify their usage and make them more accessible to users of all levels.",
        "open_issues": 168,
        "cover_image_prompt": "Imagine a friendly librarian standing amidst towering shelves filled with dusty, complex manuals. The librarian holds a glowing tablet displaying concise, clear examples of command-line usage, instantly illuminating the relevant information. Digital particles representing simplified instructions float from the tablet, replacing the overwhelming text in the manuals. The repository name, 'tldr-pages,' is subtly etched on the librarian's desk. The scene is bathed in warm, inviting light, creating a sense of approachability. The image should be in a 3D isometric illustration style with vibrant colors and a focus on clarity."
    },
    {
        "id": 917864037,
        "name": "isd",
        "description": "isd (interactive systemd) ‚Äì a better way to work with systemd units",
        "url": "https://github.com/isd-project/isd",
        "language": "Python",
        "stars": 1540,
        "forks": 16,
        "created_at": "2025-01-16T19:37:15Z",
        "updated_at": "2025-04-08T09:52:46Z",
        "topics": [
            "cli",
            "systemctl",
            "systemd",
            "textual",
            "tui"
        ],
        "quality_score": 0.95,
        "contributors_count": 0,
        "last_commit_date": "2025-03-26T12:44:14Z",
        "media_urls": [
            "https://opengraph.githubassets.com/7b888b00147055af91a73f886f5a27c38f137129796d012772708742269d1501/isd-project/isd"
        ],
        "homepage": "https://isd-project.github.io/isd/",
        "readme_summary": "The `isd` repository provides an interactive TUI for managing systemd units, offering features like fuzzy searching, auto-refreshing previews, and customizable keybindings. It simplifies systemd management for both power users and newcomers by providing a more intuitive and efficient way to interact with systemd.",
        "key_features": [
            "Quickly switch between system and user units",
            "Fuzzy search units",
            "Auto refresh previews",
            "Quickly open outputs in a pager or editor",
            "Auto sudo prefixing if required",
            "Auto rescale depending on terminal window size (fluid design)",
            "Extensive command palette with many keyboard shortcuts",
            "Fully configurable keybindings",
            "Optional input state caching for common inputs",
            "Theme support",
            "YAML configuration file with auto-complete"
        ],
        "primary_use_case": "Interactive management of systemd units.",
        "open_issues": 9,
        "cover_image_prompt": "Imagine a skilled orchestra conductor meticulously managing a complex system of interconnected instruments. Each instrument represents a systemd unit, and the conductor uses an interactive control panel with glowing buttons and a clear display to start, stop, and monitor them. The conductor's movements are fluid and precise, reflecting the ease of use and control provided by the isd tool. Subtle UI elements float around the conductor, displaying unit status and logs. The scene is set in a modern, minimalist concert hall with soft, focused lighting. The image should be in a 3D isometric illustration style with vibrant colors and sharp details."
    },
    {
        "id": 724970183,
        "name": "FlexibleBottomSheet",
        "description": "üê¨ Advanced Compose Multiplatform bottom sheet for segmented sizing, non-modal type, and allows interaction behind the bottom sheet similar to Google Maps.",
        "url": "https://github.com/skydoves/FlexibleBottomSheet",
        "language": "Kotlin",
        "stars": 880,
        "forks": 41,
        "created_at": "2023-11-29T06:57:18Z",
        "updated_at": "2025-04-08T05:59:46Z",
        "topics": [
            "android",
            "animation",
            "bottomsheet",
            "jetpack-compose",
            "modal",
            "modal-bottom-sheets",
            "skydoves"
        ],
        "quality_score": 0.8500000000000001,
        "contributors_count": 0,
        "last_commit_date": "2025-01-21T00:43:14Z",
        "media_urls": [
            "https://repository-images.githubusercontent.com/724970183/09de9bcc-777e-4ee9-959c-0b2205dc8be6"
        ],
        "homepage": "",
        "readme_summary": "FlexibleBottomSheet is a Kotlin library that provides an advanced Compose Multiplatform bottom sheet implementation. It offers features like segmented sizing, a non-modal behavior allowing interaction behind the sheet, and extensive customization options for sheet sizes and state management. The library is designed for Android applications using Jetpack Compose and Kotlin Multiplatform.",
        "key_features": [
            "Segmented sizing",
            "Non-modal type",
            "Interaction behind the bottom sheet",
            "Customizable sheet sizes",
            "Sheet state monitoring"
        ],
        "primary_use_case": "Creating flexible and customizable bottom sheet components in Jetpack Compose Multiplatform applications.",
        "open_issues": 23,
        "cover_image_prompt": "A skilled architect meticulously adjusting the height of a multi-tiered building using a digital interface. Each tier represents a different level of expansion for a bottom sheet, from slightly raised to fully extended. The building's foundation allows interaction with the city behind it, symbolizing the non-modal nature of the bottom sheet. Subtle UI elements and code snippets are integrated into the building's design. The scene is set in a brightly lit, modern cityscape. The image should be in 3D isometric illustration style with clean lines and vibrant colors."
    },
    {
        "id": 90507660,
        "name": "java-interview",
        "description": "–í–æ–ø—Ä–æ—Å—ã –∏ –æ—Ç–≤–µ—Ç—ã –∫ –∏–Ω—Ç–µ—Ä–≤—å—é Java —Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫–∞",
        "url": "https://github.com/enhorse/java-interview",
        "language": "Batchfile",
        "stars": 5571,
        "forks": 1985,
        "created_at": "2017-05-07T04:00:38Z",
        "updated_at": "2025-04-08T09:25:41Z",
        "topics": [
            "interview",
            "interview-questions",
            "java"
        ],
        "quality_score": 0.7000000000000001,
        "contributors_count": 0,
        "last_commit_date": "2025-01-30T14:52:49Z",
        "media_urls": [
            "https://opengraph.githubassets.com/e0fdcebc909a922705879550e1241902954e67d0a138a890ce67a2cc6bf345fd/enhorse/java-interview"
        ],
        "homepage": "",
        "readme_summary": "This repository provides a comprehensive collection of Java interview questions and answers, covering a wide range of topics relevant to Java development. It serves as a valuable resource for Java developers preparing for job interviews, helping them to review key concepts and practice answering common interview questions.",
        "key_features": [
            "Java interview questions and answers",
            "Covers topics like OOP, JVM, Java Core, Collections, Multithreading, Databases, and more",
            "Includes questions on design patterns, web technologies, and testing"
        ],
        "primary_use_case": "Preparing for Java developer interviews",
        "open_issues": 22,
        "cover_image_prompt": "A seasoned Java instructor stands before a class of eager students, holding a glowing Java coffee cup that projects interview questions onto a holographic screen. The questions cover topics like OOP, JVM, and Java Core. The instructor gestures towards the screen, guiding students through the concepts. Subtle UI elements displaying code snippets and data structures float around the scene. The setting is a modern, minimalist classroom with warm, inviting lighting. The image should be in a 3D isometric illustration style with clean lines, vibrant colors, and a focus on clarity."
    },
    {
        "id": 855638312,
        "name": "segmantix",
        "description": "SegmantiX is a library that enables granular data access control on the user/role/tenant level",
        "url": "https://github.com/wizzdi/segmantix",
        "language": "Java",
        "stars": 7,
        "forks": 0,
        "created_at": "2024-09-11T07:55:36Z",
        "updated_at": "2025-04-08T00:21:12Z",
        "topics": [
            "access-control",
            "java",
            "multitenancy",
            "permissions"
        ],
        "quality_score": 0.6,
        "contributors_count": 0,
        "last_commit_date": "2025-03-03T21:51:33Z",
        "media_urls": [
            "https://opengraph.githubassets.com/750ba9d102a93a092e5330d4fc21f0f784ba050ad6add94abebbb8b136a08900/wizzdi/segmantix"
        ],
        "homepage": "https://wizzdi.com",
        "readme_summary": "SegmantiX is a Java library that provides robust multi-tenancy and data access control. It offers fine-grained security controls for managing permissions across users, roles, tenants, and instance groups. The library supports features like wildcard access, restricted data access, and operation-specific access, making it suitable for applications requiring secure and isolated environments.",
        "key_features": [
            "Multi-Tenancy Support",
            "Role-Based Access Control",
            "User-Level Permissions",
            "Instance Group Management",
            "Wildcard Access",
            "Restricted Data Access",
            "Operation-Specific Access",
            "Data Set Management"
        ],
        "primary_use_case": "Enabling granular data access control on the user/role/tenant level in Java applications.",
        "open_issues": 0,
        "cover_image_prompt": "Imagine a master locksmith standing before a massive vault door, meticulously crafting keys for different compartments within. Each key represents access for a specific user, role, or tenant. The vault door glows with a soft, secure light, and digital streams of data flow into and out of the compartments. Small screens display user roles and permissions. The scene is set in a futuristic data center with a clean, organized layout. The composition is focused and clear, with a blue and gold color scheme. The image should be in 3D isometric illustration style with rich details and vibrant colors."
    },
    {
        "id": 5389577,
        "name": "jsfuck",
        "description": "Write any JavaScript with 6 Characters: []()!+",
        "url": "https://github.com/aemkei/jsfuck",
        "language": "JavaScript",
        "stars": 8351,
        "forks": 675,
        "created_at": "2012-08-12T15:46:14Z",
        "updated_at": "2025-04-08T07:36:49Z",
        "topics": [],
        "quality_score": 0.8500000000000001,
        "contributors_count": 0,
        "last_commit_date": "2025-03-10T08:15:33Z",
        "media_urls": [
            "https://opengraph.githubassets.com/c2d8f87930bb99d05f0858806a88144a9accf9da523a4697a8b317b3b3081f80/aemkei/jsfuck"
        ],
        "homepage": "jsfuck.com",
        "readme_summary": "JSFuck is an esoteric JavaScript programming style that allows developers to write and execute code using only six characters. It is intended for educational purposes and can be run in environments like Node.js. The project demonstrates the flexibility and underlying mechanics of the JavaScript language.",
        "key_features": [
            "Write JavaScript code using only six characters: `[]()!+`",
            "Can be run in Node.js environment",
            "Educational programming style"
        ],
        "primary_use_case": "Esoteric and educational programming using a limited character set.",
        "open_issues": 28,
        "cover_image_prompt": "Imagine a skilled calligrapher meticulously writing a complex message on ancient parchment using only a set of six unique symbols. The calligrapher's brow is furrowed in concentration as they transform a modern digital message into this cryptic form. The parchment rests on a high-tech desk displaying a glowing JavaScript code snippet, subtly hinting at the underlying technology. The scene is bathed in soft, warm light, emphasizing the intricate details of the calligraphy. The illustration should be in a detailed digital painting style, reminiscent of classical art with a modern twist."
    }
]