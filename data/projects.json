[
    {
        "id": 825187044,
        "name": "ab-download-manager",
        "description": "A Download Manager that speeds up your downloads",
        "url": "https://github.com/amir1376/ab-download-manager",
        "language": "Kotlin",
        "stars": 9972,
        "forks": 551,
        "created_at": "2024-07-07T03:56:25Z",
        "updated_at": "2025-10-04T10:09:31Z",
        "topics": [
            "chrome",
            "compose",
            "compose-desktop",
            "compose-multiplatform",
            "desktop",
            "desktop-app",
            "download",
            "download-manager",
            "downloader",
            "downloadmanager",
            "firefox",
            "kotlin",
            "kotlin-multiplatform",
            "linux",
            "windows"
        ],
        "quality_score": 0.7499999999999999,
        "contributors_count": 0,
        "last_commit_date": "2025-09-28T02:15:00Z",
        "media_urls": [
            "https://repository-images.githubusercontent.com/825187044/e982f7e5-20e1-4842-a2f3-6281ef8b9f71"
        ],
        "homepage": "https://abdownloadmanager.com",
        "readme_summary": "AB Download Manager is a desktop application built with Kotlin that aims to accelerate and efficiently manage file downloads. It offers features like faster download speeds, download queue management, browser integration through extensions, and cross-platform compatibility (Windows, Linux, Mac).",
        "key_features": [
            "Faster Download Speed",
            "Queues and Schedulers",
            "Browser Extensions",
            "Multiplatform Support (Windows/Linux/Mac)",
            "Multiple Themes (Dark/Light)",
            "Free and Open Source"
        ],
        "primary_use_case": "Efficiently managing and accelerating file downloads on desktop computers.",
        "open_issues": 257,
        "cover_image_prompt": "A diligent librarian overseeing a vast digital archive, directing streams of data packets into designated folders with remarkable speed and precision. The librarian uses a control panel with glowing buttons and a small screen displaying download queues and progress. Browser windows float nearby, feeding download links to the librarian. The scene is set in a futuristic library with organized shelves and soft, ambient lighting. Small UI elements and data visualizations subtly connect the metaphor to software. The composition is clean and focused with a blue and purple color scheme. The image should be in a 3D isometric illustration style with rich details."
    },
    {
        "id": 33037215,
        "name": "docker-mailserver",
        "description": "Production-ready fullstack but simple mail server (SMTP, IMAP, LDAP, Antispam, Antivirus, etc.) running inside a container.",
        "url": "https://github.com/docker-mailserver/docker-mailserver",
        "language": "Shell",
        "stars": 17185,
        "forks": 1974,
        "created_at": "2015-03-28T14:56:28Z",
        "updated_at": "2025-10-04T08:28:05Z",
        "topics": [
            "antispam",
            "antivirus",
            "container",
            "docker",
            "dovecot",
            "fail2ban",
            "imap",
            "kubernetes",
            "ldap",
            "mail",
            "mailserver",
            "postfix",
            "rspamd",
            "smtp"
        ],
        "quality_score": 1.0000000000000002,
        "contributors_count": 0,
        "last_commit_date": "2025-10-02T15:45:06Z",
        "media_urls": [
            "https://repository-images.githubusercontent.com/33037215/533fdc00-7d03-11eb-808d-bfc8f3d87004"
        ],
        "homepage": "https://docker-mailserver.github.io/docker-mailserver/latest/",
        "readme_summary": "The docker-mailserver repository provides a production-ready, full-stack mail server solution within a Docker container. It includes essential components like Postfix, Dovecot, and anti-spam/anti-virus tools, configured primarily through configuration files rather than a SQL database, aiming for simplicity and ease of deployment.",
        "key_features": [
            "Containerized mail server (SMTP, IMAP, LDAP)",
            "Postfix with SMTP/LDAP authentication",
            "Dovecot with SASL, IMAP, POP3, LDAP, Sieve, and quotas",
            "Rspamd, Amavis, SpamAssassin, ClamAV for spam and virus protection",
            "OpenDKIM & OpenDMARC for email authentication",
            "Fail2ban for intrusion prevention",
            "LetsEncrypt support for SSL certificates",
            "SASLauthd with LDAP authentication",
            "OAuth2 authentication"
        ],
        "primary_use_case": "Setting up and managing a complete mail server infrastructure using Docker containers.",
        "open_issues": 81,
        "cover_image_prompt": "Imagine a diligent postal worker sorting letters inside a futuristic, transparent server room. Each letter represents an email, passing through various stations: one stamps out spam (Rspamd), another checks for viruses (ClamAV), and a final station authenticates the sender (OpenDKIM). Successfully processed letters are neatly delivered into labeled mailboxes (Dovecot). UI elements subtly display server logs and security metrics. The scene is brightly lit with a clean, organized composition. The image should be in a 3D isometric illustration style with vibrant colors and clear iconography."
    },
    {
        "id": 1056028586,
        "name": "small_projects",
        "description": "Source code of smaller projects.",
        "url": "https://github.com/mikeakohn/small_projects",
        "language": "Assembly",
        "stars": 22,
        "forks": 1,
        "created_at": "2025-09-13T08:41:14Z",
        "updated_at": "2025-10-04T08:04:53Z",
        "topics": [],
        "quality_score": 0.44999999999999996,
        "contributors_count": 0,
        "last_commit_date": "2025-09-29T21:45:35Z",
        "media_urls": [
            "https://opengraph.githubassets.com/623e910b792e31b1242fbf022d60c8254dbb665016928f89d0db6550d7d0c107/mikeakohn/small_projects"
        ],
        "homepage": null,
        "readme_summary": "This repository hosts source code and schematics for small projects developed over the years, as found on mikekohn.net. The projects are written in Assembly language.",
        "key_features": [
            "Source code for small projects",
            "Schematics for small projects"
        ],
        "primary_use_case": "Providing examples of small Assembly projects.",
        "open_issues": 0,
        "cover_image_prompt": "An artisan meticulously crafting intricate clockwork mechanisms from lines of assembly code. Each gear represents a different project, fitting perfectly into a larger, functional whole. The artisan uses specialized tools that resemble debuggers and compilers, subtly glowing with digital energy. Small screens display snippets of assembly code and circuit diagrams. The scene is set in a brightly lit workshop with a clean, organized aesthetic. The repository name is subtly etched onto a workbench. The image should be in a detailed technical illustration style with labeled parts and vibrant colors."
    },
    {
        "id": 1043516507,
        "name": "port-kill",
        "description": "Port Kill helps you find and free ports blocking your dev work.",
        "url": "https://github.com/kagehq/port-kill",
        "language": "Rust",
        "stars": 1642,
        "forks": 41,
        "created_at": "2025-08-24T02:58:20Z",
        "updated_at": "2025-10-04T08:39:44Z",
        "topics": [],
        "quality_score": 0.85,
        "contributors_count": 0,
        "last_commit_date": "2025-09-29T22:45:15Z",
        "media_urls": [
            "https://opengraph.githubassets.com/1104148d3c98efd8d1c70359eef2e8ce7a2fbc8c06e429855bf76ee9ca56096f/kagehq/port-kill"
        ],
        "homepage": "https://portkill.com",
        "readme_summary": "Port Kill is a Rust-based tool designed to identify and free up ports that are blocking development work. It supports macOS, Linux, and Windows, offering both local and remote (SSH) functionality through a CLI, status bar integration, and an optional dashboard.",
        "key_features": [
            "Find and free ports",
            "Cross-platform support (macOS, Linux, Windows)",
            "CLI interface",
            "Status bar integration",
            "Optional dashboard",
            "SSH support",
            "Port Guard Mode (auto-resolve)",
            "MCP integration (Cursor, Claude)"
        ],
        "primary_use_case": "Identifying and releasing blocked ports to facilitate software development and deployment.",
        "open_issues": 1,
        "cover_image_prompt": "A doctor wearing a stethoscope is examining a city skyline where each building represents a software application. The stethoscope glows, highlighting specific buildings (applications) with blocked pipes (ports). The doctor is using a tablet displaying a simplified UI with port numbers and process IDs. The scene is set against a clean, futuristic cityscape with subtle digital particles flowing around the buildings. The repository name, 'Port Kill,' is subtly displayed on the tablet. The image should be in a flat design style with clear iconography and a bright, optimistic color scheme."
    },
    {
        "id": 37319088,
        "name": "finicky",
        "description": "A macOS app for customizing which browser to start",
        "url": "https://github.com/johnste/finicky",
        "language": "Go",
        "stars": 4336,
        "forks": 173,
        "created_at": "2015-06-12T11:46:13Z",
        "updated_at": "2025-10-04T08:50:18Z",
        "topics": [
            "browser",
            "go",
            "handler",
            "macos",
            "menu",
            "productivity",
            "typescript",
            "url"
        ],
        "quality_score": 0.85,
        "contributors_count": 0,
        "last_commit_date": "2025-10-03T10:16:04Z",
        "media_urls": [
            "https://opengraph.githubassets.com/5398557a0328a31b8f36b36a3d25f6e302687e2443a520590a65d18f5db4ad19/johnste/finicky"
        ],
        "homepage": "",
        "readme_summary": "Finicky is a macOS application that acts as a default browser, allowing users to define rules to route URLs to specific browsers based on matching criteria. It offers features like URL rewriting, JavaScript/TypeScript configuration, and handling multiple browsers, enhancing workflow organization by separating browsing contexts.",
        "key_features": [
            "Route URLs to preferred browsers with matching rules",
            "Automatically edit URLs before opening",
            "Write rules in JavaScript or TypeScript",
            "Create complex routing logic",
            "Handle multiple browsers and apps",
            "Browser extensions for Chrome and Firefox"
        ],
        "primary_use_case": "Customizing which browser opens for specific URLs based on user-defined rules.",
        "open_issues": 27,
        "cover_image_prompt": "Imagine a traffic controller directing streams of colorful URLs towards different browser icons, each representing a specific application like Chrome, Firefox, or Safari. The controller stands at a central hub with glowing screens displaying URL patterns and routing rules. Digital arrows indicate the flow of URLs, with some being transformed by magical wrenches representing URL rewriting. The scene is set in a clean, futuristic control room with soft, ambient lighting. Small code snippets and browser logos subtly connect the metaphor to software. The image should be in a 3D isometric illustration style with vibrant colors and clear details."
    },
    {
        "id": 895926919,
        "name": "poml",
        "description": "Prompt Orchestration Markup Language",
        "url": "https://github.com/microsoft/poml",
        "language": "TypeScript",
        "stars": 4615,
        "forks": 239,
        "created_at": "2024-11-29T07:43:56Z",
        "updated_at": "2025-10-04T09:19:29Z",
        "topics": [
            "llm",
            "markup-language",
            "prompt",
            "vscode-extension"
        ],
        "quality_score": 0.85,
        "contributors_count": 0,
        "last_commit_date": "2025-09-20T06:52:34Z",
        "media_urls": [
            "https://opengraph.githubassets.com/39902a7c16ea5f7c43476e1f02e23e664154411f1724d76e7415e698a43537b3/microsoft/poml"
        ],
        "homepage": "https://microsoft.github.io/poml/",
        "readme_summary": "POML (Prompt Orchestration Markup Language) is a markup language designed for structuring and managing prompts for Large Language Models (LLMs). It provides features for organizing prompt components, integrating data, and managing presentation variations, addressing challenges like lack of structure and format sensitivity in prompt engineering.",
        "key_features": [
            "Structured Prompting Markup",
            "Comprehensive Data Handling",
            "Decoupled Presentation Styling",
            "Integrated Templating Engine",
            "Rich Development Toolkit (IDE Extension, SDKs)"
        ],
        "primary_use_case": "Creating structured, maintainable, and versatile prompts for Large Language Models (LLMs).",
        "open_issues": 22,
        "cover_image_prompt": "A skilled architect meticulously crafting a blueprint for a towering structure of interconnected prompts. The architect uses specialized tools to arrange various data sources, styling elements, and logic blocks into a cohesive design. A holographic display shows the structure transforming into a refined and adaptable prompt ready for deployment. Small UI elements showing POML code snippets are subtly integrated into the architect's workstation. The scene is set in a brightly lit, futuristic design studio with a blue and white color scheme. The image should be in a 3D isometric illustration style with clean lines and clear details."
    },
    {
        "id": 1020924685,
        "name": "marchat",
        "description": "Lightweight terminal chat with server/client binaries, real-time WebSocket messaging, optional end-to-end encryption, plugins, file sharing, admin panel, and code snippets. Built in Go with Bubble Tea and SQLite; ideal for developers and small teams.",
        "url": "https://github.com/Cod-e-Codes/marchat",
        "language": "Go",
        "stars": 97,
        "forks": 5,
        "created_at": "2025-07-16T15:48:32Z",
        "updated_at": "2025-10-03T21:29:42Z",
        "topics": [
            "admin-panel",
            "bubbletea",
            "chat",
            "chat-app",
            "code-snippets",
            "cross-platform",
            "docker",
            "encryption",
            "file-sharing",
            "go",
            "golang",
            "open-source",
            "plugins",
            "real-time",
            "self-hosted",
            "sqlite",
            "syntax-highlighting",
            "terminal",
            "tui",
            "websocket"
        ],
        "quality_score": 0.9,
        "contributors_count": 0,
        "last_commit_date": "2025-10-02T23:44:33Z",
        "media_urls": [
            "https://repository-images.githubusercontent.com/1020924685/9346b44d-528a-4d30-8a52-86fe55132fa9"
        ],
        "homepage": "https://github.com/Cod-e-Codes/marchat",
        "readme_summary": "marchat is a lightweight, self-hosted terminal chat application built in Go, designed for developers and small teams. It features real-time WebSocket messaging, optional end-to-end encryption, a plugin system, file sharing, and an admin panel, all accessible through a terminal UI.",
        "key_features": [
            "Terminal UI (Bubble Tea)",
            "Real-time Chat (WebSockets, SQLite)",
            "Plugin System",
            "E2E Encryption (X25519/ChaCha20-Poly1305)",
            "File Sharing",
            "Admin Controls",
            "Bell Notifications",
            "Themes",
            "Docker Support"
        ],
        "primary_use_case": "Self-hosted, lightweight terminal chat for developers and small teams.",
        "open_issues": 4,
        "cover_image_prompt": "A skilled telegraph operator sits at a vintage terminal, expertly relaying messages between distant outposts. Each message is carefully encrypted with glowing cryptographic keys before transmission. The terminal displays a clean, modern chat interface with active users and file transfer indicators. Subtle digital particles flow around the terminal, visualizing the real-time data streams. A small screen in the background displays a snippet of Go code related to WebSocket communication. The scene is set in a cozy, dimly lit office with a focused atmosphere. The image should be in 3D isometric illustration style with warm colors and clear details."
    },
    {
        "id": 1030990993,
        "name": "hexora",
        "description": "Static analysis of malicious Python code",
        "url": "https://github.com/rushter/hexora",
        "language": "Rust",
        "stars": 53,
        "forks": 3,
        "created_at": "2025-08-02T19:10:44Z",
        "updated_at": "2025-10-03T17:47:40Z",
        "topics": [],
        "quality_score": 0.65,
        "contributors_count": 0,
        "last_commit_date": "2025-09-23T17:53:14Z",
        "media_urls": [
            "https://opengraph.githubassets.com/fb1257a9fe17d86e20c4f1cbdf25c62432b9b1b4b3dedff3a049645d0736bfaf/rushter/hexora"
        ],
        "homepage": "",
        "readme_summary": "Hexora is a static analysis tool written in Rust designed to detect malicious patterns in Python code. It can be used to audit project dependencies, detect malicious scripts, analyze IoC files, and audit new PyPi packages.",
        "key_features": [
            "Audit project dependencies",
            "Detect malicious scripts",
            "Analyze IoC files",
            "Audit new PyPi packages",
            "Static analysis of Python code"
        ],
        "primary_use_case": "Detecting malicious and harmful patterns in Python code.",
        "open_issues": 1,
        "cover_image_prompt": "A seasoned detective meticulously examining Python code files with a magnifying glass, revealing hidden red flags and warning signs within the lines of code. The detective's office is filled with screens displaying code snippets and security alerts. A subtle UI element in the corner shows Hexora's logo and a real-time analysis dashboard. The scene is set in a dimly lit, noir-style office with dramatic lighting. Small digital particles highlight the malicious code fragments. The composition is focused and clean with a blue and orange color scheme. The image should be in a digital painting style with clear outlines and rich details."
    }
]