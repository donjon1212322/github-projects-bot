[
    {
        "id": 961287106,
        "name": "HiDream-I1",
        "description": null,
        "url": "https://github.com/HiDream-ai/HiDream-I1",
        "language": "Python",
        "stars": 455,
        "forks": 25,
        "created_at": "2025-04-06T07:18:20Z",
        "updated_at": "2025-04-10T10:11:54Z",
        "topics": [],
        "quality_score": 0.75,
        "contributors_count": 0,
        "last_commit_date": "2025-04-09T03:59:12Z",
        "media_urls": [
            "https://opengraph.githubassets.com/c3b4bc9cb4cc89ffe5b82a3e1224662e87227ac1e84c32d7ee9dc6609244460c/HiDream-ai/HiDream-I1"
        ],
        "homepage": null,
        "readme_summary": "HiDream-I1 is an open-source image generative foundation model that provides state-of-the-art image generation quality in a short amount of time. It offers multiple model versions optimized for different use cases, including a full version and distilled, faster versions. The repository also includes a Gradio demo for interactive image generation and evaluation metrics for assessing model performance.",
        "key_features": [
            "State-of-the-art image generation quality",
            "Fast image generation (within seconds)",
            "Multiple model versions (Full, Dev, Fast)",
            "Gradio demo for interactive image generation",
            "Evaluation metrics (DPG-Bench, GenEval)"
        ],
        "primary_use_case": "Text-to-image generation",
        "open_issues": 10,
        "cover_image_prompt": "A skilled sculptor meticulously chiseling away at a rough block of marble, revealing a stunning, high-resolution image within. The sculptor's tools are subtly enhanced with digital interfaces, displaying parameters like 'Inference Steps' and 'Model Type'. The surrounding studio is filled with glowing particles representing data, and faint code snippets are projected onto the walls. The scene is bathed in soft, focused light, highlighting the transformation from raw potential to refined output. The composition is clean and focused, with a warm color scheme. The image should be in a 3D isometric illustration style with rich details and vibrant colors, subtly incorporating the 'HiDream-I1' logo."
    },
    {
        "id": 953803366,
        "name": "zev",
        "description": "A simple CLI to help you remember commands",
        "url": "https://github.com/dtnewman/zev",
        "language": "Python",
        "stars": 15,
        "forks": 3,
        "created_at": "2025-03-24T05:21:42Z",
        "updated_at": "2025-04-10T06:58:48Z",
        "topics": [],
        "quality_score": 0.65,
        "contributors_count": 0,
        "last_commit_date": "2025-04-09T18:51:57Z",
        "media_urls": [
            "https://opengraph.githubassets.com/28b2aea3b8cb710a74b9817445d50c2b1f00cae82b0357e6cc81c2a4599aadf0/dtnewman/zev"
        ],
        "homepage": null,
        "readme_summary": "Zev is a command-line tool that helps users remember or discover terminal commands by using natural language. It offers both an interactive mode and a direct query mode, allowing users to find commands by describing what they want to do. The tool also provides a setup option to configure settings such as the OpenAI API key.",
        "key_features": [
            "Remembers terminal commands using natural language",
            "Interactive mode",
            "Direct query mode",
            "Settings configuration via command line"
        ],
        "primary_use_case": "Remembering and discovering terminal commands using natural language queries.",
        "open_issues": 0,
        "cover_image_prompt": "A librarian with a magnifying glass, standing in a vast library filled with scrolls representing terminal commands. The librarian is helping a programmer, who is searching for a specific command, by using natural language to locate the correct scroll. The scrolls glow faintly with digital code. A small screen displays the Zev logo and a command prompt. The scene is set in a warmly lit, organized library. The image should be in a detailed digital painting style with clear outlines and a focus on conveying information."
    },
    {
        "id": 643749430,
        "name": "agentheroes",
        "description": "Generate, animate and schedule your AI characters 🤖",
        "url": "https://github.com/agentheroes/agentheroes",
        "language": "TypeScript",
        "stars": 3307,
        "forks": 68,
        "created_at": "2023-05-22T04:38:29Z",
        "updated_at": "2025-04-10T09:15:22Z",
        "topics": [
            "agent",
            "agents",
            "ai",
            "chatgpt",
            "generate",
            "image",
            "lora",
            "replicate",
            "train",
            "video",
            "workflow"
        ],
        "quality_score": 0.7499999999999999,
        "contributors_count": 0,
        "last_commit_date": "2025-04-10T09:15:14Z",
        "media_urls": [
            "https://opengraph.githubassets.com/785a2f4210de2dacc931990e0bd1b83305f5db3665a9af3c0ebf949227f0fc4e/agentheroes/agentheroes"
        ],
        "homepage": "https://agentheroes.ai",
        "readme_summary": "AgentHeroes is a platform for generating, animating, and scheduling AI characters. It allows users to train LoRA models, generate images and videos, and automate the entire process through agentic flows, triggered by schedule or API. The platform currently supports scheduling videos to X (formerly Twitter).",
        "key_features": [
            "Train LoRA models on images using Fal.ai and Replicate",
            "Generate pictures using trained or different models",
            "Convert pictures into videos",
            "Schedule videos to social media (currently supporting X)",
            "Build agentic flows to automate the process and trigger via schedule or API"
        ],
        "primary_use_case": "Generating, animating, and scheduling AI characters for various applications, including social media content creation and automated workflows.",
        "open_issues": 12,
        "cover_image_prompt": "A skilled artisan meticulously crafting AI characters on a digital loom, weaving together lines of code and vibrant images. The loom's output transforms into animated figures that gracefully step onto a stage, ready to perform. A calendar hangs nearby, displaying scheduled events for the AI characters. Subtle UI elements and code snippets are woven into the fabric of the loom. The scene is set in a bright, modern workshop with a focus on clean lines and intuitive design. The image should be in a flat design style with clear iconography and a pastel color scheme."
    },
    {
        "id": 944787249,
        "name": "spongecake",
        "description": "Spongecake is the easiest way to launch computer use agents.",
        "url": "https://github.com/aditya-nadkarni/spongecake",
        "language": "JavaScript",
        "stars": 116,
        "forks": 11,
        "created_at": "2025-03-08T00:54:44Z",
        "updated_at": "2025-04-10T09:45:33Z",
        "topics": [
            "ai-agents",
            "ai-agents-framework",
            "automation",
            "computer-use",
            "docker",
            "llm",
            "openai",
            "python"
        ],
        "quality_score": 0.85,
        "contributors_count": 0,
        "last_commit_date": "2025-04-09T20:11:48Z",
        "media_urls": [
            "https://repository-images.githubusercontent.com/944787249/d214ddc6-74a2-4190-983f-82c53db4e696"
        ],
        "homepage": "",
        "readme_summary": "Spongecake is a framework for building AI agents that can interact with computers. It allows developers to automate workflows, scrape data, and fill out forms in both web and desktop applications. It is particularly useful for automating tasks in environments with limited APIs or on-premise infrastructure.",
        "key_features": [
            "Automates computer interactions",
            "Scrapes websites and fills out forms",
            "Interacts with websites and local apps",
            "Automates workflows in desktop applications",
            "Supports on-prem environments with VPNs and firewalls"
        ],
        "primary_use_case": "Creating OpenAI Operators that can use computers to automate tasks like web scraping, form filling, and interacting with applications, especially in environments with limited or no APIs.",
        "open_issues": 0,
        "cover_image_prompt": "A diligent robot chef meticulously crafting a multi-layered spongecake in a futuristic kitchen. The robot uses data streams as ingredients, transforming them into perfectly formed cake layers representing automated computer tasks. Each layer signifies a different function like web scraping, form filling, and application interaction. UI elements float around the cake, displaying code snippets and process visualizations. The kitchen is clean and brightly lit, with a focus on precision and efficiency. The image should be in a 3D isometric illustration style with vibrant colors and sharp details."
    },
    {
        "id": 942675228,
        "name": "prompp",
        "description": "Deckhouse Prom++ – high-performance fork of Prometheus, designed to significantly reduce memory consumption",
        "url": "https://github.com/deckhouse/prompp",
        "language": "Go",
        "stars": 193,
        "forks": 1,
        "created_at": "2025-03-04T13:44:41Z",
        "updated_at": "2025-04-10T09:43:34Z",
        "topics": [],
        "quality_score": 1.0000000000000002,
        "contributors_count": 0,
        "last_commit_date": "2025-04-09T16:22:56Z",
        "media_urls": [
            "https://opengraph.githubassets.com/24579f2416e44dd6f28fc5b1a486a6f3158cc5d0d55c749903b8b2196e00dee3/deckhouse/prompp"
        ],
        "homepage": "https://deckhouse.ru/products/prompp/",
        "readme_summary": "Prom++ is a high-performance fork of Prometheus designed to significantly reduce memory consumption. It achieves this by rewriting resource-intensive components in C++, specifically in-memory block construction and Write-Ahead Log (WAL) management. Prom++ is a drop-in replacement for Prometheus, ensuring effortless migration and full compatibility with existing configurations and data.",
        "key_features": [
            "Drastically reduced memory usage (up to 10x)",
            "Full compatibility with Prometheus (configuration files, API endpoints, storage block format)",
            "Effortless migration (drop-in replacement)",
            "Optimized in-memory block construction",
            "Optimized Write-Ahead Log (WAL) management"
        ],
        "primary_use_case": "Replacing Prometheus to reduce memory consumption while maintaining full compatibility.",
        "open_issues": 0,
        "cover_image_prompt": "Imagine a bustling hospital emergency room where a doctor, representing Prom++, efficiently triages patients (Prometheus metrics) arriving on stretchers. The doctor uses advanced scanning tools (optimized algorithms) to quickly assess each patient, prioritizing critical cases and minimizing wait times. A large screen displays vital signs (key metrics) with minimal lag. The room is clean, organized, and brightly lit, symbolizing reduced memory consumption and improved performance. Subtle UI elements and code snippets float in the background, connecting the scene to software. The image should be in a 3D isometric illustration style with vibrant colors and clear details, conveying efficiency and precision."
    },
    {
        "id": 140457254,
        "name": "amass",
        "description": "In-depth attack surface mapping and asset discovery",
        "url": "https://github.com/owasp-amass/amass",
        "language": "Go",
        "stars": 12778,
        "forks": 1962,
        "created_at": "2018-07-10T16:05:08Z",
        "updated_at": "2025-04-10T08:51:21Z",
        "topics": [
            "attack-surfaces",
            "dns",
            "enumeration",
            "go",
            "golang",
            "information-gathering",
            "maltego",
            "network-security",
            "osint",
            "osint-reconnaissance",
            "owasp",
            "recon",
            "subdomain"
        ],
        "quality_score": 0.55,
        "contributors_count": 0,
        "last_commit_date": "2023-09-10T20:40:57Z",
        "media_urls": [
            "https://repository-images.githubusercontent.com/140457254/1a5a3880-df66-11ea-9bd6-1ff72d6702d4"
        ],
        "homepage": "https://owasp.org/www-project-amass/",
        "readme_summary": "The OWASP Amass Project is designed for in-depth attack surface mapping and external asset discovery. It leverages open-source information gathering and active reconnaissance techniques to provide a comprehensive view of an organization's online presence. Amass integrates with numerous data sources and employs various methods, including APIs, certificate analysis, DNS enumeration, routing data, web scraping, and WHOIS lookups, to identify and map assets.",
        "key_features": [
            "Network mapping of attack surfaces",
            "External asset discovery",
            "Open source information gathering",
            "Active reconnaissance techniques",
            "Extensive data source integration"
        ],
        "primary_use_case": "Attack surface mapping and asset discovery for security assessments.",
        "open_issues": 180,
        "cover_image_prompt": "A cartographer meticulously charting an uncharted island, revealing hidden coves and resources. The cartographer uses various tools like telescopes, maps, and compasses, each representing different information gathering techniques. Digital overlays on the map display network routes and domain names. The island itself is shaped like a network diagram, with servers and connections subtly integrated into the landscape. The scene is set on a cliff overlooking the island at sunrise, with warm, inviting light. Small UI elements showing Amass's interface are subtly placed on the cartographer's desk. The image should be in a detailed digital painting style with clear outlines and vibrant colors."
    },
    {
        "id": 110445107,
        "name": "telegram",
        "description": "A Matrix-Telegram hybrid puppeting/relaybot bridge",
        "url": "https://github.com/mautrix/telegram",
        "language": "Python",
        "stars": 1428,
        "forks": 192,
        "created_at": "2017-11-12T15:42:45Z",
        "updated_at": "2025-04-10T04:18:27Z",
        "topics": [
            "bridge",
            "matrix",
            "matrix-appservice",
            "matrix-org",
            "python",
            "telegram",
            "telegram-client",
            "telethon"
        ],
        "quality_score": 0.85,
        "contributors_count": 0,
        "last_commit_date": "2025-03-19T18:47:08Z",
        "media_urls": [
            "https://opengraph.githubassets.com/47f6d8e99cd570ffb6453f2c86bf681755b40e8ec32a6ffa7c84a726d9c02480/mautrix/telegram"
        ],
        "homepage": "https://matrix.to/#/#telegram:maunium.net",
        "readme_summary": "Mautrix-telegram is a hybrid bridge that connects Matrix and Telegram, enabling users to communicate between the two platforms. It supports both puppeting and relaybot functionality, allowing for flexible integration. The bridge aims to provide a seamless communication experience between Matrix and Telegram users.",
        "key_features": [
            "Matrix-Telegram hybrid bridge",
            "Puppeting",
            "Relaybot functionality"
        ],
        "primary_use_case": "Bridging Matrix and Telegram for seamless communication between the two platforms.",
        "open_issues": 151,
        "cover_image_prompt": "A skilled messenger bird, representing the bridge, carrying messages between two distinct realms: a bustling city of interconnected screens and digital interfaces symbolizing Matrix, and a cozy, vibrant town square where people communicate via traditional telegrams, representing Telegram. The bird clutches encrypted scrolls in its talons, ensuring secure delivery. Subtle UI elements and data visualizations float around the bird, connecting the metaphor to software. The scene is set in a bright, whimsical world with a clear, focused composition. The image should be in a 3D isometric illustration style with rich details and vibrant colors."
    },
    {
        "id": 953787416,
        "name": "gatehouse",
        "description": "A flexible authorization library that combines role-based (RBAC), attribute-based (ABAC), and relationship-based (ReBAC) access control policies.",
        "url": "https://github.com/thepartly/gatehouse",
        "language": "Rust",
        "stars": 265,
        "forks": 4,
        "created_at": "2025-03-24T04:36:11Z",
        "updated_at": "2025-04-10T05:31:54Z",
        "topics": [],
        "quality_score": 0.9,
        "contributors_count": 0,
        "last_commit_date": "2025-03-25T03:47:00Z",
        "media_urls": [
            "https://opengraph.githubassets.com/f584c244927355c5491ab0dea6ea6d215092eb85d6eb5eb8279ecd0c550986f4/thepartly/gatehouse"
        ],
        "homepage": "",
        "readme_summary": "Gatehouse is a Rust library that provides flexible authorization capabilities by combining RBAC, ABAC, and ReBAC access control policies. It offers features like policy composition, detailed evaluation tracing, a fluent builder API, type safety, and async support, enabling developers to create fine-grained and adaptable authorization systems.",
        "key_features": [
            "Multi-paradigm Authorization (RBAC, ABAC, ReBAC)",
            "Policy Composition with logical operators",
            "Detailed Evaluation Tracing",
            "Fluent Builder API for custom policies",
            "Type Safety",
            "Async Ready"
        ],
        "primary_use_case": "Flexible authorization in applications by combining role-based, attribute-based, and relationship-based access control policies.",
        "open_issues": 0,
        "cover_image_prompt": "A master locksmith standing before a grand vault, expertly crafting keys that unlock various doors representing RBAC, ABAC, and ReBAC. Each door glows with a distinct color, and the vault is filled with digital particles representing data. The locksmith uses a holographic interface to fine-tune the keys, displaying snippets of code and policy configurations. The scene is set in a futuristic workshop with soft, ambient lighting. The image should be in 3D isometric illustration style with intricate details and a vibrant color scheme, subtly incorporating the 'Gatehouse' name on the vault's facade."
    },
    {
        "id": 583008078,
        "name": "coq-of-rust",
        "description": "Formal verification tool for Rust: check 100% of execution cases of your programs 🦀 to make super safe applications! ✈️ 🚀 ⚕️ 🏦",
        "url": "https://github.com/formal-land/coq-of-rust",
        "language": "Coq",
        "stars": 886,
        "forks": 31,
        "created_at": "2022-12-28T13:46:19Z",
        "updated_at": "2025-04-10T03:10:31Z",
        "topics": [
            "coq",
            "formal-verification",
            "proof",
            "rust"
        ],
        "quality_score": 1.0000000000000002,
        "contributors_count": 0,
        "last_commit_date": "2025-04-09T20:25:00Z",
        "media_urls": [
            "https://opengraph.githubassets.com/f68a7f9227908933f7e308d1cb80015a1d94aada417d1a285ccc2900657cf999/formal-land/coq-of-rust"
        ],
        "homepage": "",
        "readme_summary": "Coq-of-rust is a formal verification tool that translates Rust code into the Coq proof system. This allows developers to mathematically prove the correctness of their Rust programs, ensuring they meet their specifications for all possible inputs. The tool includes features for translation, refinement, and specification, ultimately aiming to reduce bugs and vulnerabilities to zero.",
        "key_features": [
            "Translates Rust code to Coq",
            "Enables formal verification of Rust programs",
            "Provides a standard library for Rust in Coq",
            "Offers semi-automated refinement steps (links and simulations)",
            "Allows proving specifications with any possible user input"
        ],
        "primary_use_case": "Formal verification of Rust programs to ensure bug-free and vulnerability-free code.",
        "open_issues": 25,
        "cover_image_prompt": "A meticulous architect meticulously inspecting the blueprints of a towering skyscraper, ensuring every structural element is perfectly sound. The architect uses a powerful magnifying glass that reveals potential flaws and vulnerabilities in the design. Holographic projections display complex mathematical equations and simulations, verifying the building's integrity. The scene is set in a brightly lit, futuristic design studio. Subtle UI elements show code snippets and verification results. The image should be in a detailed technical illustration style with precise lines and labeled parts, using a clean and professional color scheme."
    },
    {
        "id": 283549473,
        "name": "turbine",
        "description": "A testing library for kotlinx.coroutines Flow",
        "url": "https://github.com/cashapp/turbine",
        "language": "Kotlin",
        "stars": 2603,
        "forks": 109,
        "created_at": "2020-07-29T16:31:35Z",
        "updated_at": "2025-04-09T17:00:25Z",
        "topics": [],
        "quality_score": 0.85,
        "contributors_count": 0,
        "last_commit_date": "2025-04-08T11:05:09Z",
        "media_urls": [
            "https://opengraph.githubassets.com/ec505cb5af8c7e3b974d8c45257c776e019eefd47ab321c8e4353f4f25ca2f85/cashapp/turbine"
        ],
        "homepage": "https://cashapp.github.io/turbine/docs/1.x/",
        "readme_summary": "Turbine is a Kotlin library designed to simplify testing `kotlinx.coroutines` Flows. It provides a set of functions to assert the behavior of flows, such as awaiting emitted items, completion, or errors. Turbine offers extensions for testing single or multiple flows and ensures that all events are consumed during testing to prevent hanging tests.",
        "key_features": [
            "Simplifies testing of Kotlin Coroutines Flows.",
            "Provides methods like `awaitItem()`, `awaitComplete()`, and `awaitError()` for asserting flow behavior.",
            "Offers `test` and `testIn` extensions for testing single and multiple flows respectively.",
            "Enforces event consumption to prevent hanging tests."
        ],
        "primary_use_case": "Testing Kotlin Coroutines Flows to ensure they emit the expected values, complete successfully, or throw expected errors.",
        "open_issues": 10,
        "cover_image_prompt": "Imagine a meticulous clockmaker carefully adjusting the gears of a complex clockwork mechanism. Each gear represents a coroutine flow, and the clockmaker uses specialized tools (Turbine) to ensure each flow is perfectly synchronized and tested for accuracy. Small screens display code snippets and flow diagrams, subtly connecting the clockwork to software. The scene is set in a brightly lit workshop with a clean, focused composition. The image should be in a 3D isometric illustration style with rich details and vibrant colors, conveying precision and reliability."
    }
]