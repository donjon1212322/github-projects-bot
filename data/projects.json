[
    {
        "id": 1060418895,
        "name": "ffclipper",
        "description": "A lightweight frontend for ffmpeg intended specifically for convenient video clipping",
        "url": "https://github.com/Jonny-GM/ffclipper",
        "language": "Python",
        "stars": 11,
        "forks": 0,
        "created_at": "2025-09-19T22:06:44Z",
        "updated_at": "2025-09-22T09:00:35Z",
        "topics": [
            "ffmpeg",
            "video-editing"
        ],
        "quality_score": 0.5499999999999999,
        "contributors_count": 0,
        "last_commit_date": "2025-09-21T06:44:21Z",
        "media_urls": [
            "https://opengraph.githubassets.com/885383c4472c6dab258905a40c2c7bc9f3aaa1fd9f4cccc3f72ed1f579ffa8a0/Jonny-GM/ffclipper"
        ],
        "homepage": "",
        "readme_summary": "ffclipper is a lightweight frontend for ffmpeg designed for convenient video clipping. It offers both a CLI and a Qt-based GUI, supporting features like stream copying, transcoding, automatic hardware acceleration (NVENC), tonemapping, two-pass encoding for target file sizes, and subtitle handling.",
        "key_features": [
            "CLI and Qt-based GUI",
            "Stream copy and transcode output modes",
            "Automatic hardware acceleration (NVENC)",
            "Tonemapping",
            "Two-pass encoding for target file size",
            "Soft subtitle support and burning into video"
        ],
        "primary_use_case": "Clipping sections from video files using ffmpeg with a user-friendly interface and sensible defaults.",
        "open_issues": 0,
        "cover_image_prompt": "A skilled tailor meticulously cutting a scene from a large roll of film using specialized scissors. The scissors have small UI elements embedded in their handles, displaying precise timestamps. The cut scene transforms into a neatly packaged video file, ready for distribution. Digital particles flow from the scissors, visualizing the editing process. A subtle watermark of 'ffclipper' is visible on the film roll. The scene is set in a bright, modern editing studio with soft, diffused lighting. The composition is clean and focused with a balanced color scheme. The image should be in a flat design style with clear iconography and vibrant colors."
    },
    {
        "id": 1043516507,
        "name": "port-kill",
        "description": "Port Kill helps you find and free ports blocking your dev work.",
        "url": "https://github.com/kagehq/port-kill",
        "language": "Rust",
        "stars": 1563,
        "forks": 35,
        "created_at": "2025-08-24T02:58:20Z",
        "updated_at": "2025-09-22T09:50:16Z",
        "topics": [],
        "quality_score": 0.85,
        "contributors_count": 0,
        "last_commit_date": "2025-09-21T21:44:52Z",
        "media_urls": [
            "https://opengraph.githubassets.com/f1bf970e0f44b5f3c84befbc44f8d4c1e413fefbe146131ccfdc83769b6810b0/kagehq/port-kill"
        ],
        "homepage": "https://portkill.com",
        "readme_summary": "Port Kill is a Rust-based tool designed to identify and free ports that are blocking development work. It supports macOS, Linux, and Windows, offering a CLI, status bar integration, and an optional dashboard for managing port usage locally or over SSH.",
        "key_features": [
            "Real-time process detection on specific ports or ranges",
            "One-shot cleanup (--reset)",
            "Smart filtering and ignore lists",
            "Port Guard Mode (watch/reserve/auto-resolve)",
            "Security Audit Mode (suspicious ports, risk score, JSON)",
            "Remote Mode over SSH",
            "Works with Docker"
        ],
        "primary_use_case": "Finding and freeing up blocked ports to facilitate development workflows.",
        "open_issues": 1,
        "cover_image_prompt": "A doctor wearing a stethoscope is listening to a city skyline, identifying blocked arteries (ports) in the city's infrastructure. The doctor uses a defibrillator to clear the blocked ports, restoring the city's flow. Small screens display port numbers and process IDs. Digital particles represent data flowing smoothly after the ports are cleared. The city is futuristic with glowing elements. The repository name 'Port Kill' is subtly displayed on the doctor's badge. The scene is in a digital painting style with clean lines and clear details, using a vibrant color scheme."
    },
    {
        "id": 756867260,
        "name": "Trayy",
        "description": "Send specified apps to Windows Tray",
        "url": "https://github.com/alirezagsm/Trayy",
        "language": "C++",
        "stars": 143,
        "forks": 6,
        "created_at": "2024-02-13T13:17:49Z",
        "updated_at": "2025-09-22T09:59:54Z",
        "topics": [
            "desktop",
            "minimize-to-system-tray",
            "notification",
            "productivity",
            "thunderbird",
            "tray",
            "webapp",
            "windows"
        ],
        "quality_score": 0.44999999999999996,
        "contributors_count": 0,
        "last_commit_date": "2025-09-18T12:08:54Z",
        "media_urls": [
            "https://opengraph.githubassets.com/b9edba0a91e68974f771dad914843790e2dcf58e4273e6e932babbbc206c7594/alirezagsm/Trayy"
        ],
        "homepage": "",
        "readme_summary": "Trayy is a Windows application written in C++ that allows users to minimize specified applications to the system tray, effectively hiding them from the taskbar. It supports various application types, including PWAs and traditional desktop applications, and offers features like quick actions via right-click menus and compatibility with Windows 10 and 11.",
        "key_features": [
            "Send to Tray",
            "Hide applications from the taskbar",
            "App Support for PWAs and other apps",
            "Quick Actions via right-click",
            "Windows 10 and 11 compatibility",
            "Lightweight and portable"
        ],
        "primary_use_case": "Minimizing applications to the system tray for a clutter-free workspace.",
        "open_issues": 9,
        "cover_image_prompt": "Imagine a diligent butler tidying up a cluttered desktop by neatly placing various application windows into a small, organized tray. The butler, with a subtle tech-inspired design, carefully arranges windows representing different apps into the tray. Some windows have miniature icons representing common programs. The desktop is clean and spacious after the apps are trayed. Small UI elements float around the butler, showing minimize and close buttons. The repository name 'Trayy' is subtly engraved on the tray. The scene is in a 3D isometric illustration style with a clean, organized composition and a calming color scheme."
    },
    {
        "id": 282944472,
        "name": "pynguin",
        "description": "The PYthoN General UnIt Test geNerator is a test-generation tool for Python",
        "url": "https://github.com/se2p/pynguin",
        "language": "Python",
        "stars": 1332,
        "forks": 92,
        "created_at": "2020-07-27T15:50:19Z",
        "updated_at": "2025-09-22T09:23:36Z",
        "topics": [
            "python",
            "search-based-software-testing",
            "test-generation",
            "test-generator",
            "testing-tools"
        ],
        "quality_score": 0.95,
        "contributors_count": 0,
        "last_commit_date": "2025-09-19T09:51:42Z",
        "media_urls": [
            "https://repository-images.githubusercontent.com/282944472/d7426a00-7b31-11eb-8b11-39c4b4fb71bd"
        ],
        "homepage": "https://www.pynguin.eu",
        "readme_summary": "Pynguin is a tool for automatically generating unit tests for Python programs. It addresses the gap in fully-automated test generation for dynamically typed languages, offering a way to reduce the tediousness of software testing.",
        "key_features": [
            "Automated unit test generation for Python",
            "Support for Python 3.10 (experimental support for 3.11, 3.12 and 3.13)",
            "Compatibility with Linux/macOS/Windows"
        ],
        "primary_use_case": "Automated generation of unit tests for Python code.",
        "open_issues": 8,
        "cover_image_prompt": "A diligent robot gardener tending to a garden of Python code plants. The robot uses a watering can labeled 'Pynguin' to nourish the plants, causing them to sprout robust test suites represented by glowing, healthy leaves. Some plants are weak and have bugs crawling on them, which the robot identifies and targets with precision tools. Small screens display code coverage metrics and test results. The scene is set in a bright, futuristic greenhouse with a clean, organized layout. The image should be in a 3D isometric illustration style with vibrant colors and clear details."
    },
    {
        "id": 807512074,
        "name": "MegaParse",
        "description": "File Parser optimised for LLM Ingestion with no loss ðŸ§  Parse PDFs, Docx, PPTx in a format that is ideal for LLMs. ",
        "url": "https://github.com/QuivrHQ/MegaParse",
        "language": "Python",
        "stars": 7169,
        "forks": 394,
        "created_at": "2024-05-29T08:40:29Z",
        "updated_at": "2025-09-22T07:37:39Z",
        "topics": [
            "docx",
            "llm",
            "parser",
            "pdf",
            "powerpoint"
        ],
        "quality_score": 0.7000000000000001,
        "contributors_count": 0,
        "last_commit_date": "2025-02-21T15:20:45Z",
        "media_urls": [
            "https://repository-images.githubusercontent.com/807512074/27c558a0-0db1-48cf-8101-8ac15cf58899"
        ],
        "homepage": "https://megaparse.com",
        "readme_summary": "MegaParse is a versatile file parser optimized for LLM ingestion, designed to minimize information loss. It supports various document types, including PDFs, Powerpoint presentations, and Word documents, making it suitable for processing data for language models.",
        "key_features": [
            "Versatile Parser",
            "No Information Loss",
            "Fast and Efficient",
            "Wide File Compatibility",
            "Open Source"
        ],
        "primary_use_case": "Parsing various document types (PDF, Powerpoint, Word, etc.) for ingestion into LLMs while minimizing information loss.",
        "open_issues": 26,
        "cover_image_prompt": "A skilled librarian meticulously organizing documents of various formats (PDFs, PPTs, DOCs) into a glowing, brain-shaped archive. The librarian carefully extracts key information from each document, represented by glowing data streams, and places them into the archive. Small UI elements display parsing progress and data structures. The scene is set in a futuristic library with soft, ambient lighting. The composition is clean and focused, with a color scheme of blues and greens. The image should be in 3D isometric illustration style with rich details and vibrant colors."
    },
    {
        "id": 184809315,
        "name": "stumpy",
        "description": "STUMPY is a powerful and scalable Python library for modern time series analysis",
        "url": "https://github.com/stumpy-dev/stumpy",
        "language": "Python",
        "stars": 3993,
        "forks": 336,
        "created_at": "2019-05-03T19:23:44Z",
        "updated_at": "2025-09-22T06:33:56Z",
        "topics": [
            "anomaly-detection",
            "dask",
            "data-science",
            "matrix-profile",
            "motif-discovery",
            "numba",
            "pattern-matching",
            "pydata",
            "python",
            "time-series-analysis",
            "time-series-data-mining",
            "time-series-segmentation"
        ],
        "quality_score": 0.95,
        "contributors_count": 0,
        "last_commit_date": "2025-09-02T14:08:17Z",
        "media_urls": [
            "https://opengraph.githubassets.com/f4edc83b752f4e9037c4d04d4f4027602381599e0cb18c3713749b27f8c4a781/stumpy-dev/stumpy"
        ],
        "homepage": "https://stumpy.readthedocs.io/en/latest/",
        "readme_summary": "STUMPY is a Python library for time series analysis, primarily focused on efficiently computing the matrix profile. This matrix profile can then be used for various time series data mining tasks, including pattern discovery, anomaly detection, and time series segmentation.",
        "key_features": [
            "Matrix profile computation",
            "Pattern/motif discovery",
            "Anomaly/novelty detection",
            "Shapelet discovery",
            "Semantic segmentation",
            "Streaming data analysis",
            "Fast approximate matrix profiles",
            "Time series chains",
            "Snippets for summarizing time series",
            "Pan matrix profiles"
        ],
        "primary_use_case": "Time series data mining and analysis",
        "open_issues": 64,
        "cover_image_prompt": "A cartographer meticulously charting a vast, undulating ocean of time series data. The cartographer uses a specialized tool that highlights repeating patterns (motifs) as islands and marks anomalies as treacherous reefs. The map is overlaid with a subtle grid representing time, and small screens display snippets of the underlying data. The scene is set in a brightly lit, organized study filled with charts and graphs. Digital particles flow from the cartographer's tool, illuminating the map. The image should be in a 3D isometric illustration style with clear details and a vibrant color scheme."
    }
]