[
    {
        "id": 1008866688,
        "name": "oh-my-logo",
        "description": "Display giant ASCII-art logos with colorful gradients in your terminal — like Claude Code or Gemini CLI.",
        "url": "https://github.com/shinshin86/oh-my-logo",
        "language": "TypeScript",
        "stars": 170,
        "forks": 3,
        "created_at": "2025-06-26T08:03:24Z",
        "updated_at": "2025-06-29T09:43:31Z",
        "topics": [
            "ascii",
            "ascii-art",
            "cli",
            "logo"
        ],
        "quality_score": 0.6,
        "contributors_count": 0,
        "last_commit_date": "2025-06-27T09:18:51Z",
        "media_urls": [
            "https://repository-images.githubusercontent.com/1008866688/2a712ee4-0181-4ba4-949c-404a60267d59"
        ],
        "homepage": "https://www.npmjs.com/package/oh-my-logo",
        "readme_summary": "Oh-my-logo is a TypeScript-based tool for generating visually appealing ASCII art logos with gradient colors in the terminal. It offers features like outlined or filled rendering modes, a variety of color palettes, customizable gradient directions, and multi-line support, all without requiring any dependencies. It can be used as a CLI tool or integrated as a library.",
        "key_features": [
            "Two Rendering Modes: Outlined ASCII art or filled block characters",
            "13 Beautiful Palettes: From sunset gradients to matrix green",
            "Gradient Directions: Vertical, horizontal, and diagonal gradients",
            "Multi-line Support: Create logos with multiple lines of text",
            "Zero Dependencies: Run instantly with `npx`",
            "Customizable: Use different fonts and create your own color schemes"
        ],
        "primary_use_case": "Displaying giant ASCII-art logos with colorful gradients in the terminal.",
        "open_issues": 0,
        "cover_image_prompt": "A skilled artisan meticulously crafting a giant, vibrant ASCII-art logo onto the side of a futuristic skyscraper using a palette of glowing, colorful paints. The logo shimmers with a gradient effect, catching the light of the digital city. Small screens display the code used to generate the logo, subtly integrated into the building's design. The scene is set at dusk, with a blend of neon and natural light. The image should be in a 3D isometric illustration style with rich details and vibrant colors, showcasing the artistic and technical aspects of the logo creation process."
    },
    {
        "id": 1009048253,
        "name": "image_to_pixel_art_wasm",
        "description": "An open source \"Rust ↦ WASM, k-Means Color Quantization\" crate for Image-to-Pixel-Art conversions in the browser",
        "url": "https://github.com/gametorch/image_to_pixel_art_wasm",
        "language": "Rust",
        "stars": 46,
        "forks": 1,
        "created_at": "2025-06-26T13:48:25Z",
        "updated_at": "2025-06-29T09:55:09Z",
        "topics": [],
        "quality_score": 0.6,
        "contributors_count": 0,
        "last_commit_date": "2025-06-26T23:33:11Z",
        "media_urls": [
            "https://opengraph.githubassets.com/346a2c3099d5814b4ab55c3f4556cf23c74aa62e81de3f95aafe27f4d01c2087/gametorch/image_to_pixel_art_wasm"
        ],
        "homepage": null,
        "readme_summary": "This Rust-based WebAssembly library converts raster images into low-color pixel art directly in the browser. It features k-means palette extraction, transparency handling, and downsampling with aspect ratio preservation, all processed client-side via WASM.",
        "key_features": [
            "K-means palette extraction with user-selectable color count or supply your own palette",
            "Transparency is kept intact",
            "Down-samples to a fixed tile grid using nearest-neighbour then scales back up, aspect-ratio preserved",
            "Pure client-side WASM processing"
        ],
        "primary_use_case": "Image-to-pixel-art conversions in the browser.",
        "open_issues": 0,
        "cover_image_prompt": "Imagine an artist meticulously transforming a photograph into a vibrant pixel art mosaic. The artist uses a palette of carefully chosen colors, each tile perfectly placed to recreate the original image in a retro style. A digital canvas displays the original photo alongside the pixelated version, showcasing the transformation. Subtle code snippets and color palettes float in the background, hinting at the underlying technology. The scene is bathed in soft, diffused light, creating a nostalgic and artistic atmosphere. The image should be in a 3D isometric illustration style with rich details and vibrant colors."
    },
    {
        "id": 769564277,
        "name": "code2prompt",
        "description": "A CLI tool to convert your codebase into a single LLM prompt with source tree, prompt templating, and token counting.",
        "url": "https://github.com/mufeedvh/code2prompt",
        "language": "MDX",
        "stars": 5926,
        "forks": 331,
        "created_at": "2024-03-09T12:42:06Z",
        "updated_at": "2025-06-29T10:09:50Z",
        "topics": [
            "ai",
            "chatgpt",
            "claude",
            "cli",
            "command-line",
            "command-line-tool",
            "gpt",
            "llm",
            "prompt",
            "prompt-engineering",
            "prompt-generator",
            "prompt-toolkit",
            "rust"
        ],
        "quality_score": 1.0000000000000002,
        "contributors_count": 0,
        "last_commit_date": "2025-06-24T17:23:06Z",
        "media_urls": [
            "https://opengraph.githubassets.com/4299bdcf814ac518ecb6aecc9016b4f7759ad0ee923536f41e0865f70282a9aa/mufeedvh/code2prompt"
        ],
        "homepage": "https://code2prompt.dev",
        "readme_summary": "Code2prompt is a CLI tool and SDK that transforms codebases into structured prompts for Large Language Models. It offers features like automatic code processing, smart filtering using glob patterns and .gitignore, flexible templating with Handlebars, token tracking, and Git integration. It streamlines the process of creating LLM prompts for code analysis, generation, and automation.",
        "key_features": [
            "Automatic Code Processing",
            "Smart Filtering",
            "Flexible Templating",
            "Token Tracking",
            "Git Integration",
            "Developer Experience"
        ],
        "primary_use_case": "Convert codebases into LLM prompts for code analysis, generation, and other tasks.",
        "open_issues": 11,
        "cover_image_prompt": "A skilled cartographer meticulously charting a vast, uncharted codebase, transforming complex files and directories into a beautifully detailed map. The cartographer uses specialized tools that convert code into geographical features like mountains (classes), rivers (data flow), and forests (modules). Small UI elements showing code snippets and token counts are subtly integrated into the map's borders. The scene is set in a sunlit library filled with ancient scrolls and modern technology. The image should be in a 3D isometric illustration style with rich details, vibrant colors, and a sense of exploration."
    },
    {
        "id": 861892731,
        "name": "pyspur",
        "description": "A visual playground for agentic workflows: Iterate over your agents 10x faster",
        "url": "https://github.com/PySpur-Dev/pyspur",
        "language": "TypeScript",
        "stars": 5202,
        "forks": 370,
        "created_at": "2024-09-23T17:24:52Z",
        "updated_at": "2025-06-29T08:48:58Z",
        "topics": [
            "agent",
            "agents",
            "ai",
            "builder",
            "deepseek",
            "framework",
            "gemini",
            "graph",
            "human-in-the-loop",
            "llm",
            "llms",
            "loops",
            "multimodal",
            "ollama",
            "python",
            "rag",
            "reasoning",
            "tool",
            "trace",
            "workflow"
        ],
        "quality_score": 0.6,
        "contributors_count": 0,
        "last_commit_date": "2025-05-12T12:00:57Z",
        "media_urls": [
            "https://repository-images.githubusercontent.com/861892731/c772225b-4648-4218-b944-e08a3f913a52"
        ],
        "homepage": "https://pyspur.dev",
        "readme_summary": "PySpur is a visual playground for AI agent workflows, designed to help AI engineers iterate faster. It offers features like human-in-the-loop, looping, file upload, structured outputs, RAG, multimodal support, tracing, evals, and one-click deployment, supporting various LLM vendors and Python-based extensions.",
        "key_features": [
            "Human in the Loop",
            "Loops",
            "File Upload",
            "Structured Outputs",
            "RAG",
            "Multimodal",
            "Tools",
            "Traces",
            "Evals",
            "One-Click Deploy",
            "Python-Based",
            "Any-Vendor-Support"
        ],
        "primary_use_case": "Visually iterating and debugging AI agent workflows to improve reliability and reduce development time.",
        "open_issues": 25,
        "cover_image_prompt": "A conductor orchestrating a complex symphony of AI agents, each represented by a unique instrument. The conductor, symbolizing the AI engineer, stands on a platform with a clear view of the entire orchestra, allowing for precise control and iterative refinement of the performance. Visual indicators of input data flow like musical notes into the instruments and output as harmonious melodies. Small UI elements displaying agent parameters and performance metrics subtly incorporated into the scene. The setting is a futuristic concert hall with dynamic lighting that responds to the music. The image should be in 3D isometric illustration style with rich details and vibrant colors."
    },
    {
        "id": 1051476,
        "name": "plantuml",
        "description": "Generate diagrams from textual description",
        "url": "https://github.com/plantuml/plantuml",
        "language": "Java",
        "stars": 11739,
        "forks": 1053,
        "created_at": "2010-11-04T15:55:50Z",
        "updated_at": "2025-06-29T09:31:32Z",
        "topics": [
            "diagram",
            "diagram-as-code",
            "diagrams",
            "diagrams-as-code",
            "java",
            "plantuml",
            "uml",
            "uml-diagram"
        ],
        "quality_score": 0.85,
        "contributors_count": 0,
        "last_commit_date": "2025-06-29T09:24:07Z",
        "media_urls": [
            "https://opengraph.githubassets.com/380d4b8c727f68cb79ae564fb9342b54c9ba5f5242e758c7898a1a0fa0ff5b05/plantuml/plantuml"
        ],
        "homepage": "https://plantuml.com",
        "readme_summary": "PlantUML is a tool that generates diagrams from textual descriptions. It primarily focuses on UML diagrams, supporting a wide range of UML diagram types. Additionally, it extends its capabilities to non-UML diagrams like JSON, YAML, and network diagrams, providing a versatile solution for visualizing various systems and data structures.",
        "key_features": [
            "Generates UML diagrams from textual descriptions",
            "Supports various UML diagram types (Sequence, Use case, Class, Object, Activity, Component, Deployment, State, Timing)",
            "Supports non-UML diagram types (JSON, YAML, EBNF, Regex, Network, Salt, Archimate, SDL)"
        ],
        "primary_use_case": "Generating diagrams from textual descriptions, particularly UML diagrams, but also supporting other diagram types.",
        "open_issues": 517,
        "cover_image_prompt": "A skilled architect meticulously drafting blueprints on a large drafting table, transforming complex verbal descriptions into detailed architectural diagrams. The architect uses a special pen that converts text into precise lines and shapes on the blueprint. Small screens display code snippets and UML syntax, subtly integrated into the drafting table. The scene is set in a bright, modern studio with natural lighting. The composition is clean and focused, with a warm color scheme. The image should be in a technical illustration style with labeled parts and clear details."
    },
    {
        "id": 771350543,
        "name": "WrenAI",
        "description": "⚡️Wren AI is your GenBI Agent, that you can query any database with natural language → get accurate SQL(Text-to-SQL), charts(Text-to-Charts) & AI-generated insights in seconds. ",
        "url": "https://github.com/Canner/WrenAI",
        "language": "TypeScript",
        "stars": 8477,
        "forks": 836,
        "created_at": "2024-03-13T06:18:20Z",
        "updated_at": "2025-06-29T08:33:11Z",
        "topics": [
            "agent",
            "anthropic",
            "bedrock",
            "bigquery",
            "business-intelligence",
            "charts",
            "duckdb",
            "genbi",
            "llm",
            "openai",
            "postgresql",
            "rag",
            "spreadsheets",
            "sql",
            "sqlai",
            "text-to-chart",
            "text-to-sql",
            "text2sql",
            "vertex"
        ],
        "quality_score": 1.0000000000000002,
        "contributors_count": 0,
        "last_commit_date": "2025-06-28T15:37:24Z",
        "media_urls": [
            "https://opengraph.githubassets.com/abd42f7fb868fce51a873b51a3d83be80d491dd1c0b484c675adcd5d09c82326/Canner/WrenAI"
        ],
        "homepage": "https://getwren.ai/oss",
        "readme_summary": "Wren AI is an open-source GenBI agent that allows users to query databases using natural language. It translates natural language into SQL, generates charts, and provides AI-driven insights. The platform also offers an API for embedding these capabilities into other applications.",
        "key_features": [
            "Natural language to SQL conversion",
            "AI-generated charts and reports",
            "Semantic layer for accurate LLM outputs",
            "API for embedding queries and charts in applications"
        ],
        "primary_use_case": "Querying databases with natural language to generate SQL, charts, and AI-driven insights.",
        "open_issues": 187,
        "cover_image_prompt": "Imagine a skilled architect standing before a vast blueprint of data, effortlessly translating spoken requests into precise building plans (SQL queries) and stunning architectural renderings (charts). The architect's voice activates glowing digital tools that instantly analyze the blueprint and generate insightful reports. The scene takes place in a bright, modern studio filled with floating data particles and subtle UI elements displaying database schemas. The composition is clean and focused, with a vibrant color scheme. The image should be in a 3D isometric illustration style with rich details and vibrant colors."
    },
    {
        "id": 919276446,
        "name": "starskey",
        "description": "Package for fast persistent, transactional, and embedded key-value storage. LevelDB-WiscKey inspired.",
        "url": "https://github.com/starskey-io/starskey",
        "language": "Go",
        "stars": 145,
        "forks": 10,
        "created_at": "2025-01-20T05:08:00Z",
        "updated_at": "2025-06-29T07:12:52Z",
        "topics": [
            "database",
            "key-value-store",
            "lsm-tree",
            "oltp",
            "storage-engine"
        ],
        "quality_score": 0.6,
        "contributors_count": 0,
        "last_commit_date": "2025-03-19T21:09:28Z",
        "media_urls": [
            "https://opengraph.githubassets.com/a8fc18b1cd188c796e19fc06f24303f6301b50d653b5df0399bd115ec06f6ec6/starskey-io/starskey"
        ],
        "homepage": "https://starskey.io",
        "readme_summary": "Starskey is a Go package for fast, persistent, transactional, and embedded key-value storage. It implements a multi-level, durable log-structured merge tree with features like ACID transactions, configurable options, WAL recovery, key-value separation, bloom filters, and compression. It's designed for high-performance OLTP applications.",
        "key_features": [
            "Leveled partial merge compaction",
            "ACID transactions",
            "Configurable options",
            "WAL with recovery",
            "Key value separation",
            "Bloom filters and Succinct Range Filters",
            "Compression (S2, Snappy)",
            "Thread safe",
            "T-Tree memtable",
            "Channel logging"
        ],
        "primary_use_case": "Fast persistent, transactional, and embedded key-value storage.",
        "open_issues": 0,
        "cover_image_prompt": "Imagine a celestial locksmith, the 'Starskey,' carefully organizing scattered stardust (representing data) into shimmering, structured constellations within a vast, dark cosmos (the database). The locksmith uses a special key to unlock and arrange the stardust, creating beautiful, easily accessible patterns. A faint, ethereal UI overlay shows snippets of code and data flow, subtly connecting the cosmic scene to software. The composition is clean and focused, with a deep blue and purple color scheme. The image should be in a digital painting style with clear outlines and a sense of wonder."
    }
]