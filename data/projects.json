[
    {
        "id": 1085475816,
        "name": "surge",
        "description": "Surge is a blazing fast, open-source terminal (TUI) download manager built in Go.",
        "url": "https://github.com/surge-downloader/surge",
        "language": "Go",
        "stars": 267,
        "forks": 14,
        "created_at": "2025-10-29T05:00:15Z",
        "updated_at": "2026-01-27T01:03:01Z",
        "topics": [
            "cli",
            "download-manager",
            "downloader",
            "go",
            "golang",
            "terminal",
            "tui"
        ],
        "quality_score": 0.85,
        "contributors_count": 0,
        "last_commit_date": "2026-01-26T12:26:03Z",
        "media_urls": [
            "https://opengraph.githubassets.com/f33c10e20e80f6cd22bd1d38ab8b30fb26b770b3ed10a90702319e0d6167ab9e/surge-downloader/surge"
        ],
        "homepage": "",
        "readme_summary": "Surge is a high-speed, open-source download manager built in Go, offering a versatile experience through its Terminal User Interface (TUI), Headless Server mode, and Command Line Interface (CLI) capabilities. It is designed for efficient file downloads with features like multi-connection support, pause/resume, and real-time progress monitoring.",
        "key_features": [
            "High-speed Downloads with multi-connection support",
            "Beautiful TUI built with Bubble Tea & Lipgloss",
            "Pause/Resume downloads seamlessly",
            "Real-time Progress with speed graphs and ETA",
            "Auto-retry on connection failures",
            "Batch Downloads",
            "Browser Extension integration",
            "Clipboard Integration",
            "Operates in TUI, Headless Server, or CLI modes"
        ],
        "primary_use_case": "A versatile and high-performance download manager for terminal-based workflows, automation, and background server tasks.",
        "open_issues": 3,
        "cover_image_prompt": "A powerful, stylized train engine labeled 'Surge' actively pulling multiple, thick streams of data from a cloud source towards a digital station. Each stream is a vibrant, glowing cable representing high-speed, multi-connection downloads. The train's front has a subtle, clean TUI interface displaying download progress and speed graphs. In the background, a small, discreet server rack hums, indicating headless operation. The overall scene is dynamic and futuristic, emphasizing speed, efficiency, and control in a digital landscape, rendered in a 3D isometric illustration style with a clean, vibrant color palette."
    },
    {
        "id": 658056064,
        "name": "fclones-gui",
        "description": "Interactive duplicate file finder and remover",
        "url": "https://github.com/pkolaczk/fclones-gui",
        "language": "Rust",
        "stars": 156,
        "forks": 7,
        "created_at": "2023-06-24T16:17:51Z",
        "updated_at": "2026-01-26T21:37:54Z",
        "topics": [],
        "quality_score": 0.25,
        "contributors_count": 0,
        "last_commit_date": "2023-06-27T08:08:42Z",
        "media_urls": [
            "https://opengraph.githubassets.com/24305c90807ef10d564b07e5d20654d2f7cf5463b614c7846e20b5793e308660/pkolaczk/fclones-gui"
        ],
        "homepage": null,
        "readme_summary": "fclones-gui is an interactive graphical user interface for the fclones command-line tool, designed to help users find and remove duplicate files efficiently. It offers features for identifying identical files across multiple directories, with advanced filtering options, and provides flexible methods for removing or replacing duplicates, including support for copy-on-write file systems.",
        "key_features": [
            "Identifying groups of identical files",
            "Finding duplicate files",
            "Scanning multiple directory roots",
            "Filtering names and paths by extended UNIX globs",
            "Filtering by min/max file size",
            "Proper handling of symlinks and hardlinks",
            "Optional ignoring of files specified in .gitignore",
            "Removing, moving, or replacing selected files with soft or hard links",
            "Removing redundant file data using native copy-on-write (reflink) support",
            "Bulk selection of files to remove",
            "Prioritizing files to remove by creation, modification, last access time or nesting level",
            "Parallel processing for I/O and CPU heavy stages",
            "Automatic tuning of parallelism and access strategy based on device type",
            "Low memory footprint",
            "Accurate progress reporting",
            "Uses modern GTK4 list controls"
        ],
        "primary_use_case": "Finding and removing duplicate files through an interactive graphical interface.",
        "open_issues": 8,
        "cover_image_prompt": "A diligent librarian meticulously organizing a vast, chaotic library. Piles of identical books are scattered, but the librarian, using a magnifying glass and a digital tablet displaying file icons, is systematically grouping them. The tablet shows clear 'duplicate' icons and options to 'archive' or 'shred'. Some books are transforming into glowing digital links. The scene is set in a clean, modern library with soft, organized lighting, emphasizing order being brought to chaos. Small, subtle UI elements from the fclones-gui application are visible on the tablet screen. The overall style is a 3D isometric illustration with a clean, friendly aesthetic, highlighting efficiency and clarity in managing redundant data."
    },
    {
        "id": 1062196393,
        "name": "Singularity",
        "description": "Stealthy Linux Kernel Rootkit for modern kernels (6x)",
        "url": "https://github.com/MatheuZSecurity/Singularity",
        "language": "C",
        "stars": 1264,
        "forks": 142,
        "created_at": "2025-09-23T00:07:21Z",
        "updated_at": "2026-01-27T04:10:33Z",
        "topics": [
            "ftrace",
            "hidden",
            "hooking",
            "kernel",
            "linux",
            "lkm",
            "poc",
            "rootkit",
            "syscall"
        ],
        "quality_score": 0.8500000000000001,
        "contributors_count": 0,
        "last_commit_date": "2026-01-25T19:47:23Z",
        "media_urls": [
            "https://repository-images.githubusercontent.com/1062196393/a2149a49-9fd4-44e6-8ffa-76845a998d60"
        ],
        "homepage": "",
        "readme_summary": "Singularity is a stealthy Linux Kernel Module (LKM) rootkit for modern 6.x kernels, utilizing ftrace for advanced system call hooking. It offers comprehensive features for hiding processes, files, and network connections, alongside capabilities for privilege escalation, log sanitization, and evasion of various detection mechanisms like eBPF tools and EDRs.",
        "key_features": [
            "Process Hiding",
            "File & Directory Hiding",
            "Network Stealth",
            "Privilege Escalation",
            "Log Sanitization",
            "Self-Hiding",
            "Remote Access",
            "Anti-Detection (eBPF, LKRG, io_uring)",
            "Audit Evasion",
            "Memory Forensics Evasion",
            "Cgroup Filtering",
            "Syslog Evasion",
            "Debugfs Evasion",
            "Conntrack Filtering",
            "SELinux Evasion",
            "LKRG Bypass",
            "eBPF Security Bypass"
        ],
        "primary_use_case": "To provide advanced stealth and evasion capabilities within a Linux kernel environment, primarily for security research, penetration testing, or demonstrating kernel-level vulnerabilities.",
        "open_issues": 0,
        "cover_image_prompt": "A shadowy, ethereal figure cloaked in digital mist, subtly manipulating the threads of a complex, glowing network. The figure is selectively making parts of the network invisible, like turning off lights in specific nodes, while other parts remain brightly lit. Small, almost imperceptible code snippets and data streams flow around the figure, hinting at its kernel-level operations. The background is a dark, abstract representation of a computer system's core. The overall mood is one of hidden power and sophisticated infiltration. The style should be a dark, atmospheric digital painting with glowing accents and a focus on the contrast between visibility and invisibility."
    },
    {
        "id": 874158162,
        "name": "superlinker",
        "description": "a tool for reinterpreting ELF executables and shared libraries",
        "url": "https://github.com/whitequark/superlinker",
        "language": "Rust",
        "stars": 345,
        "forks": 10,
        "created_at": "2024-10-17T10:56:14Z",
        "updated_at": "2026-01-27T04:44:29Z",
        "topics": [],
        "quality_score": 0.45,
        "contributors_count": 0,
        "last_commit_date": "2024-11-12T16:22:21Z",
        "media_urls": [
            "https://opengraph.githubassets.com/a082f31a127ce78f35f114600643d181106d46e827adce9a09376f73d5242024/whitequark/superlinker"
        ],
        "homepage": "",
        "readme_summary": "Superlinker is a Rust tool that reinterprets and combines ELF executables and shared libraries into larger, self-contained binaries. It functions like a compiler for interpreted programs, lifting ELF objects into an intermediate representation and lowering them back, enabling the merging of dynamic linkers and dependencies into a single executable.",
        "key_features": [
            "Combines ELF executables and shared libraries into larger products",
            "Lifts ELF ET_DYN objects into an intermediate representation",
            "Lowers intermediate representation back to an ELF ET_DYN object",
            "Merges dynamic linker into an executable for system independence",
            "Transforms system-dependent executables into executables that run anywhere",
            "Intermediate representation is architecture- and format-independent",
            "Frontend and backend ported to amd64"
        ],
        "primary_use_case": "Creating self-contained, dependency-free ELF executables by merging multiple libraries and the dynamic linker into a single binary.",
        "open_issues": 1,
        "cover_image_prompt": "A master craftsman, resembling a futuristic alchemist, stands in a workshop filled with glowing blueprints and digital components. They are meticulously merging several distinct, transparent vials (representing shared libraries and executables) into a single, larger, solid crystal orb (the final merged executable). Streams of light and data flow from the vials into the orb, symbolizing the combination of code and dependencies. Subtle UI elements showing code snippets and dependency graphs are visible on floating screens in the background. The overall mood is one of creation and consolidation, with a clean, modern aesthetic. 3D isometric illustration style, vibrant blues and golds, high detail."
    },
    {
        "id": 873373981,
        "name": "Allegro",
        "description": "Allegro is a powerful text-to-video model that generates high-quality videos up to 6 seconds at 15 FPS and 720p resolution from simple text input. ",
        "url": "https://github.com/rhymes-ai/Allegro",
        "language": "Python",
        "stars": 1112,
        "forks": 69,
        "created_at": "2024-10-16T04:04:15Z",
        "updated_at": "2026-01-26T20:18:30Z",
        "topics": [],
        "quality_score": 0.6000000000000001,
        "contributors_count": 0,
        "last_commit_date": "2025-02-07T15:31:36Z",
        "media_urls": [
            "https://opengraph.githubassets.com/265d109257341385897e65c168de927f5ff0e04395b95072a3bda6f27c7a28bb/rhymes-ai/Allegro"
        ],
        "homepage": "https://rhymes.ai/",
        "readme_summary": "Allegro is a Python-based text-to-video generation model capable of producing up to 6-second videos at 720p resolution and 15 FPS from text prompts. A variant, Allegro-TI2V, extends this by incorporating first-frame and optional last-frame image inputs.",
        "key_features": [
            "Text-to-Video generation",
            "Text-Image-to-Video generation (Allegro-TI2V)",
            "Generates 6-second videos at 15 FPS and 720p resolution",
            "Open-sourced models available on Hugging Face",
            "Integration with Hugging Face diffusers library",
            "Training code for fine-tuning available"
        ],
        "primary_use_case": "Generating short, high-quality videos from textual descriptions and optionally initial image frames.",
        "open_issues": 19,
        "cover_image_prompt": "A magical quill pen writing on a blank parchment, with words flowing from the tip and transforming into a vibrant, short video clip playing in the air above the parchment. The video clip shows a dynamic scene, such as a dragon flying or a cityscape evolving. Subtle digital particles emanate from the quill, and a small, stylized screen in the background displays the text prompt 'A majestic dragon soaring through clouds'. The overall mood is creative and wondrous, with a clean, modern aesthetic. The style should be a 3D isometric illustration with bright, engaging colors, clearly depicting the transformation of text into dynamic video content."
    },
    {
        "id": 873217205,
        "name": "vulnhuntr",
        "description": "Zero shot vulnerability discovery using LLMs",
        "url": "https://github.com/protectai/vulnhuntr",
        "language": "Python",
        "stars": 2460,
        "forks": 276,
        "created_at": "2024-10-15T19:44:25Z",
        "updated_at": "2026-01-26T20:39:33Z",
        "topics": [
            "ai",
            "llm",
            "security",
            "static-analysis",
            "vulnerability-detection"
        ],
        "quality_score": 0.45,
        "contributors_count": 0,
        "last_commit_date": "2025-02-06T18:04:14Z",
        "media_urls": [
            "https://opengraph.githubassets.com/de43a7c8c2578454cc1a1ff21b839877bdd4b0074caec0c4637970af8881585a/protectai/vulnhuntr"
        ],
        "homepage": "",
        "readme_summary": "Vulnhuntr is a Python tool that uses Large Language Models (LLMs) combined with static code analysis to discover complex, multi-step, remotely exploitable vulnerabilities in Python codebases. It aims to find zero-day vulnerabilities that traditional static analysis tools might miss by analyzing entire code call chains from user input to server output.",
        "key_features": [
            "Zero-shot vulnerability discovery using LLMs",
            "Identifies complex, multi-step vulnerabilities",
            "Analyzes code call chains from user input to server output",
            "Supports Python codebases",
            "Detects vulnerability classes: LFI, AFO, RCE, XSS, SQLI, SSRF, IDOR",
            "Installation via Docker or pipx",
            "Command-line interface for analysis"
        ],
        "primary_use_case": "Automated discovery of zero-day vulnerabilities in Python projects using AI and static code analysis.",
        "open_issues": 10,
        "cover_image_prompt": "A vigilant AI-powered detective, represented as a glowing, abstract digital entity, meticulously sifting through a complex network of interconnected code pathways. The detective holds a magnifying glass that highlights potential security flaws, visualized as small, red 'X' marks or glitching code snippets within the pathways. The input is depicted as streams of data flowing into the network, and the output shows secure, green-glowing pathways emerging. The background is a dark, futuristic cityscape with subtle UI elements displaying vulnerability metrics. The overall style is a 3D isometric illustration with a neon-cyberpunk aesthetic, emphasizing the AI's deep code inspection and the discovery of hidden threats."
    }
]