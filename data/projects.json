[
    {
        "id": 1043937336,
        "name": "doomscroll-detector",
        "description": "Computer vision pipeline to detect and punish doomscrolling",
        "url": "https://github.com/andrew-noble/doomscroll-detector",
        "language": "Python",
        "stars": 2,
        "forks": 0,
        "created_at": "2025-08-24T23:42:16Z",
        "updated_at": "2025-09-25T03:17:18Z",
        "topics": [],
        "quality_score": 0.44999999999999996,
        "contributors_count": 0,
        "last_commit_date": "2025-09-23T02:07:38Z",
        "media_urls": [
            "https://opengraph.githubassets.com/ecdb8c69b6d760cfa2c8bca2fd662653e100ad875ed7b8875cb7a630f661f659/andrew-noble/doomscroll-detector"
        ],
        "homepage": null,
        "readme_summary": "The Doomscrolling Detector is a computer vision pipeline designed to identify and discourage excessive phone usage while in a reclined position. It uses pose estimation and object detection to determine when a user is likely doomscrolling, and then applies a spoofed penalty counter as a deterrent.",
        "key_features": [
            "YOLOv11 pose estimation for keypoint tracking",
            "YOLO object detection for phone detection",
            "Heuristic-based reclined posture detection (hip/shoulder alignment)",
            "Wrist proximity to phone detection",
            "Spoofed penalty counter"
        ],
        "primary_use_case": "Detecting and discouraging doomscrolling behavior.",
        "open_issues": 0,
        "cover_image_prompt": "A frustrated person sinking into a couch, being slowly consumed by a swirling vortex of social media icons emanating from their phone. A digital hourglass above them shows time rapidly draining away. Subtle UI elements on the phone screen display a rapidly increasing 'doomscroll penalty' counter. The scene is set in a dimly lit living room with a sense of impending regret. Small code snippets related to pose estimation are faintly visible in the background. The composition is a close-up shot with a desaturated color scheme, punctuated by the phone's bright screen. The image should be in a digital painting style with clear outlines and a slightly exaggerated perspective."
    },
    {
        "id": 819751459,
        "name": "Air-Guard",
        "description": "ESP32 based Wi-Fi Intrusion Detection System",
        "url": "https://github.com/razvan-radutoiu/Air-Guard",
        "language": "Jupyter Notebook",
        "stars": 7,
        "forks": 0,
        "created_at": "2024-06-25T06:16:58Z",
        "updated_at": "2025-09-26T07:09:08Z",
        "topics": [],
        "quality_score": 0.15,
        "contributors_count": 0,
        "last_commit_date": "2025-05-11T09:02:27Z",
        "media_urls": [
            "https://opengraph.githubassets.com/fca6f68d6f7c897489cc2929c207303a5a0b2c1b91bc6a30b53d438bf41231d7/razvan-radutoiu/Air-Guard"
        ],
        "homepage": null,
        "readme_summary": "Air-Guard is an ESP32-based Wi-Fi Intrusion Detection System that captures and analyzes wireless communication data in real-time. It provides a graphical interface for data visualization, detects various attacks like deauthentication and Evil Twin, and uses machine learning for advanced threat detection.",
        "key_features": [
            "Real-time WiFi packet capture using ESP32",
            "Graphical user interface for easy interaction",
            "Live packet statistics and visualization",
            "Detection of deauthentication attacks and Evil_Twin attacks",
            "Machine learning-based detection of Kr00k vulnerability and web spoofing attacks",
            "Logging and data export via .pcap files or .log files"
        ],
        "primary_use_case": "Monitoring and analyzing wireless communication data to detect and prevent Wi-Fi intrusions and attacks.",
        "open_issues": 0,
        "cover_image_prompt": "A vigilant knight stands guard over a Wi-Fi router, using a glowing sword to deflect malicious data packets. The router emits a protective shield of energy, while the knight's sword glows brighter upon detecting threats like deauthentication and Evil Twin attacks. Small UI elements float around the knight, displaying real-time packet statistics and security metrics. The scene is set in a futuristic network environment with a blue and green color scheme. The image should be in a 3D isometric illustration style with clean lines and vibrant colors."
    },
    {
        "id": 1044117453,
        "name": "pageindex-mcp",
        "description": "MCP server for PageIndex",
        "url": "https://github.com/VectifyAI/pageindex-mcp",
        "language": "TypeScript",
        "stars": 10,
        "forks": 1,
        "created_at": "2025-08-25T08:00:01Z",
        "updated_at": "2025-09-26T06:25:28Z",
        "topics": [],
        "quality_score": 0.7499999999999999,
        "contributors_count": 0,
        "last_commit_date": "2025-09-24T08:04:29Z",
        "media_urls": [
            "https://opengraph.githubassets.com/f61b4296d5d05f3c01700976da2efee3bd6db1a30b3b0fc63965e7337cf9069e/VectifyAI/pageindex-mcp"
        ],
        "homepage": "https://pageindex.ai/mcp",
        "readme_summary": "The PageIndex MCP repository provides a Multi-Client Protocol (MCP) server that allows users to chat with long PDFs using Claude, even when they encounter limit restrictions. It leverages a reasoning-based RAG system to provide human-like interactions with documents, offering features like local and online PDF support and unlimited conversations.",
        "key_features": [
            "Chat with long PDFs",
            "Reasoning-based RAG system",
            "Local and online PDF support",
            "Free usage (1000 pages)",
            "Unlimited conversations",
            "Vectorless RAG (no vector DB or chunking)"
        ],
        "primary_use_case": "Enabling users to interact with long PDFs on Claude and other MCP-compatible clients by providing a reasoning-based RAG system.",
        "open_issues": 0,
        "cover_image_prompt": "A librarian meticulously organizing a vast library of PDF documents, each glowing with inner knowledge. The librarian uses a magnifying glass that transforms complex text into clear, conversational insights, which then float as thought bubbles towards a user interface showing a chat window. Subtle digital particles swirl around the documents, representing the reasoning process. A small screen displays the PageIndex logo. The scene is set in a warmly lit, futuristic library with a clean, focused composition. The image should be in a 3D isometric illustration style with rich details and a vibrant color scheme."
    },
    {
        "id": 707614074,
        "name": "link-extractor",
        "description": "Web Extension to extract, parse, and open links with optional filters.",
        "url": "https://github.com/cssnr/link-extractor",
        "language": "JavaScript",
        "stars": 74,
        "forks": 7,
        "created_at": "2023-10-20T09:25:00Z",
        "updated_at": "2025-09-26T08:41:47Z",
        "topics": [
            "browser-extension",
            "chrome-addon",
            "chrome-extension",
            "extract-links",
            "firefox-addon",
            "firefox-extension",
            "link-extraction",
            "link-extractor",
            "web-extension"
        ],
        "quality_score": 0.6,
        "contributors_count": 0,
        "last_commit_date": "2025-07-31T00:31:37Z",
        "media_urls": [
            "https://repository-images.githubusercontent.com/707614074/5ce6c147-4b15-4715-a78f-89faff8697dd"
        ],
        "homepage": "https://link-extractor.cssnr.com",
        "readme_summary": "The 'link-extractor' repository provides a web extension designed to extract, parse, and open links from web pages. It supports filtering links based on user-defined criteria, enhancing the user's ability to manage and interact with web content efficiently across multiple browsers.",
        "key_features": [
            "Extracting links from web pages",
            "Parsing links",
            "Opening links",
            "Filtering links"
        ],
        "primary_use_case": "Efficiently extracting and managing links from web pages within a browser environment.",
        "open_issues": 5,
        "cover_image_prompt": "A diligent librarian meticulously sorting through a mountain of books, each representing a webpage, and extracting glowing threads (links) from them. The librarian uses a magnifying glass that filters the threads, separating them into organized piles. A small UI element hovers nearby, displaying link extraction options. The scene is set in a grand, sunlit library with subtle digital particles floating in the air. The repository name is subtly etched on the librarian's desk. The composition is focused and clean with a warm, inviting color scheme. The image should be in a 3D isometric illustration style with rich details and vibrant colors."
    },
    {
        "id": 1013031861,
        "name": "ssh-bot",
        "description": "Telegram bot for executing commands on remote hosts via ssh.",
        "url": "https://github.com/Lifailon/ssh-bot",
        "language": "Go",
        "stars": 30,
        "forks": 2,
        "created_at": "2025-07-03T08:55:35Z",
        "updated_at": "2025-09-26T10:04:53Z",
        "topics": [
            "bot",
            "chat-bot",
            "go",
            "ssh-client",
            "telegrambot"
        ],
        "quality_score": 0.4,
        "contributors_count": 0,
        "last_commit_date": "2025-08-08T08:10:59Z",
        "media_urls": [
            "https://opengraph.githubassets.com/302fee52fab0871791c16e0b3cba7ac6a124c4d4b86c8a7d67f150499d3975c9/Lifailon/ssh-bot"
        ],
        "homepage": "https://hub.docker.com/r/lifailon/ssh-bot",
        "readme_summary": "The ssh-bot is a Telegram bot written in Go that allows users to execute commands on remote hosts via SSH. It eliminates the need for VPNs or external IPs by providing asynchronous command execution and a connection manager with host availability checks.",
        "key_features": [
            "Executing commands on local or remote hosts via SSH",
            "Parallel (asynchronous) command execution",
            "SSH connection manager with host availability check",
            "Support for directory navigation",
            "Combined access to remote hosts by key and/or password",
            "Error handling for commands requiring user input",
            "Support for storing and reusing passed variables and functions"
        ],
        "primary_use_case": "Remotely executing commands on servers or devices within a home network via Telegram.",
        "open_issues": 0,
        "cover_image_prompt": "Imagine a friendly robot butler standing in a high-tech server room, holding a Telegram chat window displaying command prompts. The butler receives commands from the chat and relays them to the servers, which respond with data streams visualized as glowing particles flowing back to the chat window. The server room is clean and organized, with subtle UI elements on the server racks displaying real-time command execution status. The robot has a small screen on its chest displaying the ssh-bot logo. The scene is brightly lit with a cool blue and green color scheme. The image should be in a 3D isometric illustration style with crisp details."
    },
    {
        "id": 831373509,
        "name": "uncloud",
        "description": "A lightweight tool for deploying and managing containerised applications across a network of Docker hosts. Bridging the gap between Docker and Kubernetes ✨",
        "url": "https://github.com/psviderski/uncloud",
        "language": "Go",
        "stars": 2390,
        "forks": 62,
        "created_at": "2024-07-20T11:13:36Z",
        "updated_at": "2025-09-26T09:42:48Z",
        "topics": [
            "containers",
            "deployment",
            "devops",
            "docker",
            "docker-compose",
            "golang",
            "kubernetes",
            "orchestration",
            "self-hosted"
        ],
        "quality_score": 1.0000000000000002,
        "contributors_count": 0,
        "last_commit_date": "2025-09-24T21:16:36Z",
        "media_urls": [
            "https://opengraph.githubassets.com/70a740c6da965615e4ba6bb80fb826731b0241122ba19d0ebb614f0ecccb94af/psviderski/uncloud"
        ],
        "homepage": "https://uncloud.run",
        "readme_summary": "Uncloud is a lightweight container orchestration tool designed to simplify the deployment and management of containerized applications across multiple Docker hosts. It aims to provide the power of multi-machine deployments with the simplicity of Docker, bridging the gap to Kubernetes by offering features like service discovery, load balancing, and automatic HTTPS without the complexity of a central control plane.",
        "key_features": [
            "Deploy anywhere (cloud VMs, bare metal)",
            "Docker Compose support",
            "Zero-downtime deployments (rolling updates)",
            "Service discovery",
            "Persistent storage",
            "Zero-config private network (WireGuard)",
            "No control plane (decentralized)",
            "Imperative over declarative approach",
            "Managed DNS",
            "Automatic HTTPS (Caddy, Let's Encrypt)",
            "Docker-like CLI",
            "Remote management"
        ],
        "primary_use_case": "Deploying and managing web applications across a network of Docker hosts with minimal cluster management overhead.",
        "open_issues": 45,
        "cover_image_prompt": "A skilled conductor orchestrating a diverse ensemble of servers, each represented by a musical instrument. The conductor uses a Docker Compose sheet as their score, seamlessly blending the sounds into a harmonious web application performance. Wires connect the instruments, forming a secure mesh network. A subtle UI overlay shows deployment progress and server status. The scene is set on a futuristic stage with dynamic lighting. Small digital elements like glowing data streams and server icons subtly connect the metaphor to software. The image should be in 3D isometric illustration style with vibrant colors and rich details."
    },
    {
        "id": 876611731,
        "name": "pinguem",
        "description": "Web interface based on Vue for async checking of the availability of the selected hosts or subnet using the node-ping library.",
        "url": "https://github.com/Lifailon/pinguem",
        "language": "Vue",
        "stars": 14,
        "forks": 0,
        "created_at": "2024-10-22T09:09:02Z",
        "updated_at": "2025-09-26T07:36:52Z",
        "topics": [
            "docker",
            "ping",
            "typescript",
            "vue",
            "web"
        ],
        "quality_score": 0.3,
        "contributors_count": 0,
        "last_commit_date": "2025-02-21T08:36:09Z",
        "media_urls": [
            "https://opengraph.githubassets.com/cd3c43099aed1b5f124ea1fdbc9a8603afc4c64751220239b4774bd114bc54c1/Lifailon/pinguem"
        ],
        "homepage": "https://hub.docker.com/r/lifailon/pinguem",
        "readme_summary": "Pinguem is a web interface built with Vue that allows users to asynchronously check the availability of hosts or subnets. It utilizes the node-ping library for pinging and provides a Prometheus exporter for monitoring ping results. The application can be deployed using Docker or built from source using npm.",
        "key_features": [
            "Asynchronous host/subnet availability checking",
            "Web interface built with Vue",
            "Dynamic address input fields with client-side storage",
            "Subnet scanning capability",
            "Docker deployment support",
            "Prometheus exporter for metrics",
            "API endpoint for retrieving ping results"
        ],
        "primary_use_case": "Monitoring the availability of hosts and subnets through a web interface and providing metrics for Prometheus.",
        "open_issues": 0,
        "cover_image_prompt": "A lighthouse keeper meticulously observing a network of ships through a high-powered telescope. Each ship represents a host, and the lighthouse beam symbolizes the ping requests. Ships within the beam glow green (available), while those outside are dimmer (unavailable). A small screen next to the keeper displays a simplified UI of the Pinguem interface. The scene is set on a rocky coastline with a stormy sea and dramatic lighting. Subtle digital particles flow from the lighthouse, visualizing the network connections. The image should be in a digital painting style with clear outlines and a focus on conveying network monitoring. The composition is focused and clear, using a cool color scheme."
    },
    {
        "id": 796010781,
        "name": "plutoprint",
        "description": "A Python Library for Generating PDFs and Images from HTML, powered by PlutoBook",
        "url": "https://github.com/plutoprint/plutoprint",
        "language": "Python",
        "stars": 956,
        "forks": 29,
        "created_at": "2024-05-04T17:00:47Z",
        "updated_at": "2025-09-26T10:10:45Z",
        "topics": [
            "css",
            "html",
            "html-to-image",
            "html-to-pdf",
            "image-generator",
            "pdf",
            "pdf-generator",
            "plutobook",
            "python",
            "svg"
        ],
        "quality_score": 0.6499999999999999,
        "contributors_count": 0,
        "last_commit_date": "2025-09-23T20:49:14Z",
        "media_urls": [
            "https://opengraph.githubassets.com/8e27c5e30b5e24613c1bd1aa7d005bdbbb88da63c530192ead71f411ab398dc7/plutoprint/plutoprint"
        ],
        "homepage": "https://plutoprint.readthedocs.io",
        "readme_summary": "PlutoPrint is a Python library that generates PDFs and images from HTML content. It leverages PlutoBook's rendering engine to provide a simple API for converting HTML into PDF documents or image files, making it suitable for generating reports, invoices, and visual snapshots.",
        "key_features": [
            "Generates PDFs from HTML",
            "Generates images from HTML",
            "Command-line interface for PDF generation",
            "Python API for PDF and image generation",
            "QR code generation support"
        ],
        "primary_use_case": "Generating reports, invoices, and visual snapshots from HTML content.",
        "open_issues": 2,
        "cover_image_prompt": "Imagine a skilled artisan meticulously crafting paper documents from shimmering threads of HTML code. The artisan uses a loom-like device that weaves the code into beautifully formatted PDFs and vibrant images. Finished documents float gently around the artisan, showcasing invoices, reports, and visual designs. Subtle UI elements on the loom display live rendering previews and code snippets. The scene is set in a bright, airy workshop filled with spools of colorful code. The image should be in a 3D isometric illustration style with clean lines and a warm color palette."
    }
]