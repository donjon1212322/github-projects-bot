[
    {
        "id": 952131779,
        "name": "tgv",
        "description": "Explore 5,000+ genomes in the terminal. Light, blazing fast 🚀, vim-motion.",
        "url": "https://github.com/zeqianli/tgv",
        "language": "Rust",
        "stars": 253,
        "forks": 8,
        "created_at": "2025-03-20T19:31:46Z",
        "updated_at": "2025-05-14T08:41:45Z",
        "topics": [
            "bioinformatics",
            "genome-viewer",
            "ratatui",
            "rust"
        ],
        "quality_score": 0.8499999999999999,
        "contributors_count": 0,
        "last_commit_date": "2025-05-10T16:18:03Z",
        "media_urls": [
            "https://repository-images.githubusercontent.com/952131779/c2962e1a-5325-4d9e-b5ac-ce0cb4f1c5df"
        ],
        "homepage": "",
        "readme_summary": "TGV is a terminal-based genome viewer written in Rust that allows users to quickly browse and explore genomes and alignment files. It supports multiple formats, including BAM, and offers Vim-like navigation for efficient exploration. It is designed for use in remote sessions where graphical genome viewers are not practical.",
        "key_features": [
            "Terminal-based genome viewer",
            "Supports multiple genome formats (BAM)",
            "Vim-like navigation",
            "Fast and lightweight",
            "Can browse remote BAM files"
        ],
        "primary_use_case": "Browsing and exploring genomes and alignment files in the terminal.",
        "open_issues": 8,
        "cover_image_prompt": "Imagine a cartographer in a high-tech library, meticulously charting a vast, swirling galaxy representing the genome. The cartographer uses a terminal interface projected onto a holographic display to navigate the complex terrain, highlighting genes and sequences with glowing markers. The library shelves are lined with ancient tomes and modern data servers, symbolizing the blend of traditional bioinformatics and cutting-edge technology. A subtle 'tgv' logo is etched into the cartographer's workstation. The scene is bathed in soft, ethereal light, creating a sense of discovery and exploration. The image should be in a detailed digital painting style with vibrant colors and crisp lines."
    },
    {
        "id": 683605055,
        "name": "AnduinOS",
        "description": "AnduinOS is a custom Ubuntu-based Linux distribution that aims to facilitate developers transitioning from Windows to Linux by maintaining familiar operational habits and workflows.",
        "url": "https://github.com/Anduin2017/AnduinOS",
        "language": "HTML",
        "stars": 310,
        "forks": 14,
        "created_at": "2023-08-27T05:42:15Z",
        "updated_at": "2025-05-14T07:29:20Z",
        "topics": [
            "debian",
            "linux-custom-image",
            "linux-distribution",
            "ubuntu"
        ],
        "quality_score": 0.9000000000000001,
        "contributors_count": 0,
        "last_commit_date": "2025-05-13T17:00:43Z",
        "media_urls": [
            "https://opengraph.githubassets.com/4f8ea47b8feda96e455ef24876ef4d4eb14e47829e0f99fdbc7eddee8dd89d46/Anduin2017/AnduinOS"
        ],
        "homepage": "https://www.anduinos.com",
        "readme_summary": "AnduinOS is a custom Ubuntu-based Linux distribution designed to ease the transition for developers moving from Windows to Linux. It achieves this by maintaining familiar operational habits and workflows. The distribution aims to provide a comfortable and efficient development environment for those accustomed to Windows.",
        "key_features": [
            "Custom Ubuntu-based Linux distribution",
            "Facilitates developers transitioning from Windows to Linux",
            "Maintains familiar operational habits and workflows"
        ],
        "primary_use_case": "Facilitating the transition of Windows developers to Linux by providing a familiar environment and workflow.",
        "open_issues": 3,
        "cover_image_prompt": "A skilled architect overseeing the construction of a modern house, seamlessly blending Windows blueprints with Linux building blocks. The architect carefully examines the Windows plans, then directs robotic arms to translate them into compatible Linux structures. A holographic display shows familiar Windows interfaces smoothly running on the Linux foundation. The scene is set in a bright, airy design studio with a minimalist aesthetic. Small code snippets and Ubuntu logos are subtly integrated into the environment. The composition is clean and focused with a harmonious color scheme. The image should be in 3D isometric illustration style with rich details and vibrant colors."
    },
    {
        "id": 720209383,
        "name": "Cap",
        "description": "Open source Loom alternative. Beautiful, shareable screen recordings.",
        "url": "https://github.com/CapSoftware/Cap",
        "language": "TypeScript",
        "stars": 9573,
        "forks": 523,
        "created_at": "2023-11-17T20:31:46Z",
        "updated_at": "2025-05-14T10:09:45Z",
        "topics": [
            "app",
            "cap",
            "coss",
            "loom",
            "mac",
            "nextjs",
            "nextjs14",
            "open-source",
            "oss",
            "react",
            "record",
            "screen-capture",
            "screen-recorder",
            "screenshot",
            "solidjs",
            "tauri",
            "tauri-app",
            "typescript",
            "vite"
        ],
        "quality_score": 0.85,
        "contributors_count": 0,
        "last_commit_date": "2025-05-14T07:18:59Z",
        "media_urls": [
            "https://opengraph.githubassets.com/5c8a080d9e5cfa8debb33a8da2101e87faea19ed52807f6dd628325ae3edf3fe/CapSoftware/Cap"
        ],
        "homepage": "https://cap.so",
        "readme_summary": "Cap is an open-source Loom alternative that allows users to record, edit, and share screen recordings. It offers desktop applications for macOS and Windows. Self-hosting options are currently under development, providing users with more control over their data and deployment.",
        "key_features": [
            "Screen recording",
            "Video editing",
            "Video sharing",
            "Self-hosting (in progress)",
            "Cross-platform (macOS & Windows)"
        ],
        "primary_use_case": "Creating and sharing screen recordings as an open-source alternative to Loom.",
        "open_issues": 113,
        "cover_image_prompt": "Imagine a skilled artisan meticulously crafting a short film using various tools on a digital workbench. The artisan is splicing together scenes, adding visual effects represented by glowing particles, and incorporating text overlays displayed on small UI screens. The final product, a polished video message, is then sent via a stylized digital envelope. The workbench is surrounded by icons representing screen recording, editing, and sharing. The scene is set in a bright, modern studio with a focus on clarity and efficiency. The image should be in a flat design style with clear iconography and a vibrant color scheme."
    },
    {
        "id": 151651158,
        "name": "sn0int",
        "description": "Semi-automatic OSINT framework and package manager",
        "url": "https://github.com/kpcyrd/sn0int",
        "language": "Rust",
        "stars": 2212,
        "forks": 187,
        "created_at": "2018-10-05T00:10:47Z",
        "updated_at": "2025-05-14T09:27:43Z",
        "topics": [
            "bug-bounty",
            "certificate-transparency",
            "intelligence",
            "investigation",
            "location",
            "lua",
            "osint",
            "osint-framework",
            "pentesting",
            "recon",
            "reconnaissance",
            "rust",
            "security",
            "security-audit",
            "security-scanner"
        ],
        "quality_score": 0.55,
        "contributors_count": 0,
        "last_commit_date": "2025-01-31T17:41:53Z",
        "media_urls": [
            "https://repository-images.githubusercontent.com/151651158/b2306680-663f-11e9-9094-711bee5cf2f3"
        ],
        "homepage": "https://sn0int.readthedocs.io/",
        "readme_summary": "sn0int is a semi-automatic OSINT framework and package manager written in Rust. It enumerates attack surface by semi-automatically processing public information and mapping the results in a unified format for followup investigations. It is extensible via modules that can be shared through a registry, allowing users to easily add new capabilities.",
        "key_features": [
            "Harvest subdomains from certificate transparency logs and passive DNS",
            "Mass resolve collected subdomains and scan for HTTP/HTTPS services",
            "Enrich IP addresses with ASN and GeoIP information",
            "Harvest emails from PGP keyservers and WHOIS",
            "Discover compromised logins in breaches",
            "Find somebody's profiles across the internet",
            "Enumerate local networks with unique techniques like passive ARP",
            "Gather information about phone numbers",
            "Harvest activity and images from social media profiles",
            "Basic image processing",
            "Extensible via modules and a registry"
        ],
        "primary_use_case": "Gathering intelligence about a given target or about yourself for IT security professionals, bug bounty hunters, law enforcement agencies, and security awareness trainings.",
        "open_issues": 46,
        "cover_image_prompt": "A detective meticulously piecing together a complex web of interconnected clues on a large digital corkboard. The detective uses a magnifying glass that highlights connections between social media profiles, email addresses, IP addresses, and other digital footprints. The corkboard is overlaid with subtle digital interfaces showing data streams and network maps. The scene is set in a dimly lit, high-tech office with multiple monitors displaying OSINT data. The repository name, 'sn0int', is subtly displayed on one of the monitors. The image should be in a digital painting style with a focus on detail and a sense of mystery."
    },
    {
        "id": 221571611,
        "name": "python-kasa",
        "description": "🏠🤖 Python API for TP-Link smarthome products",
        "url": "https://github.com/python-kasa/python-kasa",
        "language": "Python",
        "stars": 1401,
        "forks": 221,
        "created_at": "2019-11-13T23:34:19Z",
        "updated_at": "2025-05-13T22:48:37Z",
        "topics": [
            "asyncio",
            "kasa",
            "python",
            "smarthome",
            "tapo",
            "tplink"
        ],
        "quality_score": 0.7999999999999999,
        "contributors_count": 0,
        "last_commit_date": "2025-03-04T07:16:47Z",
        "media_urls": [
            "https://opengraph.githubassets.com/985b0313ea44c024e63d03a927f838939d6af8aa4db24385b26c7285ad00864e/python-kasa/python-kasa"
        ],
        "homepage": "https://python-kasa.readthedocs.io/en/stable/",
        "readme_summary": "The python-kasa library provides a Python API for interacting with TP-Link smart home devices. It allows users to discover, control, and monitor devices such as plugs, switches, and bulbs through a command-line interface or programmatically within Python scripts.",
        "key_features": [
            "Control of TP-Link smart home devices (plugs, switches, bulbs)",
            "Device discovery",
            "Command-line interface",
            "Asynchronous operation"
        ],
        "primary_use_case": "Controlling TP-Link smart home devices programmatically using Python.",
        "open_issues": 44,
        "cover_image_prompt": "Imagine a friendly robot butler in a modern smart home, diligently managing various appliances. The butler holds a tablet displaying a simplified UI with icons representing lights, plugs, and other devices. The robot taps an icon, and the corresponding device in the home responds instantly. Subtle code snippets float around the robot, connecting it to the digital world. The scene is brightly lit with a clean, minimalist aesthetic. The image should be in a 3D isometric illustration style with vibrant colors and clear details, emphasizing ease of use and seamless integration."
    },
    {
        "id": 1017451,
        "name": "watchdog",
        "description": "Python library and shell utilities to monitor filesystem events.",
        "url": "https://github.com/gorakhargosh/watchdog",
        "language": "Python",
        "stars": 6897,
        "forks": 716,
        "created_at": "2010-10-23T12:00:17Z",
        "updated_at": "2025-05-14T10:07:44Z",
        "topics": [],
        "quality_score": 0.95,
        "contributors_count": 0,
        "last_commit_date": "2025-04-25T15:56:36Z",
        "media_urls": [
            "https://opengraph.githubassets.com/7670f0402a89c244ff0086814eb5bdd1e98a7f9e71d2bdad57dcfd1042c0f10d/gorakhargosh/watchdog"
        ],
        "homepage": "http://packages.python.org/watchdog/",
        "readme_summary": "The Watchdog library provides a Python API and shell utilities for monitoring file system events. It allows developers to observe changes in directories and files, triggering custom actions or scripts in response. The `watchmedo` utility offers command-line tools for logging events and executing shell commands, while the 'tricks' feature enables advanced event handling through YAML configuration.",
        "key_features": [
            "File system event monitoring",
            "Python API for event handling",
            "Shell utilities (watchmedo)",
            "Tricks for custom event handling via YAML configuration"
        ],
        "primary_use_case": "Monitoring file system events and triggering actions based on those events.",
        "open_issues": 192,
        "cover_image_prompt": "A diligent gardener tending to a digital garden, where files sprout like plants. The gardener uses a watering can labeled 'watchdog' to nurture the garden, triggering actions like automated pruning (code formatting) and pest control (security scans) when new files grow. Small UI elements float around the garden, displaying file system events in real-time. The scene is set in a bright, sunny greenhouse with a clean, focused composition. The image should be in a 3D isometric illustration style with vibrant colors and clear details."
    },
    {
        "id": 494107715,
        "name": "datafusion-ballista",
        "description": "Apache DataFusion Ballista Distributed Query Engine",
        "url": "https://github.com/apache/datafusion-ballista",
        "language": "Rust",
        "stars": 1750,
        "forks": 218,
        "created_at": "2022-05-19T14:32:27Z",
        "updated_at": "2025-05-13T22:08:47Z",
        "topics": [
            "arrow",
            "big-data",
            "dataframe",
            "distributed",
            "olap",
            "python",
            "query-engine",
            "rust",
            "sql"
        ],
        "quality_score": 0.85,
        "contributors_count": 0,
        "last_commit_date": "2025-05-05T16:45:42Z",
        "media_urls": [
            "https://opengraph.githubassets.com/b0284a943d2730b6c97adfd851d40adc2f56bc41c79099131f201bf348091f25/apache/datafusion-ballista"
        ],
        "homepage": "https://datafusion.apache.org/ballista",
        "readme_summary": "Ballista is a distributed query execution engine built on top of Apache DataFusion. It allows DataFusion applications to be scaled out to a cluster of machines, enabling parallel processing of large datasets. The system uses a scheduler and executor architecture and can be deployed using Docker Compose or Kubernetes.",
        "key_features": [
            "Distributed query execution engine",
            "Enhances Apache DataFusion",
            "Parallelized workload execution across multiple nodes",
            "Supports SQL queries",
            "Uses a scheduler and executor architecture",
            "Deployable with Docker Compose or Kubernetes"
        ],
        "primary_use_case": "Distributing DataFusion applications to enable parallel query execution across a cluster of machines.",
        "open_issues": 121,
        "cover_image_prompt": "A skilled conductor leading an orchestra where each musician represents a different server node. The conductor's baton transforms a complex musical score (SQL query) into a harmonious performance, with each section of the orchestra playing in perfect synchronization. Visual indicators of data flow like glowing musical notes rise from the orchestra and converge into a beautiful symphony (the query result). Small UI elements showing query execution plans are subtly displayed on music stands. The scene is set in a grand concert hall with warm, inviting lighting. The image should be in 3D isometric illustration style with rich details and vibrant colors."
    },
    {
        "id": 5891360,
        "name": "radon",
        "description": "Various code metrics for Python code",
        "url": "https://github.com/rubik/radon",
        "language": "Python",
        "stars": 1833,
        "forks": 122,
        "created_at": "2012-09-20T18:58:58Z",
        "updated_at": "2025-05-13T22:23:56Z",
        "topics": [
            "cli",
            "code-analysis",
            "python",
            "quality-assurance",
            "static-analysis"
        ],
        "quality_score": 0.45,
        "contributors_count": 0,
        "last_commit_date": "2024-10-20T09:52:52Z",
        "media_urls": [
            "https://opengraph.githubassets.com/eeb308744edc5a7788e00e9a1a12d501aa5bcf0c7bd3582a49419711d0261f6d/rubik/radon"
        ],
        "homepage": "http://radon.readthedocs.org/",
        "readme_summary": "Radon is a Python tool designed for static code analysis. It computes various metrics, including McCabe's complexity, raw metrics like SLOC, Halstead metrics, and the Maintainability Index, providing insights into code quality and complexity. Radon can be used from the command line or programmatically and supports Python versions from 2.7 to 3.12.",
        "key_features": [
            "McCabe's complexity (cyclomatic complexity)",
            "Raw metrics (SLOC, comment lines, blank lines, etc.)",
            "Halstead metrics",
            "Maintainability Index"
        ],
        "primary_use_case": "Analyzing Python code to compute various code metrics for quality assurance and complexity assessment.",
        "open_issues": 29,
        "cover_image_prompt": "A meticulous architect examining blueprints (Python code) with a magnifying glass, identifying structural weaknesses and potential issues. The blueprints are spread across a large drafting table in a sunlit studio. The architect's tools include a complexity meter and a quality assurance checklist. Subtle digital elements, like a glowing maintainability index overlay and small code snippets projected onto the table, connect the scene to software analysis. The composition is clean and focused, with a warm color scheme. The image should be in a detailed technical illustration style with labeled parts and clear outlines."
    }
]