[
    {
        "id": 930540725,
        "name": "exif-viewer",
        "description": "A browser extension to display EXIF data of images directly on web pages.",
        "url": "https://github.com/ternera/exif-viewer",
        "language": "JavaScript",
        "stars": 15,
        "forks": 0,
        "created_at": "2025-02-10T19:53:38Z",
        "updated_at": "2025-03-15T08:19:54Z",
        "topics": [],
        "quality_score": 0.44999999999999996,
        "contributors_count": 0,
        "last_commit_date": "2025-03-10T14:45:46Z",
        "media_urls": [
            "https://opengraph.githubassets.com/deb07619839bad27fe5dba1f71da5c572e830014bfb0fbaa182a0451f8157754/ternera/exif-viewer"
        ],
        "homepage": null,
        "readme_summary": "The EXIF Metadata Viewer extension allows users to view hidden details embedded within images directly from their browser. It reveals information such as camera settings, location data, and the date and time the image was captured. This extension respects user privacy and does not collect personal data.",
        "key_features": [
            "Displays camera settings (make, model, aperture, shutter speed, ISO)",
            "Shows location data (if available)",
            "Displays date and time of capture",
            "Reveals other metadata (software used, artist information)"
        ],
        "primary_use_case": "Displaying EXIF data of images directly on web pages.",
        "open_issues": 0,
        "cover_image_prompt": "An art historian meticulously examining a photograph with a magnifying glass that reveals hidden layers of data like camera settings, location coordinates, and timestamps. The photograph rests on a digital tablet displaying a simplified EXIF data interface. Faint lines of code subtly overlay the scene, connecting the magnifying glass to the digital realm. The setting is a brightly lit, modern art gallery. The image should be in a clean, flat design style with clear iconography and a vibrant color scheme. The repository name, 'EXIF Viewer,' is subtly displayed on the tablet's screen."
    },
    {
        "id": 879320294,
        "name": "pydoll",
        "description": "Pydoll is a library for automating chromium-based browsers without a WebDriver, offering realistic interactions. It supports Python's asynchronous features, enhancing performance and enabling event capturing and simultaneous web scraping.",
        "url": "https://github.com/thalissonvs/pydoll",
        "language": "Python",
        "stars": 2620,
        "forks": 151,
        "created_at": "2024-10-27T15:46:43Z",
        "updated_at": "2025-03-15T09:45:16Z",
        "topics": [],
        "quality_score": 1.2000000000000002,
        "contributors_count": 0,
        "last_commit_date": "2025-03-13T16:55:57Z",
        "media_urls": [
            "https://opengraph.githubassets.com/31cd27d9f45c37b419ee2dcef7f7ea389607cd54e30472796cc1053d2dd1a918/thalissonvs/pydoll"
        ],
        "homepage": "",
        "readme_summary": "Pydoll is a Python library designed for automating Chromium browsers without relying on WebDrivers. It offers features like asynchronous programming for enhanced performance, realistic human-like interactions, and native Captcha bypassing. The library is suitable for web scraping and automating tasks that require sophisticated browser control.",
        "key_features": [
            "WebDriver-less Chromium automation",
            "Asynchronous programming for performance",
            "Realistic human-like interactions",
            "Native Captcha Bypass",
            "Advanced Event System",
            "Concurrent Scraping"
        ],
        "primary_use_case": "Automating Chromium-based browsers for web scraping and interaction without the need for WebDrivers.",
        "open_issues": 11,
        "cover_image_prompt": "Imagine a skilled puppeteer controlling a fleet of sleek, chrome browsers with invisible strings. The puppeteer, representing Pydoll, stands confidently amidst a digital landscape, effortlessly guiding the browsers through complex websites and captchas. Each browser navigates seamlessly, bypassing security measures with ease. Subtle code snippets and data visualizations float in the background, hinting at the underlying technology. The scene is bathed in a futuristic glow, with a clean and focused composition. The image should be in a 3D isometric illustration style with rich details and vibrant colors."
    },
    {
        "id": 926863501,
        "name": "thedeck",
        "description": "The Deck: An Open-Source, Cross-Platform, Mobile, Turn by Turn Card Game Engine in Flutter",
        "url": "https://github.com/xajik/thedeck",
        "language": "Dart",
        "stars": 643,
        "forks": 30,
        "created_at": "2025-02-04T01:35:35Z",
        "updated_at": "2025-03-15T09:14:03Z",
        "topics": [
            "android",
            "dart",
            "flutter",
            "game",
            "gamedev",
            "gamedevelopment",
            "ios",
            "mobile",
            "socket-io"
        ],
        "quality_score": 0.3,
        "contributors_count": 0,
        "last_commit_date": "2025-02-09T04:45:27Z",
        "media_urls": [
            "https://opengraph.githubassets.com/ec165e6b14dee90692a1abc1b791976db69cf6de13f018f242d05f86e5e9cec0/xajik/thedeck"
        ],
        "homepage": "https://getthedeck.com",
        "readme_summary": "The Deck is an open-source Flutter-based mobile card game engine designed for playing classic card games in a cooperative, offline multiplayer setting. It allows one device to act as the central 'table' or deck, distributing the game state to other players' devices, creating a shared and immersive gaming experience. The application supports both Android and iOS platforms.",
        "key_features": [
            "Mobile multiplayer card game engine",
            "Cross-platform (Android and iOS)",
            "Offline play supported",
            "One device acts as the 'table' or deck",
            "Supports classic card games"
        ],
        "primary_use_case": "Providing a digital environment for playing classic card games with friends, where one device acts as the central 'table' and distributes the game state to other players' devices.",
        "open_issues": 0,
        "cover_image_prompt": "Imagine a group of friends gathered around a digital card table, represented by a glowing tablet in the center. Each friend holds a smartphone displaying their individual hand of cards. The tablet projects a shared game board visible to all players. Digital cards float from the tablet to each player's phone, symbolizing the distribution of cards. The scene is set in a cozy living room with warm lighting. Subtle UI elements on the phones show card game interfaces. The repository's name, 'The Deck,' is subtly etched on the tablet's surface. The image should be in a 3D isometric illustration style with vibrant colors and clear details."
    },
    {
        "id": 855091786,
        "name": "dockershrink",
        "description": "Dockershrink is an AI Assistant that reduces the size of your application's Docker Image",
        "url": "https://github.com/duaraghav8/dockershrink",
        "language": "Go",
        "stars": 384,
        "forks": 53,
        "created_at": "2024-09-10T09:41:49Z",
        "updated_at": "2025-03-15T07:10:17Z",
        "topics": [
            "ai",
            "ai-agent",
            "containers",
            "docker",
            "optimization",
            "retrieval-augmented-generation"
        ],
        "quality_score": 0.6,
        "contributors_count": 0,
        "last_commit_date": "2025-01-26T17:54:38Z",
        "media_urls": [
            "https://opengraph.githubassets.com/236560d55ff90fbc762045532095376d56c791a01bbd8b7a5d24a4467f8a13c9/duaraghav8/dockershrink"
        ],
        "homepage": "",
        "readme_summary": "Dockershrink is an AI-powered command-line tool designed to reduce the size of Docker images. It optimizes existing Dockerfiles and generates new ones, employing techniques like multi-stage builds and lighter base images. The tool currently supports NodeJS applications and aims to minimize storage costs, data transfer fees, and build times associated with bloated Docker images.",
        "key_features": [
            "Generates optimized Dockerfile and .dockerignore for new projects",
            "Optimizes existing Docker image definitions using best practices",
            "Applies techniques like Multi-Stage builds and lighter base images",
            "Dependency checks",
            "AI-powered optimization"
        ],
        "primary_use_case": "Reducing the size of Docker images, especially for NodeJS applications.",
        "open_issues": 23,
        "cover_image_prompt": "Imagine a blacksmith meticulously hammering a large, bulky metal container (representing a bloated Docker image) on an anvil. With each strike, sparks fly, and the container shrinks, becoming sleeker and more efficient. The blacksmith uses AI-powered tools, subtly displayed on a nearby screen, to guide the optimization process. The background features a futuristic workshop with glowing digital elements representing data flow and efficiency. The repository name, 'DockerShrink,' is subtly etched onto the anvil. The image should be in a 3D isometric illustration style with clear details and a vibrant color scheme, conveying the concept of reducing Docker image size through AI-driven optimization."
    },
    {
        "id": 310933773,
        "name": "winapps",
        "description": "Run Windows apps such as Microsoft Office/Adobe in Linux (Ubuntu/Fedora) and GNOME/KDE as if they were a part of the native OS, including Nautilus integration.",
        "url": "https://github.com/Fmstrat/winapps",
        "language": "Shell",
        "stars": 9015,
        "forks": 418,
        "created_at": "2020-11-07T21:19:24Z",
        "updated_at": "2025-03-15T09:19:05Z",
        "topics": [],
        "quality_score": 0.7,
        "contributors_count": 0,
        "last_commit_date": "2024-08-18T15:48:39Z",
        "media_urls": [
            "https://opengraph.githubassets.com/082406efe186c6dbd3dd4dfa024336f3e77c55f1bc423143f13d21416edc26d3/Fmstrat/winapps"
        ],
        "homepage": "",
        "readme_summary": "WinApps allows users to run Windows applications within Linux distributions like Ubuntu and Fedora, integrating them into the GNOME/KDE desktop environment as if they were native applications. It achieves this by running a Windows RDP server in a background VM, detecting installed applications, and creating shortcuts for easy access, including Nautilus integration for file handling.",
        "key_features": [
            "Runs Windows applications in Linux.",
            "Integrates Windows apps into GNOME/KDE desktops.",
            "Provides Nautilus integration for file opening.",
            "Supports any installed application.",
            "Automatically detects installed applications.",
            "Creates shortcuts for CLI and GNOME tray.",
            "Provides access to home directory files via RDP."
        ],
        "primary_use_case": "Running Windows applications seamlessly within a Linux environment.",
        "open_issues": 225,
        "cover_image_prompt": "Imagine a skilled artisan in a workshop, seamlessly integrating a stained-glass window (representing a Windows application) into a modern, minimalist Linux home. The artisan carefully fits the window into the existing structure, making it appear as a natural part of the design. Digital particles subtly flow from the window, enhancing the surrounding Linux environment. A blueprint with the 'WinApps' logo rests on a nearby table. The scene is bathed in soft, ambient light, creating a sense of harmony and integration. The image should be in a clean, flat design style with clear iconography and a focus on seamless integration."
    },
    {
        "id": 931420518,
        "name": "hector-rag",
        "description": "Hector RAG is a modular RAG framework built on PostgreSQL, offering advanced retrieval methods and fusion techniques for AI-driven applications.",
        "url": "https://github.com/P3-AI-Network/hector-rag",
        "language": "Python",
        "stars": 36,
        "forks": 4,
        "created_at": "2025-02-12T08:49:18Z",
        "updated_at": "2025-03-15T08:31:49Z",
        "topics": [],
        "quality_score": 0.9000000000000001,
        "contributors_count": 0,
        "last_commit_date": "2025-02-24T22:07:00Z",
        "media_urls": [
            "https://opengraph.githubassets.com/6c1c66d6492b1e5922dc85203827dfe83c6cbc8072ba33bca528f558e80a7e68/P3-AI-Network/hector-rag"
        ],
        "homepage": "",
        "readme_summary": "Hector RAG is a modular RAG framework built on PostgreSQL, designed for creating advanced AI applications. It offers multiple retrieval methods, including similarity, keyword, and graph-based approaches, combined with Reciprocal Rank Fusion. The framework's modular architecture allows for easy customization and integration into existing systems.",
        "key_features": [
            "Multiple RAG retrieval methods (Similarity Search, Keyword Search, Graph Retrieval, KAG)",
            "Reciprocal Rank Fusion (RRF) for combining multiple retrieval methods",
            "Built on PostgreSQL vector database",
            "Modular architecture",
            "Advanced RAG pipeline creation"
        ],
        "primary_use_case": "Building modular and extensible Retrieval Augmented Generation (RAG) pipelines for AI-driven applications.",
        "open_issues": 3,
        "cover_image_prompt": "Imagine a skilled librarian in a vast, glowing digital library, carefully selecting books (representing data sources) and arranging them on a special table. As the librarian places each book, it transforms into a glowing node within a complex network graph, connected by shimmering lines. A magnifying glass hovers over the graph, revealing hidden connections and insights. Small UI elements display search queries and retrieved documents. The scene is bathed in soft, ethereal light with a color scheme of blues and greens. The image should be in a 3D isometric illustration style with rich details and vibrant colors."
    },
    {
        "id": 708775091,
        "name": "dockge",
        "description": "A fancy, easy-to-use and reactive self-hosted docker compose.yaml stack-oriented manager",
        "url": "https://github.com/louislam/dockge",
        "language": "TypeScript",
        "stars": 15566,
        "forks": 461,
        "created_at": "2023-10-23T11:18:20Z",
        "updated_at": "2025-03-15T10:07:57Z",
        "topics": [
            "docker",
            "docker-compose",
            "docker-deployment",
            "docker-stack",
            "docker-stack-deploy",
            "docker-ui",
            "responsive",
            "self-hosted",
            "selfhosted",
            "single-page-app",
            "socket-io",
            "webapp",
            "websocket"
        ],
        "quality_score": 0.8,
        "contributors_count": 0,
        "last_commit_date": "2025-01-04T10:14:17Z",
        "media_urls": [
            "https://repository-images.githubusercontent.com/708775091/65893b2a-e134-4797-8b37-a49bc4d7ad98"
        ],
        "homepage": "https://dockge.kuma.pet",
        "readme_summary": "Dockge is a self-hosted Docker Compose manager that provides a user-friendly and reactive interface for managing Docker stacks. It allows users to create, edit, start, stop, and update their `compose.yaml` files, offering features like an interactive editor, web terminal, and support for multiple Docker hosts. Dockge aims to simplify Docker stack management with a focus on ease of use and real-time feedback.",
        "key_features": [
            "Manage docker-compose.yaml files (Create/Edit/Start/Stop/Restart/Delete)",
            "Update Docker Images",
            "Interactive Editor for compose.yaml",
            "Interactive Web Terminal",
            "Multiple agents support for managing stacks from different Docker hosts",
            "Convert docker run commands into compose.yaml",
            "File-based structure for compose files",
            "Reactive UI with real-time progress and terminal output"
        ],
        "primary_use_case": "Managing and orchestrating Docker Compose stacks in a self-hosted environment.",
        "open_issues": 67,
        "cover_image_prompt": "A skilled conductor orchestrating a symphony of Docker containers, each represented by a musical instrument. The conductor uses a digital baton (stylus) on a tablet displaying a `compose.yaml` file, seamlessly managing the containers' harmonious performance. Visual cues like glowing lines connect the conductor's actions to the containers, showcasing real-time responsiveness. The scene is set on a futuristic stage with subtle UI elements and code snippets projected onto the backdrop. The repository name, 'Dockge,' is subtly integrated into the stage design. The image should be in a 3D isometric illustration style with vibrant colors and clear details."
    },
    {
        "id": 634972366,
        "name": "maelstrom",
        "description": "Maelstrom is a fast Rust, Go, and Python test runner that runs every test in its own container. Tests are either run locally or distributed to a clustered job runner.",
        "url": "https://github.com/maelstrom-software/maelstrom",
        "language": "Rust",
        "stars": 654,
        "forks": 12,
        "created_at": "2023-05-01T17:13:44Z",
        "updated_at": "2025-03-15T03:31:14Z",
        "topics": [
            "cargo-subcommand",
            "containers",
            "distributed-systems",
            "go",
            "golang",
            "pytest",
            "python",
            "rust",
            "testing"
        ],
        "quality_score": 1.0000000000000002,
        "contributors_count": 0,
        "last_commit_date": "2025-03-14T23:43:52Z",
        "media_urls": [
            "https://opengraph.githubassets.com/344f4771db27b36f1d5c65ca826b68c521a23adef58b93870a8ed63367f6a7dd/maelstrom-software/maelstrom"
        ],
        "homepage": "https://maelstrom-software.com/",
        "readme_summary": "Maelstrom is a test runner that executes each test in its own container, providing isolation and eliminating dependency conflicts. It supports Rust, Go, and Python, offering drop-in replacements for standard test runners. Maelstrom can be run locally or distributed across a cluster for scalable testing.",
        "key_features": [
            "Runs tests in isolated micro-containers",
            "Supports Rust, Go, and Python",
            "Provides drop-in replacements for common test runners",
            "Scalable with distributed cluster support",
            "Rootless container implementation for low overhead",
            "General-purpose job execution system with gRPC API and Rust bindings"
        ],
        "primary_use_case": "Running tests in isolated containers, either locally or distributed across a cluster, for Rust, Go, and Python projects.",
        "open_issues": 191,
        "cover_image_prompt": "A team of construction workers meticulously building a skyscraper out of Lego bricks, each brick representing a software test. Some workers are carefully placing bricks, while others are inspecting the structure with magnifying glasses, ensuring each brick is perfectly aligned and secure. The skyscraper is surrounded by smaller, incomplete structures, symbolizing individual tests in progress. A blueprint on a nearby table shows a complex architectural design, representing the overall test suite. Small screens display code snippets and test results, subtly connecting the metaphor to software testing. The scene is set in a bright, modern workshop with a focus on precision and quality. The image should be in 3D isometric illustration style with rich details and vibrant colors."
    },
    {
        "id": 678562120,
        "name": "binsider",
        "description": "Analyze ELF binaries like a boss 😼🕵️‍♂️",
        "url": "https://github.com/orhun/binsider",
        "language": "Rust",
        "stars": 3074,
        "forks": 71,
        "created_at": "2023-08-14T21:00:36Z",
        "updated_at": "2025-03-15T04:12:21Z",
        "topics": [
            "analysis",
            "binary",
            "binary-data",
            "dynamic-analysis",
            "elf",
            "hex-editor",
            "hexdump",
            "linux",
            "ratatui",
            "reverse-engineering",
            "rust",
            "static-analysis",
            "terminal",
            "terminal-ui",
            "terminal-user-interface",
            "tui"
        ],
        "quality_score": 1.05,
        "contributors_count": 0,
        "last_commit_date": "2025-02-22T22:13:16Z",
        "media_urls": [
            "https://repository-images.githubusercontent.com/678562120/78ce6c60-636b-4158-a36c-83d92004327d"
        ],
        "homepage": "https://binsider.dev/",
        "readme_summary": "Binsider is a Rust-based tool for analyzing ELF binaries. It provides both static and dynamic analysis capabilities, allowing users to inspect file information, examine the binary layout, perform hexdumps, and analyze linked libraries. The tool features a user-friendly terminal user interface, making it a valuable asset for reverse engineers and security professionals.",
        "key_features": [
            "General binary file information retrieval (file size, permissions, etc.)",
            "Static analysis of ELF layout (sections, segments, symbols, relocations)",
            "Hexdump functionality",
            "Dynamic analysis capabilities",
            "Terminal User Interface (TUI)"
        ],
        "primary_use_case": "Analyzing ELF binaries for reverse engineering and security auditing.",
        "open_issues": 23,
        "cover_image_prompt": "Imagine a skilled detective meticulously examining a complex clockwork mechanism representing an ELF binary. The detective uses magnifying glasses and specialized tools to analyze the gears, springs, and levers, revealing hidden functions and potential vulnerabilities. Small screens display disassembled code and memory maps as clues. The scene is set in a dimly lit workshop filled with technical diagrams and reference materials. The composition is focused and detailed, with a color scheme of deep blues and greens. The image should be in a technical illustration style with labeled parts and clear outlines, reminiscent of a vintage engineering blueprint."
    }
]