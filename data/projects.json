[
    {
        "id": 887103582,
        "name": "objcurses",
        "description": "ncurses 3d object viewer",
        "url": "https://github.com/admtrv/objcurses",
        "language": "C++",
        "stars": 29,
        "forks": 1,
        "created_at": "2024-11-12T07:07:12Z",
        "updated_at": "2025-05-21T09:46:03Z",
        "topics": [
            "3d-engine",
            "3d-graphics",
            "ascii",
            "ascii-graphics",
            "ascii-rendering",
            "c-cpp",
            "command-line",
            "command-line-tool",
            "cplusplus",
            "cplusplus-20",
            "cpp",
            "educational-project",
            "from-scratch",
            "learning-project",
            "rendering",
            "rendering-3d-graphics",
            "rendering-engine",
            "retro-programming",
            "terminal",
            "wavefront-obj"
        ],
        "quality_score": 0.44999999999999996,
        "contributors_count": 0,
        "last_commit_date": "2025-05-19T14:39:56Z",
        "media_urls": [
            "https://opengraph.githubassets.com/ff114f6976b033b7c29fc24e1d2a4e75a6c79fb83a75cc38e9fd23870281b85b/admtrv/objcurses"
        ],
        "homepage": "",
        "readme_summary": "objcurses is a terminal-based 3D object viewer that renders .obj models using ASCII characters. It allows users to preview 3D files directly in the terminal, control the camera and lighting in real-time, and supports basic colors from .mtl files. This tool is useful for quickly previewing 3D models without launching a heavy editor.",
        "key_features": [
            "Render .obj files directly in terminal",
            "Real-time camera and directional light control",
            "Basic color support from .mtl material files",
            "HUD overlay for additional stats"
        ],
        "primary_use_case": "Previewing 3D models quickly in the terminal without needing a full 3D editor.",
        "open_issues": 0,
        "cover_image_prompt": "Imagine an artist in a dimly lit, retro-futuristic workshop, meticulously sculpting a complex 3D model entirely out of ASCII characters. The model, a sleek spaceship, hovers in the center of the room, illuminated by the glow of a vintage CRT monitor displaying the ncurses interface. The artist uses a keyboard and mouse as chisels, carefully arranging each character to form the ship's hull. The workshop is filled with discarded ASCII art and technical diagrams. The scene should be in a digital painting style with clear outlines and a nostalgic color palette of greens and blacks, reminiscent of old terminal screens. The repository name 'objcurses' is subtly etched onto a nearby workbench."
    },
    {
        "id": 976256008,
        "name": "Simple-Site-Monitor",
        "description": "A robust web application for monitoring website uptime, performance, and SSL certificate expiration.",
        "url": "https://github.com/DarthTigerson/Simple-Site-Monitor",
        "language": "JavaScript",
        "stars": 64,
        "forks": 6,
        "created_at": "2025-05-01T19:27:34Z",
        "updated_at": "2025-05-21T08:31:19Z",
        "topics": [],
        "quality_score": 0.44999999999999996,
        "contributors_count": 0,
        "last_commit_date": "2025-05-20T21:30:31Z",
        "media_urls": [
            "https://opengraph.githubassets.com/811ca91a57cb1183819254eed3774567e0347c04758e19825df54a2d44ab62c0/DarthTigerson/Simple-Site-Monitor"
        ],
        "homepage": "",
        "readme_summary": "Simple Site Monitor is a web application designed to monitor website uptime, performance, and SSL certificate expiration. It provides a dashboard for real-time tracking, configurable thresholds, webhook notifications, and Docker support for easy deployment.",
        "key_features": [
            "Real-time Website Monitoring",
            "SSL Certificate Monitoring",
            "Configurable Thresholds",
            "Webhook Notifications",
            "Advanced Log History",
            "Intelligent Search",
            "Tagging System",
            "Responsive UI",
            "Docker Support"
        ],
        "primary_use_case": "Monitoring website uptime, performance, and SSL certificate expiration.",
        "open_issues": 14,
        "cover_image_prompt": "A diligent doctor monitoring a patient's vital signs on a series of interconnected screens, each representing a different website. The screens display website uptime, response times, and SSL certificate status. The doctor is surrounded by glowing digital threads that connect to the screens, visualizing real-time data flow. A small UI element in the corner shows the Simple Site Monitor logo. The scene is set in a modern, minimalist clinic with soft, ambient lighting. The image should be in a flat design style with clear iconography and a calming color palette."
    },
    {
        "id": 977113202,
        "name": "oci2git",
        "description": "Introspecting Docker images as easy as using Git",
        "url": "https://github.com/Virviil/oci2git",
        "language": "Rust",
        "stars": 303,
        "forks": 8,
        "created_at": "2025-05-03T13:03:21Z",
        "updated_at": "2025-05-21T09:26:48Z",
        "topics": [],
        "quality_score": 0.8499999999999999,
        "contributors_count": 0,
        "last_commit_date": "2025-05-07T21:43:16Z",
        "media_urls": [
            "https://opengraph.githubassets.com/097c941a5b9aeda9fe7260c2b547e2e7b609c441d85213e95d06248f0feff8fb/Virviil/oci2git"
        ],
        "homepage": "",
        "readme_summary": "OCI2Git converts container images into Git repositories, representing each layer as a commit. This enables users to leverage Git's powerful features like diffing, blame, and log to analyze and track changes within container images. The primary use case is layer diffing, allowing engineers to easily identify changes between layers for troubleshooting and understanding image evolution.",
        "key_features": [
            "Analyze Docker images and extract layer information",
            "Create a Git repository where each image layer is represented as a commit",
            "Support for empty layers as empty commits",
            "Complete metadata extraction to Markdown format",
            "Extensible architecture for supporting different container engines"
        ],
        "primary_use_case": "Layer Diffing",
        "open_issues": 0,
        "cover_image_prompt": "A skilled archivist meticulously transforming a towering stack of shipping containers into neatly organized books on library shelves. The archivist uses a special tool that extracts the essence of each container, converting it into a readable volume. Subtle UI elements on the archivist's workbench display container layer information and Git commit details. The scene is set in a bright, airy library with sunlight streaming through large windows. The image should be in a 3D isometric illustration style with clean lines and vibrant colors."
    },
    {
        "id": 227265548,
        "name": "gluesql",
        "description": "GlueSQL is quite sticky. It attaches to anywhere.",
        "url": "https://github.com/gluesql/gluesql",
        "language": "Rust",
        "stars": 2821,
        "forks": 224,
        "created_at": "2019-12-11T03:09:07Z",
        "updated_at": "2025-05-21T09:25:30Z",
        "topics": [
            "database",
            "nosql",
            "rust",
            "schemaless",
            "sql",
            "storage",
            "webassembly",
            "websql"
        ],
        "quality_score": 0.7,
        "contributors_count": 0,
        "last_commit_date": "2025-03-19T01:29:28Z",
        "media_urls": [
            "https://opengraph.githubassets.com/1b276eb0c2fc3ff92bc0003e8e7d8c549ac7cc1527df7218cf719a90a796a833/gluesql/gluesql"
        ],
        "homepage": "https://gluesql.org/docs",
        "readme_summary": "GlueSQL is a Rust library that provides a multi-model database engine. It supports both SQL and an AST Builder, allowing developers to interact with the database using either method. GlueSQL is designed to be flexible, supporting structured and unstructured data, custom storage systems, and integration with both Rust and JavaScript environments.",
        "key_features": [
            "Multi-Model Database Engine as a Library",
            "Supports SQL and AST Builder",
            "Supports Structured and Unstructured Data with Schema Flexibility",
            "Extensible with custom planners",
            "Portable and can be used with various storage types",
            "Can be used in Rust and JavaScript environments"
        ],
        "primary_use_case": "Providing a versatile SQL database library for developers, supporting both SQL and AST Builder, and handling structured and unstructured data with various storage options.",
        "open_issues": 132,
        "cover_image_prompt": "Imagine a skilled artisan carefully assembling a complex clock from various components: gears representing SQL parsers, springs symbolizing execution layers, and different types of containers as storage options (boxes, chests, digital clouds). The artisan is meticulously fitting these pieces together, creating a unified, versatile database engine. Subtle UI elements float around the artisan, displaying SQL queries and data structures. The scene is bathed in warm, inviting light, suggesting ease of use and flexibility. The image should be in a detailed 3D isometric illustration style with vibrant colors and clear labels."
    },
    {
        "id": 515368123,
        "name": "burn",
        "description": "Burn is a next generation Deep Learning Framework that doesn't compromise on flexibility, efficiency and portability.",
        "url": "https://github.com/tracel-ai/burn",
        "language": "Rust",
        "stars": 11155,
        "forks": 574,
        "created_at": "2022-07-18T23:11:45Z",
        "updated_at": "2025-05-21T08:49:53Z",
        "topics": [
            "autodiff",
            "cross-platform",
            "cuda",
            "deep-learning",
            "kernel-fusion",
            "machine-learning",
            "metal",
            "ndarray",
            "neural-network",
            "onnx",
            "pytorch",
            "rocm",
            "rust",
            "scientific-computing",
            "tensor",
            "vulkan",
            "wasm",
            "webgpu"
        ],
        "quality_score": 1.0000000000000002,
        "contributors_count": 0,
        "last_commit_date": "2025-05-20T20:11:59Z",
        "media_urls": [
            "https://opengraph.githubassets.com/f6f45c03fc1be811ac6334603e34b4dce57de6e986622e986b6d87a41e4a668b/tracel-ai/burn"
        ],
        "homepage": "https://burn.dev",
        "readme_summary": "Burn is a deep learning framework written in Rust that prioritizes flexibility, efficiency, and portability. It achieves high performance through features like automatic kernel fusion and asynchronous execution. The framework's thread-safe design and cross-platform support enable multi-device training and deployment on various backends, including CUDA, Metal, and WebGPU.",
        "key_features": [
            "Automatic kernel fusion",
            "Asynchronous execution",
            "Thread-safe building blocks",
            "Cross-platform support (CUDA, Metal, ROCm, Vulkan, WebGPU)",
            "Flexibility, efficiency, and portability"
        ],
        "primary_use_case": "Developing and deploying deep learning models with a focus on performance and cross-platform compatibility.",
        "open_issues": 225,
        "cover_image_prompt": "Imagine a skilled artisan meticulously crafting intricate clockwork gears within a brightly lit workshop. Each gear represents a neural network layer, and the artisan carefully fuses them together using a glowing forge, symbolizing automatic kernel fusion. Asynchronous streams of light represent data flowing through the gears, powering a miniature, self-aware robot on a workbench. The robot is learning and adapting in real-time, showcasing the framework's efficiency and thread-safe design. Subtle UI elements display Rust code snippets and performance metrics. The scene is rendered in a detailed 3D isometric illustration style with a warm, inviting color scheme."
    },
    {
        "id": 316912509,
        "name": "ggwave",
        "description": "Tiny data-over-sound library",
        "url": "https://github.com/ggerganov/ggwave",
        "language": "C++",
        "stars": 6678,
        "forks": 376,
        "created_at": "2020-11-29T09:02:43Z",
        "updated_at": "2025-05-21T04:24:41Z",
        "topics": [
            "arduino",
            "data-over-sound",
            "ecc",
            "fsk",
            "internet-of-things",
            "modem",
            "pairing",
            "python",
            "qrcode",
            "serverless",
            "sound-library",
            "ultrasound"
        ],
        "quality_score": 0.7999999999999999,
        "contributors_count": 0,
        "last_commit_date": "2025-03-20T17:27:58Z",
        "media_urls": [
            "https://repository-images.githubusercontent.com/316912509/6dc87c80-52a1-11eb-97ea-3dbba2a5fccb"
        ],
        "homepage": "https://youtu.be/Zcgf77T71QM",
        "readme_summary": "ggwave is a tiny data-over-sound library that enables communication between devices using audio signals. It utilizes FSK modulation and error correction to transmit data, making it suitable for serverless broadcasting and IoT applications. The library is platform-agnostic, allowing integration with various audio backends.",
        "key_features": [
            "Data-over-sound communication",
            "FSK-based transmission protocol",
            "Error correction codes (ECC)",
            "Platform agnostic audio backend",
            "Serverless one-to-many broadcast"
        ],
        "primary_use_case": "Communicating small amounts of data between air-gapped devices using sound.",
        "open_issues": 53,
        "cover_image_prompt": "Imagine a village crier standing in a town square, ringing a bell. Instead of shouting words, the bell emits audible data signals, like musical notes. Villagers with various devices (smartphones, laptops, IoT devices) receive the data-over-sound broadcast. Some devices display received text messages, others trigger actions. The town square is subtly overlaid with a faint digital grid. The scene is brightly lit, cheerful, and conveys a sense of simple, accessible communication. The illustration is in a clean, flat design style with clear iconography and a limited color palette."
    },
    {
        "id": 730033775,
        "name": "star-vector",
        "description": "StarVector is a foundation model for SVG generation that transforms vectorization into a code generation task. Using a vision-language modeling architecture, StarVector processes both visual and textual inputs to produce high-quality SVG code with remarkable precision.",
        "url": "https://github.com/joanrod/star-vector",
        "language": "Python",
        "stars": 3816,
        "forks": 198,
        "created_at": "2023-12-11T03:53:55Z",
        "updated_at": "2025-05-21T08:19:15Z",
        "topics": [
            "llm",
            "multimodal-large-language-models",
            "svg",
            "vlm"
        ],
        "quality_score": 0.7500000000000001,
        "contributors_count": 0,
        "last_commit_date": "2025-04-15T15:45:13Z",
        "media_urls": [
            "https://opengraph.githubassets.com/2fd698e04436528793f98c53f593704d6b18565705505df641da0c2844ae8afc/joanrod/star-vector"
        ],
        "homepage": "https://starvector.github.io",
        "readme_summary": "StarVector is a multimodal vision-language model designed for generating SVG code. It transforms vectorization into a code generation task, enabling both image-to-SVG and text-to-SVG generation. The model leverages a vision-language modeling architecture to process visual and textual inputs, producing high-quality SVG code.",
        "key_features": [
            "Image to SVG generation",
            "Text to SVG generation",
            "Multimodal vision-language model for SVG code generation"
        ],
        "primary_use_case": "Generating Scalable Vector Graphics (SVG) code from images and text using a multimodal vision-language model.",
        "open_issues": 35,
        "cover_image_prompt": "An artist in a digital studio, sketching a complex vector image on a tablet. The image springs to life, transforming into a scalable vector graphic that floats above the tablet. The artist is inspired by both a photograph displayed on a nearby screen and a text description floating in the air. Subtle UI elements and code snippets are visible in the background, connecting the artistic process to software. The studio is brightly lit with a modern, clean aesthetic. The image should be in a 3D isometric illustration style with vibrant colors and crisp details."
    },
    {
        "id": 228145865,
        "name": "KitHack",
        "description": "Hacking tools pack & backdoors generator.",
        "url": "https://github.com/AdrMXR/KitHack",
        "language": "Python",
        "stars": 1812,
        "forks": 239,
        "created_at": "2019-12-15T07:28:16Z",
        "updated_at": "2025-05-21T05:47:27Z",
        "topics": [
            "android",
            "apktool",
            "backdoor",
            "bash",
            "information-gathering",
            "metasploit-framework",
            "msfvenom",
            "ngrok",
            "passwords-attacks",
            "payload-generator",
            "phishing",
            "python",
            "spoofing",
            "web-attacks",
            "wifi-attacks",
            "windows"
        ],
        "quality_score": 0.45,
        "contributors_count": 0,
        "last_commit_date": "2025-02-19T05:32:04Z",
        "media_urls": [
            "https://repository-images.githubusercontent.com/228145865/4ee48380-db65-11ea-9341-cb9f8b488ea2"
        ],
        "homepage": "https://adrmxr.github.io/KitHack/",
        "readme_summary": "KitHack is a framework designed to automate the process of downloading and installing various penetration testing tools. It also features a backdoor generator that leverages the Metasploit Framework for creating multi-platform payloads. The tool supports infecting legitimate Android applications and utilizes Ngrok for establishing TCP connections.",
        "key_features": [
            "Automated installation of penetration testing tools",
            "Multi-platform backdoor generation using Metasploit Framework",
            "Android application infection",
            "Ngrok integration for TCP connections"
        ],
        "primary_use_case": "Automating the setup of penetration testing tools and generating multi-platform backdoors.",
        "open_issues": 18,
        "cover_image_prompt": "A blacksmith in a high-tech forge, crafting various tools (swords, lockpicks, digital probes) from raw materials (metal, data streams). The blacksmith uses a central console displaying code snippets and security protocols to guide the crafting process. Finished tools are displayed on a rack, each glowing with a specific aura representing its function (penetration testing, password cracking, web attack). The forge is powered by a network of servers and glowing cables. The repository name, 'KitHack,' is subtly engraved on the anvil. The image should be in a detailed digital painting style with vibrant colors and dramatic lighting."
    },
    {
        "id": 375081980,
        "name": "osint_stuff_tool_collection",
        "description": "A collection of several hundred online tools for OSINT",
        "url": "https://github.com/cipher387/osint_stuff_tool_collection",
        "language": "HTML",
        "stars": 6342,
        "forks": 737,
        "created_at": "2021-06-08T16:50:33Z",
        "updated_at": "2025-05-21T09:03:12Z",
        "topics": [
            "awesome",
            "awesome-list",
            "cybersecurity",
            "geoint",
            "hacking",
            "humint",
            "osint",
            "socmint",
            "tools",
            "toolset"
        ],
        "quality_score": 0.6,
        "contributors_count": 0,
        "last_commit_date": "2025-04-06T19:33:45Z",
        "media_urls": [
            "https://opengraph.githubassets.com/71e65828b01153fe329596ea22be8cbfeb074e652390deb954cc1b469a2028d2/cipher387/osint_stuff_tool_collection"
        ],
        "homepage": "https://cybdetective.com",
        "readme_summary": "This repository is a curated collection of hundreds of online tools designed to assist in Open Source Intelligence (OSINT) investigations. It categorizes tools across various domains like social media, geolocation, domain analysis, and more. While some tools may be outdated, the repository serves as a valuable resource for discovering and exploring potential OSINT resources.",
        "key_features": [
            "Maps, Geolocation and Transport tools",
            "Social Media OSINT tools",
            "Domain/IP/Links analysis tools",
            "Image Search and Identification tools",
            "Cryptocurrency investigation tools",
            "Messaging platform analysis tools",
            "Code analysis tools",
            "Search engine tools",
            "IOT device tools",
            "Archive search tools",
            "Password recovery/analysis tools",
            "Email investigation tools",
            "Nickname research tools"
        ],
        "primary_use_case": "Collection of online tools for Open Source Intelligence (OSINT) investigations.",
        "open_issues": 14,
        "cover_image_prompt": "A detective, surrounded by a vast web of interconnected screens displaying various online tools and data streams, meticulously pieces together information to solve a complex case. The detective uses a magnifying glass to examine a digital map, with social media feeds, website screenshots, and geolocation data subtly overlaid. Glowing lines connect the different data points, forming a network of intelligence. The repository name is subtly displayed on one of the screens. The scene is set in a dimly lit, high-tech office with a sense of mystery and focus. The image should be in a digital painting style with clear outlines and a cool color scheme."
    }
]