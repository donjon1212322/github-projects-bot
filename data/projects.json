[
    {
        "id": 993475711,
        "name": "pwmenu",
        "description": "Launcher-driven audio manager for Linux",
        "url": "https://github.com/e-tho/pwmenu",
        "language": "Rust",
        "stars": 31,
        "forks": 0,
        "created_at": "2025-05-30T21:25:23Z",
        "updated_at": "2025-09-24T08:41:00Z",
        "topics": [],
        "quality_score": 0.5499999999999999,
        "contributors_count": 0,
        "last_commit_date": "2025-09-22T22:37:46Z",
        "media_urls": [
            "https://opengraph.githubassets.com/56e6a6b5289a7af1b7a19ccdd3cfec3671a8abf5d0fb8d0b8991de5d87e9421c/e-tho/pwmenu"
        ],
        "homepage": null,
        "readme_summary": "pwmenu is a launcher-driven audio manager for Linux that allows users to control audio settings through their preferred launcher. It supports various launchers and offers compatibility with font and XDG icons for visual representation of audio controls.",
        "key_features": [
            "Launcher-driven audio management",
            "PipeWire integration",
            "Support for multiple launchers (Fuzzel, Rofi, Walker, dmenu, custom)",
            "Font and XDG icon support",
            "System notifications"
        ],
        "primary_use_case": "Managing audio settings on Linux systems using a launcher interface.",
        "open_issues": 0,
        "cover_image_prompt": "A conductor orchestrating a symphony of sound levels using a launcher interface as their baton. The conductor stands before a mixing console where each fader is controlled by a launcher menu item. Sound waves emanate from the console, visualizing the audio output. Small UI elements displaying PipeWire connections and audio levels subtly connect the metaphor to software. The scene is set in a modern recording studio with warm, focused lighting. The composition is centered with a clear focus on the conductor and console. The image should be in 3D isometric illustration style with rich details and vibrant colors."
    },
    {
        "id": 1004995740,
        "name": "opcode",
        "description": "A powerful GUI app and Toolkit for Claude Code - Create custom agents, manage interactive Claude Code sessions, run secure background agents, and more.",
        "url": "https://github.com/winfunc/opcode",
        "language": "TypeScript",
        "stars": 17428,
        "forks": 1290,
        "created_at": "2025-06-19T13:53:26Z",
        "updated_at": "2025-09-24T10:04:54Z",
        "topics": [
            "anthropic",
            "anthropic-claude",
            "claude",
            "claude-4",
            "claude-4-opus",
            "claude-4-sonnet",
            "claude-ai",
            "claude-code",
            "claude-code-sdk",
            "cursor",
            "ide",
            "llm",
            "llm-code",
            "rust",
            "tauri"
        ],
        "quality_score": 1.0000000000000002,
        "contributors_count": 0,
        "last_commit_date": "2025-09-07T12:12:00Z",
        "media_urls": [
            "https://opengraph.githubassets.com/fb62cd4ae82f7c2efcb9c0d9fba70cb02a17f69e4f46fcba71774f022d2a5e1c/winfunc/opcode"
        ],
        "homepage": "https://opcode.sh",
        "readme_summary": "Opcode is a desktop application built with Tauri 2 that provides a GUI for managing Claude Code sessions and creating custom agents. It aims to bridge the gap between command-line tools and a visual experience for AI-assisted development, offering features like usage tracking, project management, and background agent execution.",
        "key_features": [
            "Project & Session Management",
            "Custom AI Agents",
            "Usage Analytics Dashboard",
            "MCP Server Management",
            "Timeline & Checkpoints",
            "CLAUDE.md Management"
        ],
        "primary_use_case": "Managing Claude Code sessions and creating custom AI agents through a graphical user interface.",
        "open_issues": 220,
        "cover_image_prompt": "A conductor orchestrating a symphony of code, with Claude (represented by a stylized AI avatar) as the lead instrument. The conductor uses a tablet displaying Opcode's interface to manage different code sections, visualized as musical notes flowing onto a grand stage. The stage is subtly embedded with UI elements and data visualizations. The scene is set in a modern, minimalist concert hall with soft, focused lighting. Small digital particles enhance the feeling of dynamic code execution. The composition is balanced and elegant with a harmonious color scheme. The image should be in a 3D isometric illustration style with rich details and vibrant colors."
    },
    {
        "id": 292014229,
        "name": "zellij",
        "description": "A terminal workspace with batteries included",
        "url": "https://github.com/zellij-org/zellij",
        "language": "Rust",
        "stars": 26485,
        "forks": 815,
        "created_at": "2020-09-01T14:04:28Z",
        "updated_at": "2025-09-24T09:56:37Z",
        "topics": [
            "multiplexer",
            "terminal",
            "workspace"
        ],
        "quality_score": 0.85,
        "contributors_count": 0,
        "last_commit_date": "2025-08-28T15:48:34Z",
        "media_urls": [
            "https://repository-images.githubusercontent.com/292014229/b8e9df2e-3a36-4642-9e54-2edffb3a59ef"
        ],
        "homepage": "https://zellij.dev",
        "readme_summary": "Zellij is a terminal workspace and multiplexer written in Rust, designed for developers and ops-oriented users. It aims to provide a great out-of-the-box experience with advanced features like customizable layouts, multiplayer collaboration, floating/stacked panes, and a plugin system supporting WebAssembly.",
        "key_features": [
            "Workspace management",
            "Terminal multiplexing",
            "Customizable layouts",
            "Multiplayer collaboration",
            "Floating and stacked panes",
            "Plugin system (WebAssembly)",
            "Built-in web client"
        ],
        "primary_use_case": "Improving terminal workflow and productivity for developers and ops personnel.",
        "open_issues": 1201,
        "cover_image_prompt": "Imagine a skilled artisan in a workshop, meticulously crafting intricate stained-glass windows, each pane representing a different terminal session. The artisan seamlessly arranges and resizes these panes within a larger frame, symbolizing the workspace. Some panes float ethereally, while others stack neatly. Digital code streams subtly through the glass, and the repository name is etched elegantly into the frame. The workshop is bathed in warm, inviting light, creating a sense of focused productivity. The illustration should be in a 3D isometric style with vibrant colors and sharp details, emphasizing the organized and customizable nature of the terminal workspace."
    },
    {
        "id": 967512112,
        "name": "qtap",
        "description": "Qtap: An eBPF agent that captures pre-encrypted network traffic, providing rich context about egress connections and their originating processes.",
        "url": "https://github.com/qpoint-io/qtap",
        "language": "C",
        "stars": 1328,
        "forks": 40,
        "created_at": "2025-04-16T15:08:49Z",
        "updated_at": "2025-09-24T09:15:36Z",
        "topics": [
            "containers",
            "developer-tools",
            "ebpf",
            "go",
            "golang",
            "kubernetes",
            "libbpf",
            "linux",
            "observability",
            "security"
        ],
        "quality_score": 1.0000000000000002,
        "contributors_count": 0,
        "last_commit_date": "2025-09-17T17:34:59Z",
        "media_urls": [
            "https://repository-images.githubusercontent.com/967512112/f8898d6a-10a1-494e-a05b-3f465d0d72e7"
        ],
        "homepage": "https://qpoint.io/qtap",
        "readme_summary": "Qtap is an eBPF agent designed to capture pre-encrypted network traffic on Linux systems. It provides visibility into egress connections and their originating processes by intercepting data before and after encryption, offering rich context without requiring application modifications or proxies.",
        "key_features": [
            "Captures pre-encrypted network traffic",
            "Provides context about egress connections",
            "Identifies originating processes",
            "Operates out-of-band with minimal overhead",
            "Supports security auditing",
            "Helps debug network issues",
            "Aids in API development"
        ],
        "primary_use_case": "Understanding and auditing egress network traffic for security, debugging, and API development purposes.",
        "open_issues": 1,
        "cover_image_prompt": "A skilled surgeon, wearing a high-tech visor displaying network traffic data, carefully dissects a fiber optic cable to reveal the raw, unencrypted data flowing within. The surgeon's tools glow with digital energy, extracting packets of information. Around the operating table, holographic displays show the originating processes and destinations of the data streams. The scene is set in a sterile, futuristic operating room with bright, focused lighting. Small UI elements display the Qtap logo and real-time data analysis. The composition is clean and focused, using a cool color scheme of blues and greens. The image should be in a 3D isometric illustration style with sharp details and a sense of precision."
    },
    {
        "id": 117710726,
        "name": "twirp",
        "description": "A simple RPC framework with protobuf service definitions",
        "url": "https://github.com/twitchtv/twirp",
        "language": "Go",
        "stars": 7437,
        "forks": 327,
        "created_at": "2018-01-16T16:37:30Z",
        "updated_at": "2025-09-24T03:33:49Z",
        "topics": [
            "go",
            "protobuf",
            "rpc",
            "twirp"
        ],
        "quality_score": 0.55,
        "contributors_count": 0,
        "last_commit_date": "2024-08-05T21:36:11Z",
        "media_urls": [
            "https://opengraph.githubassets.com/3400daccc2eae0e52f3e120a0788da373547181bd96a183a5610f7a854673fed/twitchtv/twirp"
        ],
        "homepage": "https://twitchtv.github.io/twirp/docs/intro.html",
        "readme_summary": "Twirp is a simple RPC framework that uses protobuf service definitions to generate routing and serialization, allowing developers to focus on application logic. It runs on the standard `net/http` server, supports HTTP 1.1 and JSON serialization, and provides autogenerated clients and error handling.",
        "key_features": [
            "RPC framework",
            "Protobuf service definitions",
            "Code generation (routing, serialization, clients)",
            "HTTP 1.1 support",
            "JSON serialization",
            "Error handling"
        ],
        "primary_use_case": "Service-to-service communication",
        "open_issues": 9,
        "cover_image_prompt": "A skilled postal worker sorts letters into labeled boxes, each representing a different service. The letters are protobuf messages, and the boxes glow with a soft light, indicating successful routing. A blueprint on the wall shows the service definitions. The worker uses a magnifying glass to inspect each letter, ensuring correct delivery. Small screens display code snippets and service logs. The scene is set in a clean, organized post office with warm, inviting lighting. The composition is balanced and focused. The image should be in a 3D isometric illustration style with clear iconography and vibrant colors."
    },
    {
        "id": 987670088,
        "name": "crush",
        "description": "The glamourous AI coding agent for your favourite terminal 💘",
        "url": "https://github.com/charmbracelet/crush",
        "language": "Go",
        "stars": 13070,
        "forks": 662,
        "created_at": "2025-05-21T12:14:57Z",
        "updated_at": "2025-09-24T09:07:03Z",
        "topics": [],
        "quality_score": 0.85,
        "contributors_count": 0,
        "last_commit_date": "2025-09-24T06:54:37Z",
        "media_urls": [
            "https://repository-images.githubusercontent.com/987670088/9247ccb4-650d-4811-ba21-a1b5b47b4e70"
        ],
        "homepage": "",
        "readme_summary": "Crush is an AI coding agent designed to be used within a terminal environment. It allows users to integrate Large Language Models (LLMs) into their existing coding workflows, offering features like multi-model support, session-based context management, and LSP-enhanced code understanding.",
        "key_features": [
            "Multi-Model support",
            "Flexible LLM switching",
            "Session-Based context management",
            "LSP-Enhanced code understanding",
            "Extensible capabilities via MCPs",
            "Cross-platform compatibility"
        ],
        "primary_use_case": "AI-assisted coding within a terminal environment.",
        "open_issues": 195,
        "cover_image_prompt": "A skilled architect stands before a digital blueprint, consulting with a glowing AI assistant that hovers nearby. The architect gestures at the blueprint, while the AI assistant suggests code snippets and solutions that materialize as shimmering overlays on the plan. The scene takes place in a modern, minimalist office with soft, ambient lighting. Small UI elements displaying code and terminal outputs are subtly integrated into the blueprint. The composition is clean and focused, with a blue and white color scheme. The image should be in a 3D isometric illustration style with rich details and vibrant colors."
    }
]