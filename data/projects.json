[
    {
        "id": 952822080,
        "name": "vibe-draw",
        "description": "üé® Turn your roughest sketches into stunning 3D worlds by vibe drawing",
        "url": "https://github.com/martin226/vibe-draw",
        "language": "TypeScript",
        "stars": 1025,
        "forks": 169,
        "created_at": "2025-03-22T00:20:20Z",
        "updated_at": "2025-03-28T10:09:21Z",
        "topics": [],
        "quality_score": 0.75,
        "contributors_count": 0,
        "last_commit_date": "2025-03-25T08:48:39Z",
        "media_urls": [
            "https://opengraph.githubassets.com/3667d4f127302f776289b861602de188eca364793ce29192c1b1ae649925d43e/martin226/vibe-draw"
        ],
        "homepage": "",
        "readme_summary": "Vibe Draw allows users to create 3D models and worlds by sketching on a 2D canvas. It uses AI to enhance drawings and convert them into 3D models, which can then be added to a 3D world. The tool supports real-time updates and glTF export for integration with existing 3D workflows.",
        "key_features": [
            "2D sketching to 3D model conversion",
            "AI-powered drawing enhancement",
            "3D world building",
            "Real-time updates",
            "glTF export"
        ],
        "primary_use_case": "Creating 3D models and worlds from 2D sketches.",
        "open_issues": 3,
        "cover_image_prompt": "An artist stands before a blank 3D canvas, sketching freely with a magical stylus. The sketches instantly transform into detailed 3D models that float around the artist. A small UI element displays the 'Improve Drawing' and 'Make 3D' buttons. The scene is set in a bright, modern studio filled with floating geometric shapes. Digital particles emanate from the stylus, enhancing the sketches. The repository name, 'Vibe Draw,' is subtly displayed on a tablet. The composition is clean and focused with a vibrant color scheme. The image should be in 3D isometric illustration style with rich details and vibrant colors."
    },
    {
        "id": 79317191,
        "name": "typesense",
        "description": "Open Source alternative to Algolia + Pinecone and an Easier-to-Use alternative to ElasticSearch ‚ö° üîç ‚ú® Fast, typo tolerant, in-memory fuzzy Search Engine for building delightful search experiences",
        "url": "https://github.com/typesense/typesense",
        "language": "C++",
        "stars": 22540,
        "forks": 704,
        "created_at": "2017-01-18T08:01:47Z",
        "updated_at": "2025-03-28T10:10:52Z",
        "topics": [
            "algolia",
            "datastore",
            "elasticsearch",
            "enterprise-search",
            "faceting",
            "full-text-search",
            "fuzzy-search",
            "geosearch",
            "in-memory",
            "instantsearch",
            "merchandising",
            "pinecone",
            "search",
            "search-engine",
            "semantic-search",
            "similarity-search",
            "site-search",
            "synonyms",
            "typo-tolerance",
            "vector-search"
        ],
        "quality_score": 1.1,
        "contributors_count": 0,
        "last_commit_date": "2025-03-27T15:59:50Z",
        "media_urls": [
            "https://opengraph.githubassets.com/d200bf2c55784bc96e5c22e9cf009c377ab31fe05bad91b869f6a27beaf6f2e1/typesense/typesense"
        ],
        "homepage": "https://typesense.org",
        "readme_summary": "Typesense is a fast, typo-tolerant search engine designed as an open-source alternative to Algolia and a more user-friendly alternative to Elasticsearch. It's built in C++ and architected for low-latency instant searches. Key features include typo tolerance, simple setup and operation, blazing fast speed, tunable ranking, and sorting capabilities.",
        "key_features": [
            "Typo Tolerance",
            "Simple and Delightful",
            "Blazing Fast",
            "Tunable Ranking",
            "Sorting"
        ],
        "primary_use_case": "Building delightful search experiences with typo-tolerance and speed.",
        "open_issues": 638,
        "cover_image_prompt": "A skilled cartographer meticulously crafting a detailed map of a vast digital landscape. The cartographer uses a magical lens to correct typos and inaccuracies in the terrain, ensuring a smooth and accurate journey for travelers. The landscape is filled with glowing data streams representing information being searched. Small UI elements float in the air, displaying search queries and results. The scene is set in a bright, airy workshop filled with maps and charts. The image should be in a 3D isometric illustration style with vibrant colors and crisp details."
    },
    {
        "id": 339533345,
        "name": "assembly-tutorial",
        "description": "Programming in assembly language tutorial",
        "url": "https://github.com/mschwartz/assembly-tutorial",
        "language": "Assembly",
        "stars": 1038,
        "forks": 73,
        "created_at": "2021-02-16T21:15:13Z",
        "updated_at": "2025-03-28T09:55:10Z",
        "topics": [],
        "quality_score": 0.45,
        "contributors_count": 0,
        "last_commit_date": "2024-09-10T19:04:26Z",
        "media_urls": [
            "https://opengraph.githubassets.com/9f8f51c8fe3e29da3bfb6bd72e73bdb8766bda828848eb6fd51e5685f70e5c1f/mschwartz/assembly-tutorial"
        ],
        "homepage": null,
        "readme_summary": "This repository provides a comprehensive tutorial for learning assembly language programming on AMD64/Intel 64-bit architectures. It covers fundamental concepts like registers, instruction sets, memory management, and assembler directives. The tutorial is aimed at novices and beginners, providing practical examples and explanations to help them understand low-level programming.",
        "key_features": [
            "AMD64/Intel 64 bit programming tutorial",
            "Covers instruction sets, registers, stacks",
            "Explains bits, bytes, words, number bases, math, boolean algebra, bit shifting",
            "Details memory management, ELF files, MMU, exceptions",
            "Explores x64/AMD64 registers (general purpose, special purpose, CPU control)",
            "Describes AMD64 instruction set and addressing modes",
            "Covers commonly used instructions (arithmetic, boolean, branching, bit manipulation, register manipulation, flags manipulation, stack manipulation)",
            "Explains assembler source, directives, and macros",
            "Provides Hello, World examples for MacOS and Linux"
        ],
        "primary_use_case": "Learning assembly language programming, specifically for AMD64/Intel 64-bit architectures.",
        "open_issues": 3,
        "cover_image_prompt": "An archaeologist carefully brushing away dirt from ancient stone tablets inscribed with assembly code. The tablets glow faintly with digital light, revealing the underlying structure of computer architecture. Around the archaeologist, holographic projections display simplified diagrams of registers, memory addresses, and instruction sets. The scene is set in a dimly lit, futuristic excavation site with advanced scanning equipment. Small UI elements show disassembled code and CPU schematics. The image should be in a detailed digital painting style with a focus on clarity and historical accuracy."
    },
    {
        "id": 60436054,
        "name": "cute_headers",
        "description": "Collection of cross-platform one-file C/C++ libraries with no dependencies, primarily used for games",
        "url": "https://github.com/RandyGaul/cute_headers",
        "language": "C",
        "stars": 4575,
        "forks": 276,
        "created_at": "2016-06-05T00:19:59Z",
        "updated_at": "2025-03-28T08:06:09Z",
        "topics": [
            "audio",
            "c",
            "collision",
            "collision-detection",
            "compression",
            "cross-platform",
            "game",
            "header",
            "library",
            "math",
            "opengl",
            "png"
        ],
        "quality_score": 0.7000000000000001,
        "contributors_count": 0,
        "last_commit_date": "2025-02-09T02:18:20Z",
        "media_urls": [
            "https://opengraph.githubassets.com/6068f7f92a45ddb2b9abc37b09e85bc1c3309bd9f6108f2610f6d94a078797fc/RandyGaul/cute_headers"
        ],
        "homepage": "",
        "readme_summary": "The cute_headers repository offers a collection of single-file, cross-platform C/C++ header libraries designed for easy integration into projects without external dependencies. These libraries cover a range of functionalities, including collision detection, networking, audio processing, image handling, and more, making them particularly useful for game development.",
        "key_features": [
            "Single-file header libraries",
            "Cross-platform compatibility",
            "No dependencies",
            "2D collision detection",
            "Networking library with security",
            "Tiled map loader",
            "Aseprite file parser",
            "Audio loading and playback",
            "3D vector math",
            "PNG loading and saving",
            "Sprite batching",
            "Synchronization primitives",
            "TLS connection creation"
        ],
        "primary_use_case": "Providing self-contained, easy-to-integrate libraries for game development and other applications.",
        "open_issues": 15,
        "cover_image_prompt": "A skilled architect meticulously assembling miniature building blocks, each representing a different software component (audio, collision, networking, etc.), onto a versatile, cross-platform foundation. The architect carefully selects and connects these blocks, creating a robust and functional structure. Subtle UI elements float around the scene, displaying code snippets and library names. The scene is bathed in soft, diffused lighting, emphasizing the ease of integration. The composition is clean and focused, with a pastel color scheme. The image should be in a 3D isometric illustration style with smooth textures and vibrant colors."
    },
    {
        "id": 264764016,
        "name": "axiom",
        "description": "The dynamic infrastructure framework for everybody! Distribute the workload of many different scanning tools with ease, including nmap, ffuf, masscan, nuclei, meg and many more!",
        "url": "https://github.com/pry0cc/axiom",
        "language": "Shell",
        "stars": 4169,
        "forks": 672,
        "created_at": "2020-05-17T21:55:02Z",
        "updated_at": "2025-03-28T01:59:45Z",
        "topics": [
            "axiom",
            "bug-bounty",
            "dnsgen",
            "dnsx",
            "ffuf",
            "gau",
            "gowitness",
            "hacking-vps",
            "httprobe",
            "httpx",
            "masscan",
            "massdns",
            "meg",
            "nmap",
            "nuclei",
            "shuffledns",
            "subfinder",
            "tmux"
        ],
        "quality_score": 0.7,
        "contributors_count": 0,
        "last_commit_date": "2024-09-30T17:18:52Z",
        "media_urls": [
            "https://opengraph.githubassets.com/9222283b214007c2d6ae81d0fd4fda349bc0df85a28f3466001da67d1948c33a/pry0cc/axiom"
        ],
        "homepage": "",
        "readme_summary": "Axiom is a dynamic infrastructure framework designed to simplify the deployment and management of security scanning tools across multiple cloud environments. It enables users to easily distribute scans using tools like Nmap, ffuf, and Nuclei across numerous instances, accelerating vulnerability assessments and penetration testing. Axiom supports various cloud providers, including DigitalOcean, IBM Cloud, Linode, Azure, and AWS.",
        "key_features": [
            "Dynamic infrastructure framework",
            "Multi-cloud environment support (DigitalOcean, IBM Cloud, Linode, Azure, AWS)",
            "Distributed scanning with tools like nmap, ffuf, masscan, nuclei, meg",
            "Immutable infrastructure for repeatable deployments",
            "Easy instance creation and management"
        ],
        "primary_use_case": "Distributing and managing offensive and defensive security scans across multiple cloud instances.",
        "open_issues": 70,
        "cover_image_prompt": "A master conductor orchestrating a symphony of scanning tools in a bustling, futuristic control room. The conductor, with a tablet displaying the 'axiom' logo, directs various robotic arms representing tools like Nmap, ffuf, and Nuclei, each scanning different targets represented by glowing servers. Successfully scanned servers emit a green light, while potential vulnerabilities trigger a red alert. Small UI elements display real-time scan data and progress. The scene is set in a clean, modern control center with bright, focused lighting. The image should be in 3D isometric illustration style with vibrant colors and clear details."
    },
    {
        "id": 920866025,
        "name": "WinVisor",
        "description": "WinVisor - A hypervisor-based emulator for Windows x64 user-mode executables using Windows Hypervisor Platform API",
        "url": "https://github.com/x86matthew/WinVisor",
        "language": "C++",
        "stars": 550,
        "forks": 37,
        "created_at": "2025-01-22T22:47:35Z",
        "updated_at": "2025-03-28T08:37:12Z",
        "topics": [],
        "quality_score": 0.44999999999999996,
        "contributors_count": 0,
        "last_commit_date": "2025-01-23T19:42:41Z",
        "media_urls": [
            "https://opengraph.githubassets.com/bfc0ed8ff1af236aaea4b2e1acdcabec53ce6700be193d60ceb5a77fe64363e2/x86matthew/WinVisor"
        ],
        "homepage": "",
        "readme_summary": "WinVisor is a hypervisor-based emulator for Windows x64 user-mode executables, leveraging the Windows Hypervisor Platform API. It creates a virtual environment by cloning the address space of a suspended process, allowing for the execution and monitoring of applications in a virtualized setting. The emulator forwards syscalls to the host OS and provides a framework for implementing custom syscall hooks.",
        "key_features": [
            "Hypervisor-based emulation of Windows x64 user-mode executables",
            "Uses Windows Hypervisor Platform (WHP) API",
            "Clones address space of a suspended process into the virtual environment",
            "Forwards syscalls to the host OS",
            "Provides a framework for syscall hooks"
        ],
        "primary_use_case": "Emulating and virtualizing Windows x64 user-mode executables within a controlled environment.",
        "open_issues": 0,
        "cover_image_prompt": "Imagine a skilled clockmaker meticulously assembling a miniature clockwork computer inside a transparent hourglass. The top half of the hourglass contains scattered gears and components representing Windows executables and DLLs. As the 'sand' (executable components) falls, the clockmaker precisely places them within the clockwork computer in the bottom half, bringing it to life. Tiny screens on the clockmaker's workbench display snippets of x64 assembly code and memory addresses. The hourglass rests on a desk with a subtle 'WinVisor' logo etched into the wood. The scene is bathed in soft, diffused light, creating a sense of precision and controlled virtualization. The image should be in a detailed 3D isometric illustration style with vibrant colors and intricate details."
    },
    {
        "id": 95876775,
        "name": "project-guidelines",
        "description": "A set of best practices for JavaScript projects",
        "url": "https://github.com/elsewhencode/project-guidelines",
        "language": "JavaScript",
        "stars": 29550,
        "forks": 3214,
        "created_at": "2017-06-30T10:17:55Z",
        "updated_at": "2025-03-28T09:26:22Z",
        "topics": [
            "best-practices",
            "guidelines",
            "how-to",
            "javascript",
            "javascript-best-practices",
            "maintainability"
        ],
        "quality_score": 0.55,
        "contributors_count": 0,
        "last_commit_date": "2024-12-09T07:59:04Z",
        "media_urls": [
            "https://opengraph.githubassets.com/2feb420d48c397dd654a396765734edd715fb863a05201a8dee4b27fe77c9e87/elsewhencode/project-guidelines"
        ],
        "homepage": "",
        "readme_summary": "The project-guidelines repository offers a comprehensive collection of best practices for JavaScript projects, covering various aspects from Git workflow to API security. It aims to improve project maintainability, code quality, and overall development efficiency by providing actionable guidelines and recommendations.",
        "key_features": [
            "Git workflow guidelines",
            "Documentation standards",
            "Environment consistency",
            "Dependency management",
            "Testing practices",
            "Code style enforcement",
            "API design and security",
            "Accessibility considerations",
            "Licensing information"
        ],
        "primary_use_case": "Providing a set of best practices and guidelines for JavaScript project development and maintenance.",
        "open_issues": 9,
        "cover_image_prompt": "A seasoned cartographer meticulously drawing a detailed map of a vast, uncharted JavaScript project landscape. The cartographer uses a compass labeled 'Best Practices' and a ruler marked with 'Maintainability' to chart clear paths and identify potential pitfalls. The map is filled with icons representing different aspects of JavaScript development, such as testing, documentation, and code style. Small screens display code snippets and guideline summaries. The scene is set in a well-lit study with a warm, inviting atmosphere. The image should be in a detailed technical illustration style with labeled parts and a muted color palette."
    },
    {
        "id": 906422044,
        "name": "cudacodes",
        "description": "Learnings and programs related to CUDA",
        "url": "https://github.com/Maharshi-Pandya/cudacodes",
        "language": "Cuda",
        "stars": 369,
        "forks": 14,
        "created_at": "2024-12-20T21:53:44Z",
        "updated_at": "2025-03-28T06:59:29Z",
        "topics": [],
        "quality_score": 0.7000000000000001,
        "contributors_count": 0,
        "last_commit_date": "2025-02-20T07:16:38Z",
        "media_urls": [
            "https://opengraph.githubassets.com/bfd641646cbbf7dd03e22c27b3b666f63ceea30cc5e1499c1f74d8aba7fdfc5f/Maharshi-Pandya/cudacodes"
        ],
        "homepage": null,
        "readme_summary": "This repository provides a collection of CUDA code examples and optimizations, primarily focusing on C/C++. It serves as a learning resource for individuals looking to understand and improve their CUDA skills through practical implementations and extensively commented code. The repository covers various topics, including softmax, matrix multiplication, and device information retrieval.",
        "key_features": [
            "Practical CUDA code examples",
            "CUDA optimization techniques",
            "Well-commented code for learning",
            "Specific implementations like softmax, matrix multiplication, and matrix-vector multiplication"
        ],
        "primary_use_case": "Learning and experimenting with CUDA programming.",
        "open_issues": 0,
        "cover_image_prompt": "A skilled sculptor meticulously chiseling away at a rough block of marble, revealing a perfectly formed, gleaming GPU chip inside. The sculptor uses various tools, each representing different CUDA optimization techniques. Digital particles representing data flow around the chip, enhancing its performance. Small UI elements displaying CUDA code snippets float subtly in the background. The scene is set in a brightly lit, modern workshop. The composition is clean and focused, with the GPU chip as the central element. The image should be in 3D isometric illustration style with sharp details and vibrant colors."
    }
]