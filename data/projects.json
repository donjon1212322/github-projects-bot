[
    {
        "id": 963573800,
        "name": "ml-matrix3d",
        "description": "[CVPR 2025 Highlight] Matrix3D: Large Photogrammetry Model All-in-One",
        "url": "https://github.com/apple/ml-matrix3d",
        "language": "Python",
        "stars": 261,
        "forks": 4,
        "created_at": "2025-04-09T22:16:42Z",
        "updated_at": "2025-05-07T10:07:30Z",
        "topics": [],
        "quality_score": 0.25,
        "contributors_count": 0,
        "last_commit_date": "2025-04-10T08:11:34Z",
        "media_urls": [
            "https://opengraph.githubassets.com/d3e688fba82a1d776d76cb42b24493d6798d549aabc14f547d5e7c7362dc5336/apple/ml-matrix3d"
        ],
        "homepage": "https://nju-3dv.github.io/projects/matrix3d/",
        "readme_summary": "The Matrix3D repository provides a unified model for performing multiple photogrammetry subtasks, including pose estimation, depth prediction, and novel view synthesis. It includes the model inference pipeline and a modified 3DGS reconstruction pipeline. The model supports various photogrammetry tasks via masked inference.",
        "key_features": [
            "Pose estimation",
            "Depth prediction",
            "Novel view synthesis",
            "3D reconstruction pipeline",
            "Masked inference for various photogrammetry tasks"
        ],
        "primary_use_case": "Unified photogrammetry model for pose estimation, depth prediction, and novel view synthesis.",
        "open_issues": 1,
        "cover_image_prompt": "A skilled architect reviewing a 3D model blueprint on a holographic table, seamlessly integrating pose estimation, depth prediction, and novel view synthesis to perfect the design. The blueprint transforms dynamically as the architect adjusts parameters on a nearby tablet, showcasing different perspectives and depths. Subtle UI elements and code snippets float around the scene, connecting the architectural design to the underlying photogrammetry technology. The scene is set in a bright, modern studio with a focus on clean lines and intuitive design. The image should be in 3D isometric illustration style with vibrant colors and sharp details."
    },
    {
        "id": 878813491,
        "name": "yt-history",
        "description": "YouTube History Analyzer",
        "url": "https://github.com/ronething/yt-history",
        "language": "TypeScript",
        "stars": 14,
        "forks": 0,
        "created_at": "2024-10-26T07:12:46Z",
        "updated_at": "2025-05-07T09:42:12Z",
        "topics": [
            "data-visualization",
            "rechats",
            "youtube",
            "youtube-stats"
        ],
        "quality_score": 0.6499999999999999,
        "contributors_count": 0,
        "last_commit_date": "2025-05-04T04:43:50Z",
        "media_urls": [
            "https://opengraph.githubassets.com/0eeccaba790d7fd2deef21a8f4a4fd288b03c3089bd2e2abfbb168e03c629f4e/ronething/yt-history"
        ],
        "homepage": "https://youtubestats.forgetimer.com",
        "readme_summary": "The YouTube History Analyzer is a web application that allows users to import their YouTube history data from Google Takeout and visualize their watching patterns and trends. It provides features to filter and search through watch history, generate insights about most-watched channels and categories, and track time spent watching different types of content.",
        "key_features": [
            "Import YouTube history data from Google Takeout",
            "Visualize watching patterns and trends",
            "Filter and search through watch history",
            "Generate insights about most-watched channels and categories",
            "Track time spent watching different types of content"
        ],
        "primary_use_case": "Visualize and analyze YouTube watch history.",
        "open_issues": 0,
        "cover_image_prompt": "Imagine a cartographer meticulously charting a vast, unexplored island representing a user's YouTube watch history. The cartographer, equipped with a magnifying glass and quill, examines scrolls filled with timestamps and video titles. As they analyze the data, the island transforms, revealing hidden landscapes of most-watched channels, trending categories, and time spent in different regions. Small UI elements float above the island, displaying interactive filters and search bars. The scene is set in a sunlit study filled with antique maps and digital screens. The image should be in a detailed 3D isometric illustration style with vibrant colors and clear labels."
    },
    {
        "id": 91253698,
        "name": "ccxt",
        "description": "A JavaScript / TypeScript / Python / C# / PHP / Go cryptocurrency trading API with support for more than 100 bitcoin/altcoin exchanges",
        "url": "https://github.com/ccxt/ccxt",
        "language": "Python",
        "stars": 35937,
        "forks": 7858,
        "created_at": "2017-05-14T15:41:56Z",
        "updated_at": "2025-05-07T10:06:39Z",
        "topics": [
            "altcoin",
            "api",
            "arbitrage",
            "bitcoin",
            "bot",
            "btc",
            "crypto",
            "cryptocurrencies",
            "cryptocurrency",
            "eth",
            "ethereum",
            "exchange",
            "invest",
            "library",
            "market-data",
            "memecoin",
            "merchant",
            "strategy",
            "trade",
            "trading"
        ],
        "quality_score": 1.0000000000000002,
        "contributors_count": 0,
        "last_commit_date": "2025-05-07T09:49:08Z",
        "media_urls": [
            "https://repository-images.githubusercontent.com/91253698/ea8e3c00-171a-11ea-9a81-e79b426fe455"
        ],
        "homepage": "https://docs.ccxt.com",
        "readme_summary": "CCXT is a cryptocurrency trading library that provides a unified API for accessing various cryptocurrency exchanges. It supports multiple programming languages and offers features like normalized data for arbitrage and easy integration. It's intended for developers, traders, and analysts building trading algorithms and related software.",
        "key_features": [
            "Support for many cryptocurrency exchanges",
            "Fully implemented public and private APIs",
            "Optional normalized data for cross-exchange analytics and arbitrage",
            "Unified API for easy integration",
            "Works in Node.js, Python, PHP, C#, Go, and web browsers"
        ],
        "primary_use_case": "Connecting and trading with cryptocurrency exchanges and payment processing services worldwide.",
        "open_issues": 969,
        "cover_image_prompt": "A skilled artisan meticulously crafting a universal key that unlocks a vault filled with diverse cryptocurrency tokens. The artisan uses various tools representing different programming languages (JavaScript, Python, PHP, C#, Go), each tool carefully shaping the key. The vault glows with a soft, inviting light, showcasing charts and trading symbols on its inner walls. Subtle UI elements float around the artisan, displaying API calls and exchange data. The scene is set in a clean, futuristic workshop with a focus on precision and accessibility. The image should be in a 3D isometric illustration style with vibrant colors and clear details, emphasizing the key's ability to access the crypto vault."
    },
    {
        "id": 961948787,
        "name": "weather-mcp-server",
        "description": "A lightweight Model Context Protocol (MCP) server that enables AI assistants like Claude to retrieve and interpret real-time weather data. What makes it popular:",
        "url": "https://github.com/TuanKiri/weather-mcp-server",
        "language": "Go",
        "stars": 213,
        "forks": 13,
        "created_at": "2025-04-07T12:22:42Z",
        "updated_at": "2025-05-07T05:45:29Z",
        "topics": [
            "go",
            "golang",
            "mcp",
            "mcp-server",
            "sse",
            "stdio"
        ],
        "quality_score": 0.7999999999999999,
        "contributors_count": 0,
        "last_commit_date": "2025-04-17T14:38:07Z",
        "media_urls": [
            "https://opengraph.githubassets.com/19d2e21f7079c00681e55ab0e8adf35a53b9a17badb6481a72fd8a9b9d62b338/TuanKiri/weather-mcp-server"
        ],
        "homepage": "https://news.ycombinator.com/item?id=43614582",
        "readme_summary": "The weather-mcp-server is a lightweight Go-based server that implements the Model Context Protocol (MCP) to provide AI assistants with real-time weather data. It supports both local and remote deployment, includes a Dockerfile for easy containerization, and offers a 'current_weather' tool for querying weather information by city. The server is designed to be easily integrated with AI platforms like Claude, allowing them to access and interpret up-to-date weather conditions.",
        "key_features": [
            "Lightweight Model Context Protocol (MCP) server",
            "Enables AI assistants to retrieve and interpret real-time weather data",
            "Supports local and remote modes",
            "Provides a 'current_weather' tool to get weather for a city",
            "Includes Dockerfile for containerization",
            "Includes tests and contribution guidelines"
        ],
        "primary_use_case": "Enabling AI assistants like Claude to access real-time weather data through the Model Context Protocol (MCP).",
        "open_issues": 0,
        "cover_image_prompt": "A friendly weather forecaster, dressed in a modern lab coat, stands before a large, interactive holographic globe. The globe displays real-time weather patterns, with swirling clouds and shimmering raindrops. The forecaster uses a tablet displaying code snippets to query the globe for specific weather data. Subtle UI elements float around the scene, showing the 'current_weather' tool and city input fields. The scene is set in a bright, airy studio with a clean, minimalist design. The image should be in a 3D isometric illustration style with vibrant colors and clear details."
    },
    {
        "id": 361178225,
        "name": "ninjabot",
        "description": "A fast trading bot platform for cryptocurrency in Go (Binance)",
        "url": "https://github.com/rodrigo-brito/ninjabot",
        "language": "Go",
        "stars": 1525,
        "forks": 192,
        "created_at": "2021-04-24T14:07:55Z",
        "updated_at": "2025-05-07T06:58:32Z",
        "topics": [
            "binance",
            "bitcoin",
            "bot",
            "crypto",
            "cryptocurrency",
            "go",
            "golang",
            "hacktoberfest",
            "trading",
            "trading-bot",
            "trading-strategies"
        ],
        "quality_score": 0.55,
        "contributors_count": 0,
        "last_commit_date": "2024-10-28T00:13:16Z",
        "media_urls": [
            "https://repository-images.githubusercontent.com/361178225/b73e29ab-8022-4f21-ae38-879e9c3495a1"
        ],
        "homepage": "https://rodrigo-brito.github.io/ninjabot/",
        "readme_summary": "Ninjabot is a fast cryptocurrency trading bot framework implemented in Go, designed for Binance. It allows users to develop, backtest, and deploy custom trading strategies for spot and futures markets. The platform includes features for live simulation with paper wallets, backtesting with historical data, and real account trading, along with a CLI tool for downloading market data.",
        "key_features": [
            "Paper Wallet (Live Simulation)",
            "Backtesting (Simulation with historical data)",
            "Real Account (Binance)",
            "CLI tool for downloading historical data"
        ],
        "primary_use_case": "Creating and testing custom cryptocurrency trading strategies on Binance.",
        "open_issues": 14,
        "cover_image_prompt": "Imagine a skilled trader, depicted as a focused strategist in a high-tech command center, orchestrating cryptocurrency trades with precision. Multiple screens display real-time market data, candlestick charts, and complex algorithms. The trader uses a conductor's baton to direct the flow of digital currency, represented by glowing streams of light, between different exchanges. Subtle UI elements show the Ninjabot logo and trading parameters. The scene is set in a futuristic, dimly lit room with a sense of intense activity and control. The image should be in a 3D isometric illustration style with vibrant colors and sharp details."
    },
    {
        "id": 956310963,
        "name": "no-ghibli",
        "description": "No Ghibli on Twitter",
        "url": "https://github.com/faisalsayed10/no-ghibli",
        "language": "Jupyter Notebook",
        "stars": 331,
        "forks": 31,
        "created_at": "2025-03-28T03:27:30Z",
        "updated_at": "2025-05-07T05:14:55Z",
        "topics": [],
        "quality_score": 0.3,
        "contributors_count": 0,
        "last_commit_date": "2025-03-29T05:02:54Z",
        "media_urls": [
            "https://opengraph.githubassets.com/c5266d676711825fc6157d5daace335e1f5846150a828629c8f716fed3c126c0/faisalsayed10/no-ghibli"
        ],
        "homepage": null,
        "readme_summary": "The No Ghibli Chrome extension detects and filters out Studio Ghibli-related content from Twitter in real-time. It utilizes a Flask backend with a Keras model for image classification and a Chrome extension to hide tweets containing identified Ghibli content, providing a user-friendly experience through a popup interface.",
        "key_features": [
            "Real-time detection of Studio Ghibli-related images on Twitter",
            "Hides tweets containing Studio Ghibli-related images/videos",
            "User-friendly popup interface for controlling the extension",
            "Efficient image classification using a trained Keras model"
        ],
        "primary_use_case": "Filtering Studio Ghibli-related content from Twitter.",
        "open_issues": 0,
        "cover_image_prompt": "A librarian meticulously organizing digital books on shelves, each book representing a Twitter feed. The librarian uses a special magnifying glass that filters out books containing images of Studio Ghibli characters, placing them on a separate shelf labeled 'Ghibli Archive'. The main shelf displays only non-Ghibli content. A small UI element on the magnifying glass shows the classification result. The scene is set in a bright, modern library with a clean, organized aesthetic. The image should be in a flat design style with clear iconography and a pastel color scheme."
    },
    {
        "id": 204796113,
        "name": "neural-structured-learning",
        "description": "Training neural models with structured signals.",
        "url": "https://github.com/tensorflow/neural-structured-learning",
        "language": "Python",
        "stars": 1001,
        "forks": 190,
        "created_at": "2019-08-27T21:48:16Z",
        "updated_at": "2025-05-07T08:35:08Z",
        "topics": [
            "adversarial-learning",
            "graph-learning",
            "keras",
            "neural-networks",
            "regularization",
            "structured-signals",
            "tensorflow"
        ],
        "quality_score": 0.45,
        "contributors_count": 0,
        "last_commit_date": "2025-01-29T22:28:21Z",
        "media_urls": [
            "https://opengraph.githubassets.com/ac8d0d322c534166ed6fe1152089116ef5015668e342b6762254cc668cd366cf/tensorflow/neural-structured-learning"
        ],
        "homepage": "https://www.tensorflow.org/neural_structured_learning",
        "readme_summary": "The neural-structured-learning repository provides tools and APIs for training neural networks using structured signals, such as graphs and adversarial perturbations. This approach enhances model accuracy, particularly when labeled data is scarce, and improves robustness against malicious attacks. The framework offers Keras APIs, TensorFlow ops, and graph building tools for flexible integration with various neural network architectures.",
        "key_features": [
            "Keras APIs for training with graphs and adversarial perturbations",
            "TF ops and functions for lower-level TensorFlow API usage",
            "Tools to build graphs and construct graph inputs"
        ],
        "primary_use_case": "Training neural networks with structured signals (graphs and adversarial perturbations) to improve accuracy and robustness, especially with limited labeled data.",
        "open_issues": 1,
        "cover_image_prompt": "A gardener carefully tending to a neural network plant, nurturing its growth with structured data represented by glowing, interconnected vines. The plant's roots are embedded in labeled data, while the vines extend to unlabeled data, drawing strength and resilience. The gardener prunes away adversarial attacks, depicted as thorny weeds, ensuring the plant's healthy development. Small UI elements display network architecture and training metrics. The scene is set in a futuristic greenhouse with soft, diffused lighting. The image should be in a 3D isometric illustration style with vibrant colors and rich details."
    },
    {
        "id": 957617467,
        "name": "pokemon-gym",
        "description": null,
        "url": "https://github.com/benchflow-ai/pokemon-gym",
        "language": "Python",
        "stars": 65,
        "forks": 3,
        "created_at": "2025-03-30T19:49:31Z",
        "updated_at": "2025-05-06T20:37:50Z",
        "topics": [],
        "quality_score": 0.6499999999999999,
        "contributors_count": 0,
        "last_commit_date": "2025-04-12T01:01:22Z",
        "media_urls": [
            "https://opengraph.githubassets.com/c0c01d96d3c11db5be239f2b08a389159f70fdcccee35ca955882d9e5fd6689a/benchflow-ai/pokemon-gym"
        ],
        "homepage": null,
        "readme_summary": "PokemonGym is a platform for evaluating AI agents in Pokemon Red. It provides a server-client architecture with evaluation metrics, a FastAPI server for game state, and implementations for both AI and human agents. The platform also includes tools for visualizing and comparing the performance of different AI models.",
        "key_features": [
            "Evaluator: Evaluation metrics and scoring system for Pokemon Red gameplay",
            "Server: FastAPI server that controls Pokemon Red emulation and exposes game state via API",
            "Agents: Implementation of AI and human agents that interact with the evaluator server",
            "Results: Evaluation results comparing different AI models playing Pokemon Red"
        ],
        "primary_use_case": "Evaluating AI agents on Pokemon Red gameplay.",
        "open_issues": 0,
        "cover_image_prompt": "Imagine a bustling Pokémon training arena where AI trainers, depicted as focused strategists with glowing digital interfaces, guide their Pokémon teams through complex battles displayed on holographic screens. Each screen shows real-time game data and strategic options. In the center, a referee bot analyzes the battle, generating evaluation metrics that float as glowing data streams. The arena is filled with subtle UI elements and code snippets, connecting the scene to software. The composition is dynamic and engaging, with a vibrant color scheme. The image should be in a 3D isometric illustration style with rich details and vibrant colors."
    }
]