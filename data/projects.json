[
    {
        "id": 223287266,
        "name": "zee",
        "description": "A modern text editor for the terminal written in Rust",
        "url": "https://github.com/zee-editor/zee",
        "language": "Rust",
        "stars": 1592,
        "forks": 44,
        "created_at": "2019-11-21T23:58:51Z",
        "updated_at": "2025-08-26T08:54:38Z",
        "topics": [
            "async",
            "cross-platform",
            "emacs",
            "ide",
            "incremental-parsing",
            "rope",
            "rust-lang",
            "text-editor",
            "tree-sitter"
        ],
        "quality_score": 0.55,
        "contributors_count": 0,
        "last_commit_date": "2025-02-06T18:41:35Z",
        "media_urls": [
            "https://opengraph.githubassets.com/26ed3b98601d2e897efc591abfab163265b433ecde1c816638212dcfffdd6849/zee-editor/zee"
        ],
        "homepage": "",
        "readme_summary": "Zee is a modern, terminal-based text editor written in Rust, inspired by Emacs. It emphasizes performance and leverages technologies like rope data structures and Tree-sitter for efficient text manipulation and syntax highlighting. Zee aims to provide a fast and feature-rich editing experience within the terminal.",
        "key_features": [
            "High performance (100 FPS editor)",
            "Rope data structure for buffers",
            "Edit tree history (undo/redo)",
            "Tree-sitter for syntax highlighting and validation",
            "Multi-buffer, multi-pane support",
            "Fast file search with fuzzy matching",
            "Local file picker"
        ],
        "primary_use_case": "Terminal-based text editing",
        "open_issues": 32,
        "cover_image_prompt": "A skilled calligrapher in a serene study, using a magical quill to meticulously edit a large scroll of text displayed on a holographic screen. The quill glows with Rust-colored energy, and the scroll dynamically updates with each stroke. The study is filled with subtle tech elements, such as floating code snippets and data visualizations. The repository name, 'Zee,' is subtly inscribed on the quill. The composition is clean and focused, with a warm color scheme. The image should be in a digital painting style with clear outlines and rich details."
    },
    {
        "id": 386913925,
        "name": "discordo",
        "description": "A lightweight, secure, and feature-rich Discord terminal (TUI) client.",
        "url": "https://github.com/ayn2op/discordo",
        "language": "Go",
        "stars": 2889,
        "forks": 103,
        "created_at": "2021-07-17T11:00:48Z",
        "updated_at": "2025-08-26T09:51:09Z",
        "topics": [
            "cross-platform",
            "discord",
            "discordo",
            "go",
            "golang",
            "linux",
            "terminal",
            "terminal-based",
            "tui"
        ],
        "quality_score": 0.85,
        "contributors_count": 0,
        "last_commit_date": "2025-08-25T17:32:16Z",
        "media_urls": [
            "https://opengraph.githubassets.com/4ec15d79522e88b71120fa73b86b4365ca0e00e939bba2c849348d3f778929ed/ayn2op/discordo"
        ],
        "homepage": "",
        "readme_summary": "Discordo is a lightweight and feature-rich Discord terminal client designed for users who prefer a text-based interface. It supports essential Discord features like attachments, notifications, and markdown, along with security features like 2-Factor authentication. Discordo is cross-platform, offering prebuilt binaries and package manager support for easy installation on various operating systems.",
        "key_features": [
            "Lightweight",
            "Configurable",
            "Mouse & clipboard support",
            "Attachments",
            "Notifications",
            "2-Factor authentication",
            "Discord-flavored markdown"
        ],
        "primary_use_case": "Terminal-based Discord client",
        "open_issues": 51,
        "cover_image_prompt": "Imagine a bustling train station where messages (representing Discord messages) arrive on various platforms (Linux, macOS, Windows) and are efficiently routed to a central terminal display (Discordo). A conductor (user) stands before the display, easily reading and interacting with the messages using keyboard controls. Subtle UI elements are overlaid on the station's architecture, showing Discord channels and user interfaces. The scene is set in a stylized, modern train station with a clean, organized layout and soft, diffused lighting. The image should be in a 3D isometric illustration style with vibrant colors and clear details."
    },
    {
        "id": 792805133,
        "name": "tabiew",
        "description": "A lightweight TUI application to view and query tabular data files, such as CSV, TSV, and parquet.",
        "url": "https://github.com/shshemi/tabiew",
        "language": "Rust",
        "stars": 2277,
        "forks": 60,
        "created_at": "2024-04-27T16:21:19Z",
        "updated_at": "2025-08-26T09:22:34Z",
        "topics": [],
        "quality_score": 0.7499999999999999,
        "contributors_count": 0,
        "last_commit_date": "2025-08-26T00:24:22Z",
        "media_urls": [
            "https://opengraph.githubassets.com/670be81947a0712707cc50eb64d98f1e3ab4eb9521bcdf75de9fd1170e2e4707/shshemi/tabiew"
        ],
        "homepage": "",
        "readme_summary": "Tabiew is a lightweight TUI application designed for viewing and querying tabular data files. It supports a variety of formats, including CSV, Parquet, and JSON, and offers features like SQL support, fuzzy search, and Vim-style keybindings. Tabiew provides a user-friendly way to interact with and analyze data directly from the terminal.",
        "key_features": [
            "Vim-style keybindings",
            "SQL support",
            "Support for various tabular data formats (CSV, Parquet, JSON, JSONL, Arrow, FWF, Sqlite, Excel)",
            "Fuzzy search",
            "Scripting support",
            "Multi-table functionality",
            "Plotting"
        ],
        "primary_use_case": "Viewing and querying tabular data files.",
        "open_issues": 9,
        "cover_image_prompt": "Imagine a skilled librarian in a vast, luminous library filled with towering shelves of data. She stands at a central console, effortlessly querying and displaying information from countless books (CSV, Parquet, JSON, etc.) onto a holographic display. The library's architecture subtly incorporates UI elements and data visualizations, blending the analog and digital worlds. The scene is bathed in soft, focused light, highlighting the librarian's focused expression and the clarity of the displayed data. The image should be in a 3D isometric illustration style with rich details and a warm, inviting color scheme."
    },
    {
        "id": 1031397464,
        "name": "Ikea-like-captcha",
        "description": null,
        "url": "https://github.com/SomeMedic/Ikea-like-captcha",
        "language": "TypeScript",
        "stars": 3,
        "forks": 0,
        "created_at": "2025-08-03T16:49:07Z",
        "updated_at": "2025-08-05T16:06:32Z",
        "topics": [],
        "quality_score": 0.44999999999999996,
        "contributors_count": 0,
        "last_commit_date": "2025-08-03T17:06:35Z",
        "media_urls": [
            "https://opengraph.githubassets.com/af39989e9dea37f7d096d3b01816d8e87f64967df6a43cf94a730e3e81b30df0/SomeMedic/Ikea-like-captcha"
        ],
        "homepage": "https://ikea-like-captcha.vercel.app",
        "readme_summary": "The repository provides a guide for creating Leonardo.AI prompts to generate conceptual illustrations that visually represent the function of a software repository. It uses the metaphor of assembling IKEA furniture to represent solving a CAPTCHA, and provides instructions for creating prompts that translate technical concepts into easily understandable visuals.",
        "key_features": [
            "Ikea assembly-themed CAPTCHA",
            "Conceptual illustration generation guide"
        ],
        "primary_use_case": "Generating conceptual illustrations for software repositories using AI",
        "open_issues": 0,
        "cover_image_prompt": "A person assembling a complex piece of IKEA furniture, but instead of instructions, they are presented with a CAPTCHA challenge involving identifying the correct furniture parts. The assembled furniture represents a successfully completed task or access granted. Digital particles float around the furniture, subtly connecting the metaphor to software. The scene is set in a brightly lit, minimalist room. Small UI elements display the CAPTCHA interface. The image should be in a flat design style with clear iconography and a limited color palette."
    },
    {
        "id": 781022269,
        "name": "prompt-eng-interactive-tutorial",
        "description": "Anthropic's Interactive Prompt Engineering Tutorial",
        "url": "https://github.com/anthropics/prompt-eng-interactive-tutorial",
        "language": "Jupyter Notebook",
        "stars": 17711,
        "forks": 1749,
        "created_at": "2024-04-02T15:52:00Z",
        "updated_at": "2025-08-26T10:00:51Z",
        "topics": [],
        "quality_score": 0.45,
        "contributors_count": 0,
        "last_commit_date": "2024-04-08T03:17:07Z",
        "media_urls": [
            "https://opengraph.githubassets.com/bf23680e3182b401b1e33719a6d1dd234c8acffaa6d06bc6d5a32dc32e33efc0/anthropics/prompt-eng-interactive-tutorial"
        ],
        "homepage": null,
        "readme_summary": "This repository provides an interactive tutorial for learning prompt engineering with Anthropic's Claude AI model. It offers a structured course with lessons, exercises, and a playground to practice writing and troubleshooting prompts. The tutorial covers basic prompt structure, common failure modes, and advanced techniques to help users build effective prompts for various use cases.",
        "key_features": [
            "Step-by-step guide to prompt engineering with Claude.",
            "Nine chapters with lessons and exercises.",
            "Example Playground for experimentation.",
            "Advanced methods in the appendix.",
            "Covers basic prompt structure, failure modes, and advanced techniques."
        ],
        "primary_use_case": "Learning and practicing prompt engineering techniques for the Claude AI model.",
        "open_issues": 11,
        "cover_image_prompt": "A student sitting at a desk, illuminated by a glowing Claude logo, is carefully crafting a prompt on a digital notebook. The prompt transforms into a helpful, insightful response displayed on a screen beside them. The scene is set in a modern, minimalist study with soft, warm lighting. Small UI elements showing prompt examples and Claude's responses subtly connect the metaphor to prompt engineering. The composition is clean and focused with a pastel color scheme. The image should be in flat design style with clear iconography and vibrant colors."
    },
    {
        "id": 478293508,
        "name": "process-compose",
        "description": "Process Compose is a simple and flexible scheduler and orchestrator to manage non-containerized applications.",
        "url": "https://github.com/F1bonacc1/process-compose",
        "language": "Go",
        "stars": 1755,
        "forks": 78,
        "created_at": "2022-04-05T20:40:27Z",
        "updated_at": "2025-08-26T08:44:42Z",
        "topics": [
            "docker",
            "go",
            "golang",
            "open-source",
            "orchestration",
            "orchestrator",
            "processes",
            "tui",
            "workflows"
        ],
        "quality_score": 1.0000000000000002,
        "contributors_count": 0,
        "last_commit_date": "2025-08-25T22:28:09Z",
        "media_urls": [
            "https://opengraph.githubassets.com/754bb2f5aba49a16c10c91c68ee80fd1af33b777d51e957356d261a1c4b4a40b/F1bonacc1/process-compose"
        ],
        "homepage": "https://f1bonacc1.github.io/process-compose/",
        "readme_summary": "Process Compose is a Go-based scheduler and orchestrator designed to manage non-containerized applications. It allows users to define workflows using a simple YAML schema, manage process dependencies, and execute processes in parallel or serially. It offers features such as health checks, a TUI, and a REST API, providing a comprehensive solution for managing applications without Docker.",
        "key_features": [
            "Processes execution (parallel or serial)",
            "Processes dependencies and startup order",
            "Process recovery policies",
            "Manual process restart",
            "Processes arguments (bash/zsh style)",
            "Per process and global environment variables",
            "Per process or global logs",
            "Health checks (liveness and readiness)",
            "TUI or CLI modes",
            "Forking processes",
            "REST API (OpenAPI/Swagger)",
            "Logs caching",
            "Server and client functions",
            "Configurable shortcuts",
            "Merge Configuration Files",
            "Namespaces",
            "Run Multiple Replicas of a Process",
            "Run a Foreground Process",
            "Themes Support"
        ],
        "primary_use_case": "Managing and orchestrating non-containerized applications.",
        "open_issues": 30,
        "cover_image_prompt": "Imagine a skilled conductor orchestrating a diverse group of musicians, each representing a non-containerized application. The conductor, symbolizing Process Compose, stands on a platform adorned with a simplified YAML configuration file as sheet music. The musicians play in harmony, their instruments emitting glowing, synchronized notes that form a cohesive melody. Subtle UI elements float around the orchestra, displaying process statuses and dependencies. The scene is set in a grand concert hall with warm, inviting lighting. The image should be in a 3D isometric illustration style with rich details and vibrant colors."
    },
    {
        "id": 190254663,
        "name": "ripgrep-all",
        "description": "rga: ripgrep, but also search in PDFs, E-Books, Office documents, zip, tar.gz, etc.",
        "url": "https://github.com/phiresky/ripgrep-all",
        "language": "Rust",
        "stars": 9073,
        "forks": 196,
        "created_at": "2019-06-04T18:08:31Z",
        "updated_at": "2025-08-26T08:34:48Z",
        "topics": [],
        "quality_score": 0.55,
        "contributors_count": 0,
        "last_commit_date": "2025-05-11T19:36:18Z",
        "media_urls": [
            "https://opengraph.githubassets.com/a74e8774aa2ad7bcd3856c5c5b45307832f903f373797baaabdcae4eea4ac1e9/phiresky/ripgrep-all"
        ],
        "homepage": "",
        "readme_summary": "rga (ripgrep-all) enhances the functionality of ripgrep by enabling it to search within a multitude of file types such as PDFs, E-Books, Office documents, and archives. It recursively descends into archives and uses adapters to handle different file formats, allowing users to efficiently search for text across diverse file types.",
        "key_features": [
            "Extends ripgrep to search within various file types (PDFs, E-Books, Office documents, zip, tar.gz, etc.)",
            "Recursively descends into archives to find matches.",
            "Provides adapters for different file formats.",
            "Supports custom adapters.",
            "Integrates with fzf."
        ],
        "primary_use_case": "Searching for text within a variety of file types, including archives and documents, using ripgrep's powerful regex capabilities.",
        "open_issues": 50,
        "cover_image_prompt": "A librarian meticulously examining various documents (PDFs, E-books, Office files, archives) with a magnifying glass that emits a ripgrep-like search beam, highlighting matching text within each file. The librarian stands amidst towering shelves filled with diverse file formats, each subtly labeled with file extensions. A holographic display shows a simplified ripgrep search interface, confirming the search parameters. The scene is set in a bright, organized library with a warm, inviting atmosphere. The image should be in a 3D isometric illustration style with clear details and a focus on readability."
    }
]