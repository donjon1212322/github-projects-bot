[
    {
        "id": 1027461827,
        "name": "vicinae",
        "description": "A focused launcher for your desktop â€” native, fast, extensible",
        "url": "https://github.com/vicinaehq/vicinae",
        "language": "C++",
        "stars": 368,
        "forks": 1,
        "created_at": "2025-07-28T03:49:03Z",
        "updated_at": "2025-08-15T10:11:45Z",
        "topics": [
            "app-launcher",
            "linux",
            "nodejs",
            "poweruser",
            "productivity",
            "qt",
            "raycast",
            "react"
        ],
        "quality_score": 0.5499999999999999,
        "contributors_count": 0,
        "last_commit_date": "2025-08-15T09:49:02Z",
        "media_urls": [
            "https://opengraph.githubassets.com/b0debbe4726ca38e5d06c46a6c0b96fa577b2e085577c2d23cc66dd6709e540a/vicinaehq/vicinae"
        ],
        "homepage": "https://docs.vicinae.com",
        "readme_summary": "Vicinae is a high-performance, native launcher for Linux built with C++ and Qt. It provides a fast, keyboard-first interface for accessing system actions, launching applications, and performing common tasks. Vicinae also offers Raycast compatibility, allowing users to leverage existing extensions with minimal modification.",
        "key_features": [
            "Application launching and information retrieval",
            "File indexing with full-text search",
            "Emoji picker with custom keywords",
            "Calculator with unit and currency conversion",
            "Encrypted clipboard history tracker",
            "Shortcuts via dynamic links",
            "Window manager integration",
            "Built-in theming system",
            "Raycast compatibility"
        ],
        "primary_use_case": "Fast, keyboard-first access to system actions for developers and power users.",
        "open_issues": 7,
        "cover_image_prompt": "Imagine a skilled conductor leading an orchestra where each instrument represents a different application or system function. The conductor, representing Vicinae, stands on a platform with a sleek, minimalist interface projected onto it. With precise gestures, the conductor orchestrates the 'instruments' to create a harmonious and efficient workflow. Subtle digital elements, like glowing data streams connecting the instruments and small UI snippets on the conductor's platform, connect the metaphor to software. The scene is bathed in soft, focused lighting, creating a sense of control and precision. The image should be in 3D isometric illustration style with clean lines and a vibrant color scheme."
    },
    {
        "id": 81095334,
        "name": "save-images",
        "description": "Save loaded images in nested iframe pages",
        "url": "https://github.com/belaviyo/save-images",
        "language": "HTML",
        "stars": 301,
        "forks": 70,
        "created_at": "2017-02-06T14:27:41Z",
        "updated_at": "2025-08-15T06:42:21Z",
        "topics": [],
        "quality_score": 0.75,
        "contributors_count": 0,
        "last_commit_date": "2025-07-27T12:42:27Z",
        "media_urls": [
            "https://opengraph.githubassets.com/3c1bb3e915ab8161f32e4a980d090fc717920c85846420819eecfe7bffb6d5e4/belaviyo/save-images"
        ],
        "homepage": "https://webextension.org/listing/save-images.html",
        "readme_summary": "The 'save-images' repository provides a browser extension that allows users to download all images from a webpage. It detects images even within nested iframes and offers filtering options based on file size, dimensions, URL, and file type. The extension also finds images in links, background scripts, and CSS files, presenting them in a gallery view before downloading.",
        "key_features": [
            "Detects images in nested iframes",
            "Filters images by size, dimension, URL, or type",
            "Finds images in links, background scripts, and CSS files",
            "Displays images in a gallery view"
        ],
        "primary_use_case": "Downloading all images from a webpage, including those in nested iframes, with customizable filtering options.",
        "open_issues": 45,
        "cover_image_prompt": "A skilled librarian carefully extracting images from countless books and scrolls, organizing them into a beautifully curated digital gallery. The librarian uses a magnifying glass that highlights different image types and sizes, filtering them with a touch. Small UI elements float around the scene, showing file size and type options. The library is filled with glowing particles representing data streams. The repository name is subtly etched on a bookshelf. The scene is set in a bright, airy digital library with a clean, focused composition and a pastel color scheme. The image should be in a flat design style with clear iconography and vibrant colors."
    },
    {
        "id": 1032305700,
        "name": "term-shdw",
        "description": null,
        "url": "https://github.com/DaarcyDev/term-shdw",
        "language": "Python",
        "stars": 13,
        "forks": 0,
        "created_at": "2025-08-05T05:54:42Z",
        "updated_at": "2025-08-14T20:00:49Z",
        "topics": [],
        "quality_score": 0.44999999999999996,
        "contributors_count": 0,
        "last_commit_date": "2025-08-10T23:29:16Z",
        "media_urls": [
            "https://opengraph.githubassets.com/6338fd09b92783c4e2a520a21ea0a8dad5bebe22fdcd7adf83a60e8168dc73de/DaarcyDev/term-shdw"
        ],
        "homepage": null,
        "readme_summary": "Term-shdw is a Python CLI tool that generates an interactive comet effect in the terminal, following mouse movements and displaying a fading tail, aura, and twinkling stars. It's designed for lightweight customization through command-line options and is intended for users who want to enhance their terminal's visual appeal.",
        "key_features": [
            "Interactive comet head following mouse motion",
            "Fading tail with color interpolation",
            "Light aura surrounding the head",
            "Twinkling stars",
            "Command-line options for personalization",
            "Mouse SGR/1006 mode support with X10 fallback",
            "Dependency-free (pure Python)"
        ],
        "primary_use_case": "Creating an interactive terminal comet/shadow effect for aesthetic purposes and customization.",
        "open_issues": 0,
        "cover_image_prompt": "Imagine a celestial artist painting the night sky with a comet as their brush. The comet, vibrant and luminous, leaves a shimmering trail of stardust across a dark canvas. The artist, clad in a modern tech-inspired robe, adjusts settings on a holographic interface, controlling the comet's color and trail length. Tiny code snippets float around the artist, subtly connecting the scene to software. The background features a stylized terminal window displaying the 'term-shdw' command. The scene is bathed in soft, ethereal lighting with a cosmic color scheme. The image should be in digital painting style with clear outlines and vibrant colors."
    },
    {
        "id": 1029317220,
        "name": "brs-xss",
        "description": "Next-Generation XSS Detection Suite",
        "url": "https://github.com/EPTLLC/brs-xss",
        "language": "Python",
        "stars": 12,
        "forks": 0,
        "created_at": "2025-07-30T21:22:10Z",
        "updated_at": "2025-08-15T07:35:13Z",
        "topics": [
            "async",
            "brabus",
            "brs",
            "brs-xss",
            "cli-tool",
            "easyprotech",
            "ml-aware",
            "pentest",
            "python",
            "security-analysis",
            "xss",
            "xss-scanner"
        ],
        "quality_score": 0.75,
        "contributors_count": 0,
        "last_commit_date": "2025-08-10T22:44:31Z",
        "media_urls": [
            "https://opengraph.githubassets.com/178e09624c4c7f19cd90db1d579d0654925248590940129ff2690965c455cae9/EPTLLC/brs-xss"
        ],
        "homepage": "",
        "readme_summary": "BRS-XSS is a command-line XSS scanner designed for security professionals. It offers features like context-aware scanning, WAF detection & bypass, intelligent classification, and professional reporting. The tool supports asynchronous scanning, web crawling, and DOM XSS analysis, making it a comprehensive solution for identifying XSS vulnerabilities.",
        "key_features": [
            "Context-Aware Scanning",
            "WAF Detection & Bypass",
            "Intelligent Classification",
            "Professional Reporting",
            "Multi-Language Support",
            "High Performance",
            "Web Crawling",
            "DOM XSS Analysis"
        ],
        "primary_use_case": "Cross-Site Scripting (XSS) vulnerability scanning for security professionals and penetration testers.",
        "open_issues": 1,
        "cover_image_prompt": "A skilled detective meticulously examining a website's architecture, represented as a complex cityscape, using a magnifying glass that reveals hidden XSS vulnerabilities as glowing red cracks in the buildings. The detective's tools include a laptop displaying security analysis data and a notepad filled with potential exploits. The cityscape is bathed in a neon glow, with subtle digital elements like code snippets and security metrics overlaid on the buildings. The scene is set in a futuristic, high-tech environment with dramatic lighting. The image should be in a digital painting style with clean lines and clear details, emphasizing the detective's focus and the hidden vulnerabilities."
    },
    {
        "id": 910418754,
        "name": "nanobrowser",
        "description": "Open-Source Chrome extension for AI-powered web automation. Run multi-agent workflows using your own LLM API key. Alternative to OpenAI Operator.",
        "url": "https://github.com/nanobrowser/nanobrowser",
        "language": "TypeScript",
        "stars": 8406,
        "forks": 853,
        "created_at": "2024-12-31T08:11:27Z",
        "updated_at": "2025-08-15T10:12:05Z",
        "topics": [
            "agent",
            "ai",
            "ai-agents",
            "ai-tools",
            "automation",
            "browser",
            "browser-extension",
            "browser-use",
            "chrome-extension",
            "manus",
            "mariner",
            "multi-agent",
            "nano",
            "openai",
            "opensource",
            "operator",
            "web",
            "web-automation"
        ],
        "quality_score": 0.9000000000000001,
        "contributors_count": 0,
        "last_commit_date": "2025-08-14T06:51:39Z",
        "media_urls": [
            "https://opengraph.githubassets.com/bc7bc8bfe6f19177e689137c9f258023effa0297c7650f06af07886259c39351/nanobrowser/nanobrowser"
        ],
        "homepage": "",
        "readme_summary": "Nanobrowser is an open-source Chrome extension for AI-powered web automation. It allows users to run multi-agent workflows using their own LLM API keys, offering a free and privacy-focused alternative to tools like OpenAI Operator. The extension supports multiple LLM providers and features an interactive side panel for real-time task management.",
        "key_features": [
            "Multi-agent System",
            "Interactive Side Panel",
            "Task Automation",
            "Follow-up Questions",
            "Conversation History",
            "Multiple LLM Support"
        ],
        "primary_use_case": "AI-powered web automation using multi-agent workflows.",
        "open_issues": 27,
        "cover_image_prompt": "Imagine a team of tiny AI agents, each with magnifying glasses and tool belts, meticulously automating tasks on a giant, glowing web page. One agent clicks buttons, another fills forms, and a third analyzes data, all orchestrated by a central AI 'Planner' displayed as a holographic brain overseeing the operation. The webpage reflects a complex task being simplified, like booking travel or researching a topic. Subtle code snippets float in the background, and the Nanobrowser logo is subtly integrated into the webpage design. The scene is brightly lit with a clean, futuristic aesthetic, rendered in a 3D isometric illustration style with vibrant colors and sharp details."
    },
    {
        "id": 438128602,
        "name": "lotusdb",
        "description": "Most advanced key-value database written in Go, extremely fast, compatible with LSM tree and B+ tree.",
        "url": "https://github.com/lotusdblabs/lotusdb",
        "language": "Go",
        "stars": 2224,
        "forks": 183,
        "created_at": "2021-12-14T05:26:57Z",
        "updated_at": "2025-08-15T06:54:25Z",
        "topics": [
            "bptree",
            "database",
            "golang",
            "kv-store",
            "lsm-tree",
            "storage"
        ],
        "quality_score": 0.6,
        "contributors_count": 0,
        "last_commit_date": "2025-02-18T08:07:45Z",
        "media_urls": [
            "https://opengraph.githubassets.com/dc46975cd3d8be8f92ba6e0a9b756c5919e22b5dcb6bb08c6cc34091bfabe99b/lotusdblabs/lotusdb"
        ],
        "homepage": "https://lotusdblabs.github.io",
        "readme_summary": "LotusDB is a high-performance key-value store written in Go. It combines the strengths of both LSM trees and B+ trees to achieve fast read/write speeds and reduced space amplification. It is designed as an optimized alternative to existing key-value stores like Badger and Bolt.",
        "key_features": [
            "Combine the advantages of LSM and B+ tree",
            "Fast read/write performance",
            "Much lower read and space amplification than typical LSM"
        ],
        "primary_use_case": "Key-value data storage",
        "open_issues": 16,
        "cover_image_prompt": "Imagine a skilled gardener tending to a garden where data grows as vibrant plants. The gardener carefully grafts branches from a robust, ancient B+ tree onto a thriving, modern LSM tree, creating a hybrid plant with exceptional growth and resilience. The hybrid plant bears fruit representing fast read/write performance and efficient storage. Subtle UI elements displaying database metrics and code snippets are integrated into the garden's design. The scene is bathed in warm, inviting sunlight, symbolizing optimization. The image should be in a 3D isometric illustration style, with clear details and a vibrant color scheme."
    }
]