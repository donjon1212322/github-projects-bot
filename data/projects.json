[
    {
        "id": 940004912,
        "name": "ClipboardShield",
        "description": "Clipboard Shield: Protection Defends Against Cyberthreats",
        "url": "https://github.com/CoinFabrik/ClipboardShield",
        "language": "C++",
        "stars": 15,
        "forks": 1,
        "created_at": "2025-02-27T13:12:53Z",
        "updated_at": "2025-03-22T09:07:27Z",
        "topics": [
            "clipboard",
            "defense",
            "threats"
        ],
        "quality_score": 0.85,
        "contributors_count": 0,
        "last_commit_date": "2025-03-17T22:30:48Z",
        "media_urls": [
            "https://opengraph.githubassets.com/af46b52c35cd45cbe30cef14fc128e3131c1748853b389e74096550ff54f3521/CoinFabrik/ClipboardShield"
        ],
        "homepage": "",
        "readme_summary": "Clipboard Shield is designed to monitor and protect sensitive data copied to the system clipboard, preventing unauthorized access from malicious applications. It utilizes features like event hooks, inter-process communication, custom threads, logging, and Windows service integration to provide continuous protection and security auditing.",
        "key_features": [
            "Protection of clipboard content against unauthorized access",
            "Implementation of hooks for event detection",
            "Inter-process communication (IPC) for security management",
            "Use of custom threads to optimize performance",
            "Logging capabilities for security auditing",
            "Windows service integration for continuous protection"
        ],
        "primary_use_case": "Protecting the system clipboard from unauthorized access by malicious applications.",
        "open_issues": 1,
        "cover_image_prompt": "A blacksmith meticulously forging a digital shield in a high-tech workshop. The blacksmith carefully hammers glowing lines of code onto the shield, reinforcing its structure. A stream of data flows towards the shield, representing clipboard content, while malicious entities (represented by shadowy figures) attempt to breach it. The shield deflects these threats, showcasing its protective capabilities. Small UI elements display real-time security logs and clipboard activity. The scene is set in a brightly lit, futuristic forge with sparks flying. The image should be in a detailed digital painting style with vibrant colors and clear outlines."
    },
    {
        "id": 5616877,
        "name": "Thrive",
        "description": "The main repository for the development of the evolution game Thrive. ",
        "url": "https://github.com/Revolutionary-Games/Thrive",
        "language": "C#",
        "stars": 3063,
        "forks": 523,
        "created_at": "2012-08-30T15:31:36Z",
        "updated_at": "2025-03-22T08:27:42Z",
        "topics": [
            "biology",
            "csharp",
            "evolution",
            "game",
            "godot",
            "godot-engine",
            "sandbox",
            "science",
            "simulation",
            "strategy",
            "thrive"
        ],
        "quality_score": 0.9500000000000001,
        "contributors_count": 0,
        "last_commit_date": "2025-03-21T07:58:47Z",
        "media_urls": [
            "https://repository-images.githubusercontent.com/5616877/23434400-d399-11eb-9a83-a0ece3bc9269"
        ],
        "homepage": "https://revolutionarygamesstudio.com/",
        "readme_summary": "Thrive is an open-source evolution simulation game developed in C# using the Godot Engine. The repository contains the game's source code, assets, and documentation, and it encourages community contributions through coding, art, translation, and testing. It uses Git LFS for managing large asset files.",
        "key_features": [
            "Evolution simulation game development",
            "C# codebase with Godot Engine integration",
            "Asset management using Git LFS",
            "Extensive documentation and contribution guidelines",
            "Community-driven development with forums and translation support"
        ],
        "primary_use_case": "Development of an open-source evolution simulation game called Thrive.",
        "open_issues": 693,
        "cover_image_prompt": "A thriving ecosystem inside a digital petri dish, where tiny, evolving organisms compete and adapt. The dish is monitored by a scientist using a holographic interface displaying code snippets and simulation parameters. Some organisms are simple cells, while others are complex multicellular creatures, showcasing the evolution process. The scene is set in a futuristic laboratory with soft, diffused lighting. Small UI elements show real-time simulation data and evolutionary trees. The composition is clean and focused, with a vibrant color scheme. The image should be in 3D isometric illustration style with rich details and vibrant colors."
    },
    {
        "id": 17420614,
        "name": "SeleniumBase",
        "description": "Python APIs for web automation, testing, and bypassing bot-detection.",
        "url": "https://github.com/seleniumbase/SeleniumBase",
        "language": "Python",
        "stars": 9589,
        "forks": 1236,
        "created_at": "2014-03-04T23:07:33Z",
        "updated_at": "2025-03-22T09:41:37Z",
        "topics": [
            "anti-detection",
            "behave",
            "bot-detection",
            "cdp",
            "chromedriver",
            "cloudflare-bypass",
            "e2e-testing",
            "pytest",
            "pytest-plugin",
            "python",
            "python-scraper",
            "selenium",
            "selenium-python",
            "seleniumbase",
            "test-automation",
            "web-automation",
            "web-scraping",
            "web-scraping-python",
            "webdriver",
            "webkit"
        ],
        "quality_score": 0.85,
        "contributors_count": 0,
        "last_commit_date": "2025-03-21T21:43:23Z",
        "media_urls": [
            "https://repository-images.githubusercontent.com/17420614/88f045f8-d20b-4d5e-9e71-fa03242f5654"
        ],
        "homepage": "https://seleniumbase.io",
        "readme_summary": "SeleniumBase is a Python framework for web automation and end-to-end testing. It provides APIs for browser automation, web crawling, web scraping, and bypassing bot detection. It integrates with pytest and offers features for creating robust and reliable web tests.",
        "key_features": [
            "Web automation",
            "Web testing",
            "Web scraping",
            "Bot detection bypass",
            "End-to-end testing",
            "Pytest integration",
            "Web crawling",
            "Stealth automation"
        ],
        "primary_use_case": "Web automation, testing, and bypassing bot-detection.",
        "open_issues": 18,
        "cover_image_prompt": "A skilled architect overseeing a team of robots constructing a magnificent web portal. The architect holds blueprints representing test scripts, while the robots meticulously assemble the portal's components: secure gateways, responsive designs, and user-friendly interfaces. Digital particles flow around the portal, symbolizing automated processes and data streams. Small UI elements on nearby screens display real-time test results and performance metrics. The scene is set in a futuristic construction yard with bright, optimistic lighting. The image should be in 3D isometric illustration style with rich details and vibrant colors."
    },
    {
        "id": 930695967,
        "name": "voice-transcribe-summarize-telegram-bot",
        "description": "Telegram bot to generate transcriptions and summarise voice notes",
        "url": "https://github.com/aviaryan/voice-transcribe-summarize-telegram-bot",
        "language": "Python",
        "stars": 29,
        "forks": 10,
        "created_at": "2025-02-11T03:54:07Z",
        "updated_at": "2025-03-22T09:48:14Z",
        "topics": [
            "groq",
            "llama3",
            "llm",
            "llms",
            "telegram-bot",
            "whisper"
        ],
        "quality_score": 0.3,
        "contributors_count": 0,
        "last_commit_date": "2025-02-16T14:41:47Z",
        "media_urls": [
            "https://opengraph.githubassets.com/c3b74d898009af7e3a9a30db552bddde521f19d1574012eeb86454e0b3d196f9/aviaryan/voice-transcribe-summarize-telegram-bot"
        ],
        "homepage": "",
        "readme_summary": "This repository provides a Telegram bot that transcribes voice notes using Whisper and summarizes them using Llama 3, both powered by Groq's API. It allows users to easily convert spoken audio into text and receive concise summaries directly within Telegram, supporting various audio formats.",
        "key_features": [
            "Transcribes voice notes from Telegram messages",
            "Summarizes transcribed content",
            "Uses Whisper for transcription",
            "Uses Llama 3 for summarization",
            "Supports multiple audio formats"
        ],
        "primary_use_case": "Transcribing and summarizing voice notes received via Telegram.",
        "open_issues": 0,
        "cover_image_prompt": "Imagine a diligent scribe in a cozy, futuristic library, meticulously transcribing spoken words from glowing orbs into neatly written summaries on parchment. The orbs represent voice notes arriving via a shimmering portal labeled 'Telegram.' The scribe uses a magical quill powered by 'Groq' to instantly convert the audio into text and then condense it into a concise summary. Small screens display snippets of code and the Llama 3 logo. The scene is bathed in warm, inviting light with a focus on clarity and efficiency. The image should be in a 3D isometric illustration style with rich details and vibrant colors."
    },
    {
        "id": 23129458,
        "name": "aseprite",
        "description": "Animated sprite editor & pixel art tool (Windows, macOS, Linux)",
        "url": "https://github.com/aseprite/aseprite",
        "language": "C++",
        "stars": 31274,
        "forks": 6829,
        "created_at": "2014-08-19T23:44:50Z",
        "updated_at": "2025-03-22T07:53:16Z",
        "topics": [
            "animated-sprites",
            "animation",
            "aseprite",
            "c-plus-plus",
            "cpp",
            "draw",
            "gif",
            "graphics",
            "pixel-art",
            "pixel-editor",
            "sprite-editor",
            "sprites",
            "spritesheet",
            "tile-editor",
            "tilemap-editor"
        ],
        "quality_score": 1.05,
        "contributors_count": 0,
        "last_commit_date": "2025-03-03T14:24:52Z",
        "media_urls": [
            "https://repository-images.githubusercontent.com/23129458/bc7e1a00-4beb-11ea-965b-60f3458721df"
        ],
        "homepage": "https://www.aseprite.org",
        "readme_summary": "Aseprite is a C++ based animated sprite editor and pixel art tool. It provides features for creating and editing sprites with layers, frames, color profiles, and animation tools. It supports exporting to various formats and offers pixel-art specific tools, Lua scripting, and a command-line interface.",
        "key_features": [
            "Layer and frame-based sprite composition",
            "Color profile and mode support (RGBA, Indexed, Grayscale)",
            "Animation facilities with real-time preview and onion skinning",
            "Export/import to sprite sheets, GIF, PNG, and other formats",
            "Pixel-art specific tools (Pixel Perfect, Shading, Custom Brushes)",
            "Lua scripting capabilities",
            "CLI for automation"
        ],
        "primary_use_case": "Creating animated sprites and pixel art.",
        "open_issues": 1699,
        "cover_image_prompt": "An artist meticulously crafting a vibrant pixel art animation on a digital easel, bringing a static character to life frame by frame. The easel displays the animation timeline, showcasing layers and frames. The artist uses specialized pixel art tools, with palettes of colors and shading techniques visible. The background subtly incorporates UI elements from Aseprite, like the sprite sheet export window and scripting interface. The scene is set in a brightly lit studio with a focus on the creative process. The image should be in a detailed digital painting style with clear outlines and vibrant colors."
    },
    {
        "id": 869724660,
        "name": "quicky",
        "description": "A simple CLI tool to self-host Next.js applications.",
        "url": "https://github.com/alohe/quicky",
        "language": "JavaScript",
        "stars": 421,
        "forks": 14,
        "created_at": "2024-10-08T19:24:28Z",
        "updated_at": "2025-03-22T08:33:49Z",
        "topics": [
            "automation",
            "cli",
            "deployment",
            "nextjs",
            "npm",
            "npm-package",
            "npx",
            "self-hosted",
            "server"
        ],
        "quality_score": 0.35,
        "contributors_count": 0,
        "last_commit_date": "2024-12-09T12:07:44Z",
        "media_urls": [
            "https://repository-images.githubusercontent.com/869724660/b437114b-eb86-48eb-83ba-5d9befc76813"
        ],
        "homepage": "https://quicky.dev",
        "readme_summary": "Quicky CLI is a tool designed to simplify the deployment and management of self-hosted Next.js and Node.js applications. It offers features such as GitHub integration, automated process management with PM2, domain and SSL configuration, webhook management, and a dashboard for monitoring, aiming to streamline the entire application lifecycle on remote servers.",
        "key_features": [
            "GitHub Integration for project deployment and management",
            "Automated process management using PM2",
            "Simplified project updates and removal",
            "Automated domain and SSL certificate configuration with Nginx",
            "Configuration overview for deployed projects and domains",
            "Webhook management for continuous deployment",
            "Web-based dashboard for webhook server monitoring",
            "Log management for the webhook server"
        ],
        "primary_use_case": "Streamlining the deployment and management of self-hosted Next.js and Node.js applications.",
        "open_issues": 0,
        "cover_image_prompt": "A skilled architect meticulously overseeing the construction of a miniature city representing web applications. The architect, equipped with blueprints (representing configuration files), directs tiny robots (representing the CLI tool) that are automatically installing building blocks (representing Next.js and Node.js projects) onto server platforms. A glowing dome (representing SSL) protects the city. Small screens display deployment logs and domain configurations. The scene is set in a bright, futuristic workshop with a clean, organized layout. The image should be in a 3D isometric illustration style with vibrant colors and sharp details."
    },
    {
        "id": 869660918,
        "name": "mle-bench",
        "description": "MLE-bench is a benchmark for measuring how well AI agents perform at machine learning engineering",
        "url": "https://github.com/openai/mle-bench",
        "language": "Python",
        "stars": 651,
        "forks": 84,
        "created_at": "2024-10-08T17:07:40Z",
        "updated_at": "2025-03-21T20:37:08Z",
        "topics": [],
        "quality_score": 0.7,
        "contributors_count": 0,
        "last_commit_date": "2025-01-06T14:06:50Z",
        "media_urls": [
            "https://opengraph.githubassets.com/42ef58cb97aafe10f05810e7f6d71a4e1269f69cfdf06f3899bf06ff83ed3cd9/openai/mle-bench"
        ],
        "homepage": "https://openai.com/index/mle-bench/",
        "readme_summary": "MLE-bench is a benchmark designed to evaluate how well AI agents perform in machine learning engineering. It provides code for dataset construction, evaluation logic, and pre-evaluated agents. The repository also offers a recommended benchmarking setup and a 'lite' evaluation option using a low-complexity dataset split for faster and more cost-effective assessments.",
        "key_features": [
            "Dataset construction code",
            "Evaluation logic",
            "Evaluated agents",
            "Benchmarking setup recommendations",
            "Lite evaluation using Low complexity split"
        ],
        "primary_use_case": "Benchmarking AI agents' performance in machine learning engineering tasks.",
        "open_issues": 5,
        "cover_image_prompt": "Imagine a team of architects meticulously inspecting blueprints for a grand machine learning engineering structure. Each architect represents an AI agent, carefully analyzing different aspects of the blueprint (representing datasets and tasks). One architect uses a magnifying glass (representing evaluation logic) to identify potential flaws and areas for improvement. The blueprints are spread across a large table in a brightly lit studio, with subtle UI elements and data visualizations projected onto the walls. The repository name, 'MLE-bench,' is subtly etched onto a drafting tool. The scene should be in a detailed, 3D isometric illustration style with a focus on clarity and precision."
    },
    {
        "id": 481398639,
        "name": "caps-log",
        "description": "A small TUI journaling tool. 📖",
        "url": "https://github.com/NikolaDucak/caps-log",
        "language": "C++",
        "stars": 166,
        "forks": 5,
        "created_at": "2022-04-13T23:01:21Z",
        "updated_at": "2025-03-22T08:41:43Z",
        "topics": [
            "cmake",
            "cpp",
            "cpp17",
            "ftxui",
            "journaling",
            "terminal",
            "terminal-app",
            "terminal-based",
            "terminal-ui",
            "tui"
        ],
        "quality_score": 0.35,
        "contributors_count": 0,
        "last_commit_date": "2024-11-29T16:02:39Z",
        "media_urls": [
            "https://repository-images.githubusercontent.com/481398639/83241f34-7d7d-4024-b922-2e4246aaa2e7"
        ],
        "homepage": "",
        "readme_summary": "Caps-Log is a terminal-based journaling tool that stores entries as Markdown files. It allows users to organize their entries using sections and tags, and provides a calendar view that highlights dates based on selected tags or sections. The tool also supports external editor integration and git-based remote storage, and AES encryption.",
        "key_features": [
            "Terminal-based journaling",
            "Markdown log storage",
            "Section and tag-based organization",
            "Calendar highlighting based on tags/sections",
            "External editor integration via $EDITOR",
            "Git-based remote storage",
            "AES encryption for logs"
        ],
        "primary_use_case": "Personal journaling with organization and habit tracking features.",
        "open_issues": 10,
        "cover_image_prompt": "Imagine a meticulous librarian in a cozy, dimly lit study, carefully organizing scattered journal entries into a beautifully structured calendar. The librarian uses a magical quill that highlights important dates based on keywords and themes found within the entries. Bookshelves filled with journals line the walls, each spine subtly displaying the 'Caps-Log' logo. A soft, warm light illuminates the scene, creating a sense of nostalgia and reflection. Small UI elements float around the librarian, showing tag menus and section titles. The image should be in a digital painting style with rich details and a vintage aesthetic."
    },
    {
        "id": 764979648,
        "name": "godoxy",
        "description": "Easy to use reverse proxy with docker integration",
        "url": "https://github.com/yusing/godoxy",
        "language": "Go",
        "stars": 1463,
        "forks": 58,
        "created_at": "2024-02-29T03:52:35Z",
        "updated_at": "2025-03-22T08:26:20Z",
        "topics": [
            "docker",
            "go",
            "golang",
            "homepage",
            "letsencrypt",
            "microservice",
            "reverse-proxy",
            "self-hosted",
            "startpage"
        ],
        "quality_score": 0.9500000000000001,
        "contributors_count": 0,
        "last_commit_date": "2025-03-02T13:59:32Z",
        "media_urls": [
            "https://opengraph.githubassets.com/e24388148d9192228f547efb3ff1100c93731cc57a683fb476d98d17202c64bf/yusing/godoxy"
        ],
        "homepage": "",
        "readme_summary": "GoDoxy is a lightweight reverse proxy designed for easy integration with Docker. It automates SSL certificate management, dynamically creates routes based on Docker containers, and offers features like idle container management and a comprehensive Web UI. It simplifies the management and routing of microservices.",
        "key_features": [
            "Easy to use with effortless configuration",
            "Auto SSL with Let's Encrypt and DNS-01",
            "Auto hot-reload on container state/config file changes",
            "Dynamic route creation from Docker containers",
            "idlesleeper: stop containers on idle, wake up on traffic",
            "HTTP reverse proxy and TCP/UDP port forwarding",
            "OpenID Connect integration",
            "HTTP middleware and custom error pages support",
            "Web UI with App dashboard, config editor, uptime monitor, system monitor, docker logs viewer"
        ],
        "primary_use_case": "Reverse proxy with Docker integration for microservices.",
        "open_issues": 10,
        "cover_image_prompt": "Imagine a skilled air traffic controller in a bustling airport, expertly managing incoming and outgoing flights. Each plane represents a microservice, and the controller's tower is GoDoxy, seamlessly routing traffic to the correct destinations. The sky is filled with glowing digital pathways, subtly resembling network connections. A large screen in the tower displays a simplified dashboard with uptime monitors and docker logs. The scene is set at twilight, with a blend of natural and digital light. The illustration should be in a clean, modern flat design style with clear iconography and a vibrant color scheme."
    },
    {
        "id": 825279449,
        "name": "ai-renamer",
        "description": "A Node.js CLI that uses Ollama and LM Studio models (Llava, Gemma, Llama etc.) to intelligently rename files by their contents",
        "url": "https://github.com/ozgrozer/ai-renamer",
        "language": "JavaScript",
        "stars": 1766,
        "forks": 114,
        "created_at": "2024-07-07T10:44:27Z",
        "updated_at": "2025-03-22T08:34:45Z",
        "topics": [
            "ai",
            "automation",
            "cli-tool",
            "file-management",
            "file-renamer",
            "files",
            "image-renamer",
            "llama3",
            "lm-studio",
            "machine-learning",
            "ollama",
            "openai",
            "video-renamer"
        ],
        "quality_score": 0.7500000000000001,
        "contributors_count": 0,
        "last_commit_date": "2025-02-09T14:58:12Z",
        "media_urls": [
            "https://opengraph.githubassets.com/83fb4b31f6c233c3764bfbe6c67c1e0838e94264d2f7f1b4e954085155973264/ozgrozer/ai-renamer"
        ],
        "homepage": "https://airenamer.app",
        "readme_summary": "The ai-renamer is a Node.js CLI tool that leverages AI models from Ollama, LM Studio, or OpenAI to intelligently rename files based on their content. It supports various models and offers customization options for case style, character limits, and language, making file management more efficient and intuitive.",
        "key_features": [
            "Intelligently renames files based on their content using AI models.",
            "Supports Ollama, LM Studio, and OpenAI providers.",
            "Configurable model selection (Llava, Gemma, Llama, gpt-4o, etc.).",
            "Customizable output with options for case style, character limits, and language.",
            "Saves configuration parameters for persistent use.",
            "Supports image and video renaming with ffmpeg."
        ],
        "primary_use_case": "Intelligently renaming files (images, videos, documents) based on their content using AI models to improve organization and searchability.",
        "open_issues": 12,
        "cover_image_prompt": "A librarian meticulously organizing a chaotic collection of unlabeled files, using a magical monocle that reveals the content of each file and automatically generates a fitting title, which then appears on a label that affixes itself to the file. The librarian works in a brightly lit, futuristic library filled with glowing screens displaying snippets of code and data visualizations. The scene is rendered in a 3D isometric illustration style with clean lines and vibrant colors, subtly incorporating the 'ai-renamer' logo on a nearby bookshelf."
    }
]