[
    {
        "id": 597895841,
        "name": "data-morph",
        "description": "Morph an input dataset of 2D points into select shapes, while preserving the summary statistics to a given number of decimal points through simulated annealing. It is intended to be used as a teaching tool to illustrate the importance of data visualization.",
        "url": "https://github.com/stefmolin/data-morph",
        "language": "Python",
        "stars": 124,
        "forks": 24,
        "created_at": "2023-02-05T23:49:12Z",
        "updated_at": "2025-09-17T06:51:53Z",
        "topics": [
            "animation",
            "python",
            "simulated-annealing",
            "summary-statistics",
            "summary-stats"
        ],
        "quality_score": 1.1000000000000003,
        "contributors_count": 0,
        "last_commit_date": "2025-09-01T18:26:34Z",
        "media_urls": [
            "https://opengraph.githubassets.com/a0adaf5b8008d69489a9032956f1084a0e08fd1ec91a232c1357fc884454bdae/stefmolin/data-morph"
        ],
        "homepage": "https://stefaniemolin.com/data-morph/",
        "readme_summary": "The data-morph repository provides a tool to morph a dataset of 2D points into various shapes while preserving summary statistics using simulated annealing. It serves as a teaching aid to emphasize the significance of data visualization by demonstrating how datasets with similar summary statistics can appear vastly different when visualized.",
        "key_features": [
            "Morphing 2D point datasets",
            "Preserving summary statistics during transformation",
            "Simulated annealing optimization",
            "Educational tool for data visualization"
        ],
        "primary_use_case": "Illustrating the importance of data visualization in education.",
        "open_issues": 6,
        "cover_image_prompt": "A sculptor meticulously chiseling a block of raw data into a recognizable shape, like a star or a heart, while ghostly numbers representing summary statistics float around the sculpture, remaining constant throughout the process. The sculptor's tools glow with digital light, subtly displaying lines of Python code. The scene is set in a bright, modern art studio with large windows. Small screens display before-and-after data visualizations. The composition is clean and focused, using a pastel color scheme. The image should be in a 3D isometric illustration style with rich details and vibrant colors."
    },
    {
        "id": 1050594574,
        "name": "sound-of-sort",
        "description": "Sorting visualizer with image support and sonification",
        "url": "https://github.com/sahaj-b/sound-of-sort",
        "language": "Go",
        "stars": 46,
        "forks": 0,
        "created_at": "2025-09-04T16:48:34Z",
        "updated_at": "2025-09-15T15:58:44Z",
        "topics": [],
        "quality_score": 0.55,
        "contributors_count": 0,
        "last_commit_date": "2025-09-13T07:54:08Z",
        "media_urls": [
            "https://opengraph.githubassets.com/94348562fa0d1dbc59641ec462c4587f8dc796ca0c2fd38554bc443a18defbfb/sahaj-b/sound-of-sort"
        ],
        "homepage": "",
        "readme_summary": "The sound-of-sort repository is a Go-based terminal application that visualizes and sonifies various sorting algorithms. It renders the sorting process as a bar graph in the terminal and plays a tone for each element access or modification, with the pitch corresponding to the element's value. It also supports sorting ASCII/Unicode art piped via stdin, offering an image mode.",
        "key_features": [
            "Real-time Visualization of sorting algorithms as a bar graph",
            "Sonification of array element access and modification",
            "Interactive control of algorithms, speed, volume, and array size",
            "Image Mode for sorting ASCII/Unicode art",
            "Variety of sorting algorithms implemented"
        ],
        "primary_use_case": "Visualizing and sonifying sorting algorithms for educational or demonstrative purposes, and creatively sorting images represented as ASCII/Unicode art.",
        "open_issues": 1,
        "cover_image_prompt": "Imagine a skilled musician conducting an orchestra where each instrument represents a data element in an array. As the conductor sorts the instruments (data), the notes they play change in pitch and order, creating a symphony of sorting. A large screen behind the orchestra displays a bar graph that visually represents the sorting process in real-time. Subtle digital elements, like glowing data streams flowing between the instruments and the screen, connect the metaphor to software. The scene is set in a modern concert hall with dynamic lighting that emphasizes the key actions. The image should be in a 3D isometric illustration style with vibrant colors and rich details."
    },
    {
        "id": 907754163,
        "name": "airweave",
        "description": "Airweave lets agents search any app",
        "url": "https://github.com/airweave-ai/airweave",
        "language": "Python",
        "stars": 2887,
        "forks": 368,
        "created_at": "2024-12-24T10:00:06Z",
        "updated_at": "2025-09-17T09:20:33Z",
        "topics": [
            "agents",
            "knowledge-graph",
            "llm",
            "llm-agent",
            "rag",
            "search",
            "search-agent",
            "vector-database"
        ],
        "quality_score": 0.85,
        "contributors_count": 0,
        "last_commit_date": "2025-09-16T17:15:14Z",
        "media_urls": [
            "https://opengraph.githubassets.com/b50e573ec317f541a87fcb7c78c9a31497c8c0ac23219fc7cd9e9532dceb0854/airweave-ai/airweave"
        ],
        "homepage": "https://airweave.ai",
        "readme_summary": "Airweave is a tool that enables agents to search across various applications by transforming their content into searchable knowledge bases. It provides a standardized interface accessible through REST API or MCP, handling auth, extraction, embedding, and serving. Airweave essentially builds a semantically searchable MCP server.",
        "key_features": [
            "Connects to apps, productivity tools, databases, or document stores",
            "Transforms content into searchable knowledge bases",
            "Provides a standardized interface for agents",
            "Exposes search interface via REST API or MCP",
            "Handles auth, extraction, embedding, and serving"
        ],
        "primary_use_case": "Enabling agents to search any app by creating searchable knowledge bases from app content.",
        "open_issues": 3,
        "cover_image_prompt": "A librarian meticulously organizing a vast collection of digital documents from various app icons (Gmail, Asana, Github) into a glowing, interconnected knowledge graph. The librarian uses a special lens to categorize and link the documents, making them easily searchable. A small robot assistant helps by fetching and embedding new documents. UI elements showing search queries and results float around the scene. The setting is a futuristic library with soft, ambient lighting. The image should be in 3D isometric illustration style with clean lines and vibrant colors."
    },
    {
        "id": 750678695,
        "name": "WeClone",
        "description": "üöÄ One-stop solution for creating your digital avatar from chat history üí° Fine-tune LLMs with your chat logs to capture your unique style, then bind to a chatbot to bring your digital self to life.  ‰ªéËÅäÂ§©ËÆ∞ÂΩïÂàõÈÄ†Êï∞Â≠óÂàÜË∫´ÁöÑ‰∏ÄÁ´ôÂºèËß£ÂÜ≥ÊñπÊ°à  ",
        "url": "https://github.com/xming521/WeClone",
        "language": "Python",
        "stars": 15505,
        "forks": 1223,
        "created_at": "2024-01-31T05:11:12Z",
        "updated_at": "2025-09-17T10:00:32Z",
        "topics": [
            "chat-history",
            "digital-avatar",
            "llm",
            "qwen",
            "telegram"
        ],
        "quality_score": 1.1000000000000003,
        "contributors_count": 0,
        "last_commit_date": "2025-08-27T13:31:46Z",
        "media_urls": [
            "https://repository-images.githubusercontent.com/750678695/7d2a5592-c303-4db4-a76d-4360a2751138"
        ],
        "homepage": "https://weclone.love",
        "readme_summary": "WeClone is a one-stop solution for creating digital avatars from chat history. It allows users to fine-tune LLMs with their chat logs to capture their unique style and then bind the model to a chatbot to bring their digital self to life. The project supports multiple platforms like Telegram and aims to provide a secure and controllable way to create personalized digital representations.",
        "key_features": [
            "Complete end-to-end solution for creating digital avatars",
            "Fine-tune LLM using chat history with support for image modal data",
            "Integrate with Telegram, WhatsApp (coming soon) to create your own digital avatar",
            "Privacy information filtering with localized fine-tuning and deployment for secure and controllable data"
        ],
        "primary_use_case": "Creating digital avatars from chat history by fine-tuning LLMs.",
        "open_issues": 35,
        "cover_image_prompt": "A skilled artisan meticulously crafting a digital puppet from threads of chat bubbles, each bubble containing snippets of conversations. The artisan uses a magical loom that weaves these threads into a lifelike avatar. Small screens display training progress and code snippets, subtly connecting the craft to software. The scene is set in a bright, airy workshop filled with digital tools and glowing interfaces. The composition is clean and focused, with a vibrant color scheme. The image should be in 3D isometric illustration style with rich details and vibrant colors."
    },
    {
        "id": 730932260,
        "name": "torchtitan",
        "description": "A PyTorch native platform for training generative AI models",
        "url": "https://github.com/pytorch/torchtitan",
        "language": "Python",
        "stars": 4399,
        "forks": 518,
        "created_at": "2023-12-13T01:51:37Z",
        "updated_at": "2025-09-17T09:46:40Z",
        "topics": [],
        "quality_score": 0.95,
        "contributors_count": 0,
        "last_commit_date": "2025-09-16T20:19:29Z",
        "media_urls": [
            "https://opengraph.githubassets.com/becaee5a8f316d09a9aab4521dfabd3d94b5032d3ee37ff4501a0b813836ac17/pytorch/torchtitan"
        ],
        "homepage": "",
        "readme_summary": "Torchtitan is a PyTorch-native platform designed for rapid experimentation and large-scale training of generative AI models. It provides a flexible foundation for developers to build upon, showcasing PyTorch's latest distributed training features, particularly for pretraining large language models like Llama 3.1.",
        "key_features": [
            "PyTorch native implementation",
            "Rapid experimentation",
            "Large-scale training",
            "Support for generative AI models",
            "Extension points for customization",
            "Showcasing PyTorch's distributed training features",
            "Support for Llama 3.1 LLMs",
            "Minimal changes to model code for parallelism",
            "Clean and minimal codebase"
        ],
        "primary_use_case": "Training generative AI models at scale using PyTorch.",
        "open_issues": 111,
        "cover_image_prompt": "A team of architects constructing a colossal AI brain from glowing PyTorch code blocks, using blueprints labeled 'Generative Models'. The brain sits atop a powerful server farm, with data streams flowing in and out. One architect holds a 'torchtitan' branded hammer, carefully placing a crucial code block. Small UI elements display training metrics and model architectures. The scene is set in a futuristic workshop with bright, optimistic lighting. The image should be in 3D isometric illustration style with clean lines, vibrant colors, and a focus on clarity."
    },
    {
        "id": 841511741,
        "name": "D-FINE",
        "description": "D-FINE: Redefine Regression Task of DETRs as Fine-grained Distribution Refinement  [ICLR 2025 Spotlight]",
        "url": "https://github.com/Peterande/D-FINE",
        "language": "Python",
        "stars": 2686,
        "forks": 249,
        "created_at": "2024-08-12T14:52:39Z",
        "updated_at": "2025-09-17T06:55:18Z",
        "topics": [
            "d-fine",
            "detr",
            "object-detection"
        ],
        "quality_score": 0.8500000000000001,
        "contributors_count": 0,
        "last_commit_date": "2025-07-09T14:33:56Z",
        "media_urls": [
            "https://opengraph.githubassets.com/2e662875dc396215dc655579fdadc9ee74c4d0696c47694e6064ad44bed5a5a0/Peterande/D-FINE"
        ],
        "homepage": "",
        "readme_summary": "D-FINE is a real-time object detection model that refines bounding box regression in DETRs (Detection Transformers) using Fine-grained Distribution Refinement (FDR). It also introduces Global Optimal Localization Self-Distillation (GO-LSD) to improve performance without increasing inference or training costs. The model excels in challenging conditions, such as backlighting and motion blur, demonstrating high confidence scores and precise localization, especially for small objects.",
        "key_features": [
            "Fine-grained Distribution Refinement (FDR)",
            "Global Optimal Localization Self-Distillation (GO-LSD)",
            "Real-time object detection",
            "High performance without additional inference/training costs",
            "Improved localization precision",
            "Robustness to challenging conditions (backlighting, motion blur)"
        ],
        "primary_use_case": "Real-time object detection, particularly in scenarios requiring high precision and robustness to challenging visual conditions.",
        "open_issues": 147,
        "cover_image_prompt": "Imagine a skilled artisan meticulously refining a blurry photograph into a sharp, detailed image using a set of specialized lenses and tools. The artisan represents D-FINE, and the blurry photo symbolizes the initial object detection. As the artisan works, the image becomes increasingly clear, revealing subtle details. Small UI elements displaying object detection bounding boxes and confidence scores subtly overlay the scene. The setting is a brightly lit workshop with a clean, focused composition. The image should be in a 3D isometric illustration style with vibrant colors and rich details."
    }
]