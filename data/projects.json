[
    {
        "id": 89359792,
        "name": "check-if-email-exists",
        "description": "Check if an email address exists without sending any email, written in Rust. Comes with a ⚙️ HTTP backend.",
        "url": "https://github.com/reacherhq/check-if-email-exists",
        "language": "Rust",
        "stars": 5676,
        "forks": 433,
        "created_at": "2017-04-25T12:47:51Z",
        "updated_at": "2025-12-14T05:12:01Z",
        "topics": [
            "email",
            "email-validation",
            "email-validation-api",
            "email-verification",
            "email-verification-api",
            "email-verifier",
            "hacktoberfest"
        ],
        "quality_score": 0.7000000000000001,
        "contributors_count": 0,
        "last_commit_date": "2025-07-06T16:47:30Z",
        "media_urls": [
            "https://repository-images.githubusercontent.com/89359792/e9ac7100-2478-11eb-9ffd-9b8c08bb11e9"
        ],
        "homepage": "https://reacher.email",
        "readme_summary": "This Rust repository provides a tool to check if an email address is valid and deliverable without sending an actual email. It offers a programmatic API, a CLI, and a Dockerized HTTP backend for integration into various applications.",
        "key_features": [
            "Email existence check without sending emails",
            "Rust library for programmatic usage",
            "Dockerized HTTP backend API",
            "Command-line interface (CLI) tool",
            "Support for SOCKS5 proxies",
            "Detailed JSON output including disposable and role account detection"
        ],
        "primary_use_case": "Verifying the existence and deliverability of email addresses in bulk or individually without the risk of triggering spam filters or sending unwanted emails.",
        "open_issues": 68,
        "cover_image_prompt": "A digital detective, wearing a magnifying glass headset, examining a stream of glowing email icons flowing from a server rack. The detective points a beam of light at specific icons, which then transform into either a green checkmark (valid) or a red 'X' (invalid), with some icons subtly revealing 'disposable' or 'role' labels. The background is a clean, abstract digital space with subtle code snippets and data visualizations. The overall mood is one of precision and efficiency, with a modern, sleek aesthetic. The repository name 'check-if-email-exists' is subtly integrated into a digital display screen in the scene. Style: 3D isometric illustration with vibrant, contrasting colors."
    },
    {
        "id": 950564038,
        "name": "unity-mcp",
        "description": "An MCP server that allows MCP clients like Claude Desktop or Cursor to perform actions in the Unity Editor",
        "url": "https://github.com/CoplayDev/unity-mcp",
        "language": "C#",
        "stars": 4254,
        "forks": 569,
        "created_at": "2025-03-18T11:01:58Z",
        "updated_at": "2025-12-13T23:33:24Z",
        "topics": [
            "ai",
            "ai-integration",
            "anthropic",
            "claude",
            "claude-co",
            "copilot",
            "cursor",
            "deepseek",
            "game-development",
            "gamedev",
            "gemini",
            "llm",
            "mcp",
            "model-context-protocol",
            "openai",
            "unity",
            "unity3d",
            "videogames"
        ],
        "quality_score": 1.0000000000000002,
        "contributors_count": 0,
        "last_commit_date": "2025-12-13T23:33:20Z",
        "media_urls": [
            "https://repository-images.githubusercontent.com/950564038/eca80507-594c-42f0-b5b5-c1f7443ea535"
        ],
        "homepage": "https://www.coplay.dev",
        "readme_summary": "Unity MCP is a server that enables AI assistants, such as Claude and Cursor, to interact directly with the Unity Editor. It acts as a bridge, allowing LLMs to control assets, scenes, scripts, and automate tasks within Unity using the Model Context Protocol.",
        "key_features": [
            "Natural Language Control",
            "Powerful Tools for asset, scene, material, script management",
            "Automation of repetitive Unity workflows",
            "Extensible design for various MCP Clients",
            "HTTP-First Transport with stdio fallback"
        ],
        "primary_use_case": "Allowing AI assistants (LLMs) to directly control and automate tasks within the Unity Editor.",
        "open_issues": 25,
        "cover_image_prompt": "A skilled conductor standing in front of a grand orchestra pit, but instead of musical instruments, the orchestra consists of various Unity Editor elements like GameObjects, assets, and script icons. The conductor holds a glowing baton, directing the elements with precise gestures, causing them to assemble, transform, and animate harmoniously. Digital streams of natural language commands flow from a stylized AI assistant hovering subtly in the background towards the conductor. The scene is set within a stylized, clean Unity Editor environment, with subtle code snippets and data visualizations appearing as ambient elements. The overall mood is one of creative control and seamless integration. Rendered in a vibrant 3D isometric illustration style with clear iconography and a focus on the conductor's interaction with the Unity elements."
    },
    {
        "id": 910107320,
        "name": "Constrict",
        "description": "Compress videos to target sizes.",
        "url": "https://github.com/Wartybix/Constrict",
        "language": "Python",
        "stars": 203,
        "forks": 16,
        "created_at": "2024-12-30T14:08:06Z",
        "updated_at": "2025-12-14T05:10:08Z",
        "topics": [
            "compressor",
            "gtk",
            "gtk4",
            "libadwaita",
            "linux",
            "video-compressor"
        ],
        "quality_score": 0.7499999999999999,
        "contributors_count": 0,
        "last_commit_date": "2025-12-13T19:54:29Z",
        "media_urls": [
            "https://opengraph.githubassets.com/66433b52145f700822bdf91d52229780d8c0832cc7c611aa63d2a5622db8dc40/Wartybix/Constrict"
        ],
        "homepage": "https://flathub.org/apps/io.github.wartybix.Constrict",
        "readme_summary": "Constrict is a desktop application that compresses video files to a user-defined target file size. It automates the complex process of re-encoding videos by intelligently adjusting parameters like bitrate, resolution, and framerate to achieve the desired size while aiming to preserve audiovisual quality.",
        "key_features": [
            "Intuitive GUI for easy video compression",
            "Automatic calculation of encoding parameters (ABR, resolution, framerate, audio quality) to meet target file size",
            "Bulk compression of multiple videos",
            "Customizable framerate limits",
            "Support for multiple codecs (H.264, HEVC, AV1, VP9)",
            "Local processing for privacy and control"
        ],
        "primary_use_case": "Compressing video files to meet specific size limitations for uploads or storage, without manual trial-and-error.",
        "open_issues": 4,
        "cover_image_prompt": "A skilled tailor meticulously adjusting a large, unraveled ball of video film. With precise tools and a digital measuring tape displaying target file sizes, the tailor is expertly weaving the film into a compact, neatly wound spool. The original film is visibly large and chaotic, while the output spool is small and orderly. Subtle glowing lines of code and UI elements from the Constrict application are integrated into the tailor's workbench. The scene is set in a clean, modern workshop with soft, focused lighting, emphasizing the transformation. The image should be in a 3D isometric illustration style with a clean, organized composition and a color palette that highlights the transition from chaos to order."
    },
    {
        "id": 1049730948,
        "name": "richpixelvid",
        "description": "Play videos in your terminal using rich-pixel",
        "url": "https://github.com/pj4533/richpixelvid",
        "language": "Python",
        "stars": 7,
        "forks": 0,
        "created_at": "2025-09-03T12:16:07Z",
        "updated_at": "2025-12-13T21:50:21Z",
        "topics": [],
        "quality_score": 0.15,
        "contributors_count": 0,
        "last_commit_date": "2025-09-03T12:16:43Z",
        "media_urls": [
            "https://opengraph.githubassets.com/25d0ee97992ba632e1a51c7a930131c3d2603cb2daa13b510e35d79f471503a6/pj4533/richpixelvid"
        ],
        "homepage": null,
        "readme_summary": "Rich-Pixel Video Player is a Python tool that plays video files directly in your terminal using Unicode characters for a retro, pixelated visual style. It leverages the rich-pixels library to render video frames with enhanced vertical resolution.",
        "key_features": [
            "Terminal-based video playback using Unicode half-block characters",
            "Automatic terminal size detection and video scaling",
            "Configurable playback frame rate",
            "Loop playback option",
            "Memory-efficient streaming",
            "Support for various video formats",
            "Graceful interrupt handling"
        ],
        "primary_use_case": "Playing video files in a terminal with a unique retro-style visualization.",
        "open_issues": 0,
        "cover_image_prompt": "A vintage television set placed in a dimly lit, cozy room, but instead of a screen, it displays a vibrant, retro-style video composed entirely of colorful Unicode block characters (▄). A small, stylized 'richpixelvid' logo is subtly integrated into the TV's frame. The room has subtle digital elements like glowing circuit patterns on the wallpaper and a few floating data particles. The overall mood is nostalgic and tech-infused, with warm ambient lighting. The art style should be a 3D isometric illustration with a focus on clear, readable textures and a slightly stylized, playful aesthetic."
    },
    {
        "id": 1046149099,
        "name": "refund-swatter-lite",
        "description": "Refund Swatter Lite significantly reduces malicious refund risks by processing Apple's CONSUMPTION_REQUEST notifications and sending detailed consumption data back to Apple within the required 12-hour window, enabling Apple to make informed decisions on refund requests.",
        "url": "https://github.com/argus-sight/refund-swatter-lite",
        "language": "TypeScript",
        "stars": 146,
        "forks": 12,
        "created_at": "2025-08-28T09:04:32Z",
        "updated_at": "2025-12-11T05:46:54Z",
        "topics": [
            "anti-abuse",
            "app-store",
            "app-store-server-api",
            "app-store-server-notifications",
            "chargeback",
            "consumption-data",
            "consumption-request",
            "deno",
            "fraud-prevention",
            "iap",
            "in-app-purchase",
            "ios",
            "open-source-saas",
            "refund",
            "refund-prevention",
            "saas",
            "security",
            "serverless",
            "subscription-management",
            "supabase"
        ],
        "quality_score": 0.85,
        "contributors_count": 0,
        "last_commit_date": "2025-09-30T06:32:39Z",
        "media_urls": [
            "https://opengraph.githubassets.com/6f4958f7090536c5027d6c7fdbed4ee7b18b855dd04d7abfd14598882fa3334a/argus-sight/refund-swatter-lite"
        ],
        "homepage": "https://lite.refundswatter.com",
        "readme_summary": "Refund Swatter Lite is a serverless, single-tenant application built on Supabase designed to prevent fraudulent App Store refunds. It processes Apple's CONSUMPTION_REQUEST notifications in real-time, sending back essential consumption data to help Apple make informed refund decisions.",
        "key_features": [
            "Bring Your Own Key (BYOK) for In-App Purchase Keys",
            "Real-time processing of CONSUMPTION_REQUEST notifications",
            "100% Supabase architecture, no additional servers",
            "Automated workflow",
            "Calculates all 12 required Apple consumption fields",
            "Secure private key storage in Supabase Vault",
            "Simple one-command setup"
        ],
        "primary_use_case": "Preventing fraudulent App Store refunds by automating the response to Apple's consumption request notifications.",
        "open_issues": 0,
        "cover_image_prompt": "A vigilant digital gatekeeper, represented by a stylized shield with the 'Refund Swatter Lite' logo subtly integrated, stands before a glowing portal representing the App Store. Incoming 'CONSUMPTION_REQUEST' notifications, depicted as small, urgent envelopes, are intercepted by the gatekeeper. The gatekeeper analyzes each envelope, and based on its contents (represented by glowing data streams), either allows it through with a positive confirmation (a green checkmark) or flags it for review (a subtle red warning). The scene is set in a clean, futuristic digital space with soft blue and green lighting, emphasizing security and automation. Small, abstract UI elements showing data flow and processing are visible in the background. The overall style is a 3D isometric illustration with a focus on clarity and a modern, secure aesthetic."
    },
    {
        "id": 1054563053,
        "name": "Logics-Parsing",
        "description": null,
        "url": "https://github.com/alibaba/Logics-Parsing",
        "language": "Python",
        "stars": 797,
        "forks": 66,
        "created_at": "2025-09-11T02:57:24Z",
        "updated_at": "2025-12-14T00:34:01Z",
        "topics": [],
        "quality_score": 0.6,
        "contributors_count": 0,
        "last_commit_date": "2025-10-13T01:50:46Z",
        "media_urls": [
            "https://opengraph.githubassets.com/462241b4717e4366f79e1c7b8184075dcbb1e228f3d0ead7e528d35bc1d5e49d/alibaba/Logics-Parsing"
        ],
        "homepage": null,
        "readme_summary": "Logics-Parsing is an end-to-end document parsing model that uses a Vision-Language Model (VLM) to accurately analyze and structure complex documents, including scientific formulas and chemical structures. It outputs rich, structured HTML with content category, bounding boxes, and OCR text, while filtering out irrelevant elements.",
        "key_features": [
            "Effortless End-to-End Processing",
            "Advanced Content Recognition (including scientific formulas and SMILES for chemical structures)",
            "Rich, Structured HTML Output (with category, bounding box, OCR text)",
            "Automatic filtering of irrelevant elements (headers, footers)",
            "State-of-the-Art Performance on complex-layout and STEM documents"
        ],
        "primary_use_case": "Accurate and structured parsing of complex documents, especially those containing scientific content like formulas and chemical structures.",
        "open_issues": 14,
        "cover_image_prompt": "A master cartographer meticulously unrolling an ancient, complex map filled with intricate symbols, scientific formulas, and chemical diagrams. The cartographer uses a glowing magnifying glass to identify and categorize each element, drawing precise boundaries around them. As they work, the map transforms into a clean, organized digital blueprint with clear labels and structured sections, representing the structured HTML output. Subtle digital particles and faint code snippets float around the scene, hinting at the underlying AI. The overall mood is one of discovery and precision, set in a dimly lit, scholarly study. 3D isometric illustration style with a focus on clear detail and a rich, parchment-and-digital color palette."
    }
]